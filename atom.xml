<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>撸猫青年的小窝</title>
  
  <subtitle>日拱一卒 功不唐捐</subtitle>
  <link href="/hlblog/atom.xml" rel="self"/>
  
  <link href="www.hlblogs.com/"/>
  <updated>2019-01-24T08:25:14.029Z</updated>
  <id>www.hlblogs.com/</id>
  
  <author>
    <name>撸猫青年</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于String的一点思考</title>
    <link href="www.hlblogs.com/2019/01/24/java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EString%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>www.hlblogs.com/2019/01/24/java基础/关于String的一些思考/</id>
    <published>2019-01-23T16:00:00.000Z</published>
    <updated>2019-01-24T08:25:14.029Z</updated>
    
    <content type="html"><![CDATA[<p>对String的一些思考: 包括String的不可变性、String对‘+’的处理、String.valueOf和Integer.toString的区别、几种不同的String创建方式的区别等等。</p><a id="more"></a><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><p>String是不可变、不可继承的，这点是众所周知的，因为它是被final修饰的(这里不对final做过多的解释)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String源码省略。。。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么为什么要把它涉及成不可变的呢？</p><ol><li><p>出于设计考虑，字符串常量池的需要<br>对于常量来说，重复创建是比较浪费资源且没有必要的，同一个字符串常量，只需要在常量池中创建一个就够了，如果其他地方需要这个字符串常量，那么它只需要引用原来常量池中的那一个就够了。</p></li><li><p>处于效率优化考虑<br>因为String是不可变的，所以String中的hash码也是不变的，这样就不用每一次使用的时候都去计算新的hash值。同时，因为它的hash值是不变的，它才能够在HashSet、HashMap等容器中不出问题。假如它的hash值是可变的，那该多尴尬，你计算了一个Stirng类型的key的hash值，将key和value保存在HashMap中了，然后它被修改了，新的hash值与原来不同了，那么再以这个String作为key去存取数据，结果必然是有问题的。</p></li><li><p>处于安全性考虑<br>String在非常多的类中被用来当做参数，同时它还被用来保存配置信息，如果它是可变的，那么势必会带来一些隐蔽性很高的隐患。</p></li></ol><p>处于上面这几点我们暂且认为这样设计非常好，但是为什么不把所有的类都设计成不可变的呢，毕竟它安全，效率又高？<br>如果将所有的类都设计成不可变的，那么每一次的修改都会创建一个新的实例，这样性能就很低。同时，大量的实例产生背后是大量的实例等待回收，垃圾回收的任务太重，也会降低系统性能。<br>一般来说我们在使用HashSet和HashMap这类容器的时候不太会用String之外的类实例来作为key，所以基本上就不需要确保hash值的唯一性。</p><h1 id="String对‘-’的处理"><a href="#String对‘-’的处理" class="headerlink" title="String对‘+’的处理"></a>String对‘+’的处理</h1><p>由于String类被设计成不可变的，所以String对象的每一次的修改都会创建一个新的String实例。对于‘+’的处理分为两种情况:<br>第一种就是类似于String str1 = “abc”+”def”这种情况，这里设计到java编译器的一个优化手段，那就是”abc”是String常量,”def”也是一个String常量，所以在编译期间它们就会被合成一个字符串”abcdef”，然后放入字符串常量池中。<br>第二种呢就是类似于String str2 = str1 + “def”这种情况，这里的str1是一个String变量，它是不确定的，这里的str1+”def”不会有有上面的编译期优化出现，也不会被主动放进字符串常量池中。</p><h1 id="String-valueOf和Integer-toString的区别"><a href="#String-valueOf和Integer-toString的区别" class="headerlink" title="String.valueOf和Integer.toString的区别"></a>String.valueOf和Integer.toString的区别</h1><p>String.valueOf有很多个重载方法，其中形参为int类型的重载方法内部调用的的就是Integer.toString,代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而Integer.toString方法最终使用的是new String的方式。<br>如果想将一个int类型的变量转化成字符串，那么使用String.valueOf和Integer.toString是没有区别的。但是如果使用int+””这种形式，区别就比较大了，因为这种方式底层使用的是StringBuilder。</p><h1 id="几种不同的String创建方式的区别"><a href="#几种不同的String创建方式的区别" class="headerlink" title="几种不同的String创建方式的区别"></a>几种不同的String创建方式的区别</h1><p>比较常见的String实例创建方式有:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span> + <span class="string">"def"</span>;  <span class="comment">//常量+常量</span></span><br><span class="line">String str2 = str1 + <span class="string">"ghi"</span>;   <span class="comment">//变量+常量  或  变量+变量</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abcdefghi"</span>);  <span class="comment">//使用new关键字</span></span><br><span class="line">String str4 = String.valurOf(<span class="number">666</span>);      <span class="comment">//使用valueOf</span></span><br></pre></td></tr></table></figure></p><p>常量+常量 :  这种创建方式，编译器会在编译期将多个常量合成一个，放入字符串常量池中，最后str1引用的是字符串常量池中的那个地址。<br>变量+常量 :  这种创建方式，不会被优化，在运行期它的值才会被确定下来，并且它是不会被放入字符串常量池中的。<br>new关键字 :  字符串参数的处理同上面的两种情况，这里还有一个不同就是new关键字会在堆内存中再创建一个String实例，所以使用new关键字实际上相当于创建了两个实例，一个在堆内存中，一个在字符串常量池中。<br>valueOf  : valueOf的创建形式内部还是使用了new关键字。</p><h1 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h1><p>intern方法的用户只有一个，那就是在运行时将字符串放入字符串常量池中并返回常量池中的那个地址。具体的情况我下面会举例。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>来看几道笔试题吧<br>一:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">"ab"</span>;</span><br><span class="line">String str4 = <span class="string">"abc"</span>;</span><br><span class="line">String str5 = str3 + <span class="string">"c"</span>;</span><br><span class="line">System.out.println(str4 == str5);</span><br></pre></td></tr></table></figure></p><p>输出结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>str1被创建时因为”abc”是常量，所以它在编译期就被放入了常量池中，str1引用的是常量池中的地址<br>str2被创建时因为”a”、”b”、”c”都是常量，所以在它们会被优化成一个常量”abc”放入到常量池中，但是因为常量池中已经有一个”abc”了，所以会直接返回这个常量的地址，也就是str1引用的那个地址，所以str1 == str2为.<br>对于str4和str5来说，str4引用的是常量池中的地址，但是由于str3是变量，所以str5应用的地址并不是常量池中的”abc”的地址，所以str4 == str5结果为false.</p><p>二 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">"a"</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(sss+<span class="string">"b"</span>);</span><br><span class="line">System.out.println(str3.intern() == str3);</span><br><span class="line"></span><br><span class="line">String str4 = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>).append(<span class="string">"def"</span>).toString();</span><br><span class="line">System.out.println(str4.intern() == str4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str5 = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>).append(<span class="string">"def"</span>).toString();</span><br><span class="line">System.out.println(str5.intern() == str5);</span><br></pre></td></tr></table></figure></p><p>输出结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>“abcd”在编译期会被放入到字符串常量池中，所以str1.intern实际返回的是”abcd”在常量池中的地址,而str1是存在于堆内存中的，所以str1.intern()==str1结果为false<br>str3.intern()这个操作会把str3放入到字符串常量池中，然后返回str3的地址，所以str3.intern() == str3结果为true<br>str4.intern()==str4结果为true的原理和上面str3.intern() == str3结果为true的原理是一样的<br>str5.intern()将str5放入字符串常量池，但是因为str4已经被放入常量池中了，所以这里返回的其实是str4的地址，所以str5.intern() == str5结果为false。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对String的一些思考: 包括String的不可变性、String对‘+’的处理、String.valueOf和Integer.toString的区别、几种不同的String创建方式的区别等等。&lt;/p&gt;
    
    </summary>
    
      <category term="java基础" scheme="www.hlblogs.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="www.hlblogs.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>关于int类型取值范围的一点思考</title>
    <link href="www.hlblogs.com/2019/01/03/java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8Eint%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
    <id>www.hlblogs.com/2019/01/03/java基础/关于int取值范围的一点思考/</id>
    <published>2019-01-02T16:00:00.000Z</published>
    <updated>2019-01-03T03:16:51.599Z</updated>
    
    <content type="html"><![CDATA[<p>java中int类型占四个字节，32位的，如果是有符号的数，那么四个字节能表示的范围-2147483648（-2^31） ~ 2147483647 （2^31-1），<br>如果是无符号数，那么四个字节能表示的范围是0–4294967295(2^32-1)。<br>java中没有有符号和无符号的说法，都是取有符号的这种情况，所以在java中int类型的取值范围是-2147483648 ~ 2147483647，即-2^31 ~ 2^31-1。但是这个范围的底层原理是什么呢？下面讲一讲我的思考过程。</p><a id="more"></a><p>int类型的最大值是2^31-1比较好理解，在java中，int类型转换为二进制数据的第一个位代表正负，0为正，1为负。所以int类型的最大值的二进制文件应该是 0111 1111 1111 1111 1111 1111 1111 1111。 转换为10进制int类型为 2^0 + 2^1 + 2^2 + 2^3 + … + 2^30 = 2^31 - 1。</p><p>int类型的最小值是-2^31,关于这个最小值，我钻了牛角尖，简单的以后最小值应该是 -(2^31-1),即-2147483647，但是事实上却是-2^31，即-2147483648。后来冥思苦想了很久才从牛角尖中钻出来，觉得十分有必要记录一下。</p><p><strong>错误的思路:</strong><br>我为什么钻了牛角尖，刚刚说到，int类型的最大值转换为二进制为 0111 1111 1111 1111 1111 1111 1111 1111，然后又讲到二进制位的第一个位代表正负，0为正，1为负，所以最小值的表示应该是1111 1111 1111 1111 1111 1111 1111 1111，即 -(2^31-1)，看起来合情合理，所以我钻进了牛角尖。当然这也反映出我的基础还有待加强。</p><p><strong>正确的思路:</strong><br>为什么上面这种思路是错误的呢？因为计算机中的负数根本就不是那么表示的(汗，大学的时候学过的，全都还给老师了。)<br>在计算机中，所有的负数都是用补码去表示的。这里顺带提一下二进制数中的原码，反码和补码。</p><p>原码:<br>int类型直接转换成二进制数就是原码，比如8的二进制为 0000 0000 0000 0000 0000 0000 0000 1000。</p><p>反码:<br>将原码全部取反就得到了反码，比如上面8的二进制反码为 1111 1111 1111 1111 1111 1111 1111 0111</p><p>补码:<br>将反码+1,得到的就是补码,比如8的二进制补码为 1111 1111 1111 1111 1111 1111 1111 1000</p><p>因为正整数的首位必须要是0，所以一个32位的二进制数，能够表示数值的，只能是后面的31位，而负整数的首位是1，这个1呢，它不能完全按照符号位来理解，它也是可以参与数值的表示的。<br>比如int类型的最大值2^31-1，二进制为 0111 1111 1111 1111 1111 1111 1111 1111，<br>所以它的反码为1000 0000 0000 0000 0000 0000 0000 0000，<br>它的补码为1000 0000 0000 0000 0000 0000 0000 0001。</p><p>那么-(2^31-1)即-2147483647的二进制表示应该就是1000 0000 0000 0000 0000 0000 0000 0001，<br>补码再减1，就是1000 0000 0000 0000 0000 0000 0000 0000，即十进制中的-2147483648，也就是-2^31。<br>仔细看看-2^31的补码,首位为1，这个时候的首位，其实同时充当了符号位和数值位，以上面-(2^31-1)的补码为例，首位是1，所以这是一个负数，并且由于首位是1，所以首位代表的数为-2^31，同时，最后一位是1，所以应该再加上1，即-2^31+1。</p><p>所以，二进制中补码的规则，可以看成是-2^(长度-1) + (除首位以外的值的和)，比如-1的二进制表示为 11111111111111111111111111111111，<br>它就可以看成是 -2^31 +（2^31-1） = -1。</p><p>这样一来为什么int类型的最小值为-2^31就彻底搞明白了。</p><p><strong>int类型溢出</strong><br>我们都知道，Integer.MAX_VALUE + 1或者是Integer.MIN_VALUE-1都会产生溢出，Integer.MAX_VALUE+1=Integer.MIN_VALUE,Integer.MIN_VALUE-1=Integer.MAX_VALUE。<br>只要想明白了上面的二进制表示问题，溢出的原因就很好解释了。</p><p>Integer.MAX_VALUE的二进制表示为 01111111111111111111111111111111，再加1的话就会变成1000 0000 0000 0000 0000 0000 0000 0000，这也就是Integer.MIN_VALUE的二进制值。  </p><p>Integer.MIN_VALUE的二进制表示为 1000 0000 0000 0000 0000 0000 0000 0000,再减去1的话就会变成 01111111111111111111111111111111，这也就是Integer.MAX_VALUE的二进制值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java中int类型占四个字节，32位的，如果是有符号的数，那么四个字节能表示的范围-2147483648（-2^31） ~ 2147483647 （2^31-1），&lt;br&gt;如果是无符号数，那么四个字节能表示的范围是0–4294967295(2^32-1)。&lt;br&gt;java中没有有符号和无符号的说法，都是取有符号的这种情况，所以在java中int类型的取值范围是-2147483648 ~ 2147483647，即-2^31 ~ 2^31-1。但是这个范围的底层原理是什么呢？下面讲一讲我的思考过程。&lt;/p&gt;
    
    </summary>
    
      <category term="java基础" scheme="www.hlblogs.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="www.hlblogs.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>最大堆与最小堆</title>
    <link href="www.hlblogs.com/2018/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%A0%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%A0%86(writing)/"/>
    <id>www.hlblogs.com/2018/12/17/数据结构与算法/最大堆与最小堆(writing)/</id>
    <published>2018-12-16T16:00:00.000Z</published>
    <updated>2018-12-17T08:56:35.251Z</updated>
    
    <content type="html"><![CDATA[<p>常用的最大/小堆其实就是一颗完全二叉树。<br>除了完全二叉树所具有的基本特性以外，最大/小堆还有以下特性:<br>1.最大堆父节点一定大于子节点，最小堆父节点一定小于子节点。<br>2.因为是完全二叉树，所以一般用数组来表示，如果某个节点的节点位置在下标n处，那么其左孩子节点为：<font color="red">2 <em> n + 1</em></font> ，其右孩子节点为<font color="red">2  (n + 1)</font>，其父节点为<font color="red">(n – 1) / 2</font> 处。 </p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;常用的最大/小堆其实就是一颗完全二叉树。&lt;br&gt;除了完全二叉树所具有的基本特性以外，最大/小堆还有以下特性:&lt;br&gt;1.最大堆父节点一定大于子节点，最小堆父节点一定小于子节点。&lt;br&gt;2.因为是完全二叉树，所以一般用数组来表示，如果某个节点的节点位置在下标n处，那么其左孩子节点为：&lt;font color=&quot;red&quot;&gt;2 &lt;em&gt; n + 1&lt;/em&gt;&lt;/font&gt; ，其右孩子节点为&lt;font color=&quot;red&quot;&gt;2  (n + 1)&lt;/font&gt;，其父节点为&lt;font color=&quot;red&quot;&gt;(n – 1) / 2&lt;/font&gt; 处。 &lt;/p&gt;
    
    </summary>
    
      <category term="数据结构与算法" scheme="www.hlblogs.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="www.hlblogs.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>2.Trailing Zeros</title>
    <link href="www.hlblogs.com/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/2.Trailing%20Zeros/"/>
    <id>www.hlblogs.com/2018/12/13/刷题/LintCode/2.Trailing Zeros/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-18T03:17:45.860Z</updated>
    
    <content type="html"><![CDATA[<p>2.Trailing Zeros<br><strong>Level : Easy</strong><br><a id="more"></a></p><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Write an algorithm which computes the number of trailing zeros in n factorial.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:  11</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">11! = 39916800, so the output should be 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:  5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">5! = 120, so the output should be 1.</span><br></pre></td></tr></table></figure></p><!-- **Challenge**O(log N) time --><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>这道题的意思是给定一个数字，求出这个数字的阶乘结果尾部的0的个数。最好是代码的时间复杂度是O(log N)。<br>比如11的阶乘是39916800，末尾有2个0，所以结果是2。</p><p>我看到这道题的时候第一想法就是先求出这个数的阶乘，然后再计算末尾的0的个数。这样是最简单的，也最好实现，但是这种算法的时间复杂度是O(N)，这里就不对这种方法做过多的解释了。</p><p>接下来说一种复杂度更低，性能更高的方法:<br>两数相乘，要想末尾出现0，那么这两个数需要达成以下两个条件的其中一个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.其中一个数末尾是0</span><br><span class="line">2.其中一个数末尾是5，另一个数是偶数</span><br></pre></td></tr></table></figure></p><p>通过这两个条件，我们可以想到，只要是阶乘中能整除5的数，就一定能使得阶乘结果的末尾多一个0，比如15，它和任何偶数相乘都能使结果的末尾是0。<br>那么如果给定一个整数n，它的阶乘结果末尾的0就是n/5。但是是这样吗？并不是！<br>我们再来想想，当n的阶乘中有一个数是25的时候，他能带来几个0呢？很明显，是两个!  25<em>4=100,25</em>8=200….<br>当阶乘中有一个数是50呢？  50<em>4=200,50</em>6=300。到这里，我们可以想到，如果是5的平方的倍数，那它能带来两个0。<br>那么如果是5的三次方的倍数呢？ 125<em>8 = 1000,125</em>16 = 2000…很明显，阶乘中的每一个5的三次方的倍数都能带来三个0。<br>….</p><p>根据上面的思路，可以看出:<br>n的阶乘末尾的0的个数 = n/5 + n/5^2 + n/5^3 +…</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">trailingZeros</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum += n / <span class="number">5</span>;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2.Trailing Zeros&lt;br&gt;&lt;strong&gt;Level : Easy&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="LintCode" scheme="www.hlblogs.com/categories/LintCode/"/>
    
    
      <category term="LintCode" scheme="www.hlblogs.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>CMS垃圾收集器</title>
    <link href="www.hlblogs.com/2018/12/13/jvm/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>www.hlblogs.com/2018/12/13/jvm/CMS垃圾收集器/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-25T06:29:41.945Z</updated>
    
    <content type="html"><![CDATA[<p>CMS垃圾收集器<br><a id="more"></a></p><h1 id="CMS出现的初衷和目的"><a href="#CMS出现的初衷和目的" class="headerlink" title="CMS出现的初衷和目的"></a>CMS出现的初衷和目的</h1><p>GC的出现是为了解决Throught收集器和Serial收集器在Full GC周期中的长时间停顿。</p><h1 id="CMS的工作区域和适用场景"><a href="#CMS的工作区域和适用场景" class="headerlink" title="CMS的工作区域和适用场景"></a>CMS的工作区域和适用场景</h1><p>CMS的主要工作区域是老年代，它在老年代中尽可能的并发执行，每个GC周期只有2次短停顿<br>如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的CPU资源也比较丰富，就适合适用CMS收集器。</p><h1 id="CMS的工作流程"><a href="#CMS的工作流程" class="headerlink" title="CMS的工作流程"></a>CMS的工作流程</h1><h2 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h2><p>初始标记主要是标记GC Roots可达的老年代对象以及新生代引用的老年代对象。这个过程在jdk1.7时是单线程执行，在1.8以后是多线程并发执行(可以通过参数CMSParallelInitialMarkEnabled调整)。初始标记会暂停工作线程(Stop The World)。</p><h2 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h2><p>并发标记主要是根据初始标记节点锁标记处的对象向下追踪，将所有可追踪到的对象标记出来，但是这个阶段是GC线程与工作线程并发工作，所以在进行并发标记的时候<br>可能会有些已经在初始标记阶段标记出来的对象发生了改变，或者有一些对象从年轻代晋升到了老年代，或者是有些大对象被直接分配到了老年代，这些对象在并发标记阶段会被标记为dirty,在重新标记阶段对这些dirty对象进行重新标记。</p><h2 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h2><p>重新标记阶段与初始标记阶段一样会暂停工作线程(STW),这个阶段需要重新扫描并标记堆中的对象，包括新生代，GCRoots和被标记为dirty的对象。</p><h2 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h2><p>并发清除阶段，用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达，然后清除。</p><h2 id="预清理阶段"><a href="#预清理阶段" class="headerlink" title="预清理阶段"></a>预清理阶段</h2><p>CMS一般常说的工作流程就上面四个，即初始标记-&gt;并发标记-&gt;重新标记-&gt;并发清除。<br>在重新标记阶段会扫描新生代，GCRoots以及并发标记阶段标记为dirty的对象，这个过程是比较耗时的，在重新标记阶段会产生较长时间的STW。<br>在并发标记阶段和重新标记阶段之间，其实还有一个预清理阶段，这个阶段也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：（1）老年代中card为dirty的对象；（2）幸存区(from和to)中引用的老年代对象。因此，这个阶段也需要扫描新生代+老年代。</p><h2 id="并发重置"><a href="#并发重置" class="headerlink" title="并发重置"></a>并发重置</h2><p>CMS内部重置回收器状态，准备进入下一个并发回收周期。</p><h1 id="CMS的异常情况"><a href="#CMS的异常情况" class="headerlink" title="CMS的异常情况"></a>CMS的异常情况</h1><p>CMS收集器也并不是每一次都能成功完成整个垃圾收集流程，当出现异常情况时，CMS可能会退出工作流程。</p><h2 id="永久代耗尽异常"><a href="#永久代耗尽异常" class="headerlink" title="永久代耗尽异常"></a>永久代耗尽异常</h2><p>默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就会触发Full GC，这种情况下CMS就会退出当前工作流程转为触发一次Full GC。</p><h2 id="并发模式失败"><a href="#并发模式失败" class="headerlink" title="并发模式失败"></a>并发模式失败</h2><p>在CMS工作流程中的并发标记和并发清理阶段，GC线程和工作线程是同时工作的，如果在此期间有大对象直接分配到老年代，但是老年代没有足够的可用内存，就会产生异常(concurrent mode failure),CMS收集器工作停止，转为一次Full GC.</p><h2 id="晋升失败异常"><a href="#晋升失败异常" class="headerlink" title="晋升失败异常"></a>晋升失败异常</h2><p>新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象。如果担保机制发现老年代的可用内存不够，或者如果担保机制判断老年代可用内存是够的，但是实际上由于碎片问题或者确实内存不够导致无法分配，就会产生异常，这个时候minor gc失败，cms的工作流程退出，全部转化为一次Full GC。</p><h1 id="CMS调优"><a href="#CMS调优" class="headerlink" title="CMS调优"></a>CMS调优</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CMS垃圾收集器&lt;br&gt;
    
    </summary>
    
      <category term="jvm" scheme="www.hlblogs.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="www.hlblogs.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>ArrayBlockingQueue源码阅读笔记</title>
    <link href="www.hlblogs.com/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/ArrayBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/ArrayBlockingQueue源码阅读笔记/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-26T09:28:15.967Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayBlockingQueue是一个有界阻塞队列，它的可容纳的最大的数据量取决于队列初始化时的设置，它的内部通过Object[],ReentrentLock和两个Condition实现了一个非常经典的生产者消费者场景，</p><a id="more"></a><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>底层技术: Object[] + ReentrentLock + Condition(两个Condition,生产者消费者场景)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列中的保存数据的容器</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一次从队列中获取数据的位置偏移量</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一次添加数据到队列中的位置偏移量</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中的数据量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure></p><h2 id="生产数据"><a href="#生产数据" class="headerlink" title="生产数据"></a>生产数据</h2><h3 id="数据入列"><a href="#数据入列" class="headerlink" title="数据入列"></a>数据入列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//添加数据到队列中</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">//修改下一次添加数据到队列的数据偏移量，如果已经到达了数组的终点边界，</span></span><br><span class="line">    <span class="comment">//就将偏移量置为0，循环使用数组</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//唤醒消费者队列中的第一个节点去消费数据</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="offer-E"><a href="#offer-E" class="headerlink" title="offer(E)"></a>offer(E)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值代表是否成功生产数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//使用可重入锁，保证生产数据的安全</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-E"><a href="#add-E" class="headerlink" title="add(E):"></a>add(E):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值代表是否成功生产数据。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-E"><a href="#put-E" class="headerlink" title="put(E)"></a>put(E)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//使用可重入锁保证生产数据时的安全问题</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//如果当前队列中的数据已经达到了可以容纳的上限，就将当先线程阻塞进入生产者队列,</span></span><br><span class="line">            <span class="comment">//等待消费者将数据消费了以后，会将生产者队列中的第一个节点唤醒</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//数据入列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue中提供了三个方法用来生产数据，offer(E),add(E)以及put(E)，这其中add(E)和put(E)内部也是通过调用offer(E)来实现的。put(E)在队列中数据已达上限的时候会将线程阻塞，直至有消费者将队列中的数据消费掉。offer(E)和add(E)在队列中数据已达上限的时候不会阻塞，而是会添加失败。</p><h2 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h2><h3 id="数据出列"><a href="#数据出列" class="headerlink" title="数据出列"></a>数据出列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">//取出队列中的第一个可消费数据</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//将被消费的数据所占用的空间释放</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        <span class="comment">//如果可消费数据的偏移量已经到了队列的终点，就回到0的位置循环消费</span></span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//每次有数据出列都会调用，用来处理迭代器的相关逻辑，此处就不再细说了</span></span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">//消费数据以后将生产者队列中的第一个节点唤醒来继续生产数据</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peek():E<br>返回队列中的第一条数据，但是不会从队列中将之移除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll():E<br>返回队列中的第一条数据,并且从队列中将之移除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>take():E<br>返回队列中的第一条数据,如果队列为空，就将线程阻塞等待生产者生产数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//队列为空，就将线程阻塞等待生产者生产数据。</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ArrayBlockingQueue中提供了三个方法用来消费数据，peek():E,pool():E以及take():E,这三个方法内部都是通过调用dequeue():E来实现的。peek():E方法返回队列中的第一条数据，但是不会从队列中将之移除，pool():E方法返回队列中的第一条数据,并且从队列中将之移除。take():E方法返回队列中的第一条数据,如果队列为空，就将线程阻塞等待生产者生产数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ArrayBlockingQueue使用了一个Object数组作为底层数据存储的容器，用putIndex和takeIndex两个字段来表示数据入列和出列的位置。生产数据的时候从putIndex开始将数据按照数组的下标插入，消费数据的时候从takeIndex将数据一一删除。通过这种形式可以将底层数组循环使用。<br>当putIndex和takeIndex重合的时候，表明当前队列中没有数据，那么所有的消费者都将被阻塞，等待生产者生产数据。<br>当size等于当前数组的容量的时候，表面当前队列已满，那么所有的生产者都将被阻塞，等待消费者消费数据。</p><p>另外，由于数据入列和出列使用同一把锁，所以在ArrayBlockingQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArrayBlockingQueue是一个有界阻塞队列，它的可容纳的最大的数据量取决于队列初始化时的设置，它的内部通过Object[],ReentrentLock和两个Condition实现了一个非常经典的生产者消费者场景，&lt;/p&gt;
    
    </summary>
    
      <category term="java源码阅读笔记" scheme="www.hlblogs.com/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="juc" scheme="www.hlblogs.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>idea中好用的插件</title>
    <link href="www.hlblogs.com/2018/12/13/idea/idea%E6%8F%92%E4%BB%B6/"/>
    <id>www.hlblogs.com/2018/12/13/idea/idea插件/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-18T04:30:42.851Z</updated>
    
    <content type="html"><![CDATA[<p>网上搜集来的idea中好用的插件</p><a id="more"></a><p>Lombok<br>编译时自动生成set方法和get方法</p><p>google-java-format<br>保存时自动格式化</p><p>CodeGlance<br>代码地图</p><p>GsonFormat<br>一键根据json文本生成java类，非常方便</p><p>Background image Plus<br>设置idea背景图片</p><p>active-power-mode<br>这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。 </p><p>Nyan progress bar<br>这是一个将你idea中的所有的进度条都变成萌新动画的小插件。 </p><p>Rainbow Brackets<br>彩虹颜色的括号 看着很舒服 敲代码效率变高</p><p>stackoverflow<br>这一看似平淡的右键stackoverflow，却把其中的闷骚体现的淋漓尽致：我就这么叼，我就不去浏览器里查，只有右键才和我的右手匹配。</p><p>FindBugs-IDEA<br>可以对多种级别的内容进行finbugs,分析完之后会有一个视图进行提示，详细的说明是哪种问题。</p><p>CheckStyle-IDEA<br>通过检查对代码编码格式，命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，从而有效约束开发人员更好地遵循代码编写规范。 软件安装成功之后，首先要设置规则。可以通过<br>Preferences—&gt;Other Settings —&gt;CheckStyles<br>进行设置，可以直接将文件添加进来，然后就可以对具体的文件进行检查了。</p><p>MetricsReloaded<br>代码复杂度检查</p><p>VisualVM Launcher<br>运行 java 程序的时候启动 visualvm，方便查看 jvm 的情况 比如堆内存大小的分配，某个对象占用了多大的内存，jvm 调优必备工具。</p><p>MyBatisCodeHelperPro<br>mybatis 代码自动生成插件，大部分单表操作的代码可自动生成，减少重复劳动 大幅提升效率。</p><p>Translation<br>最好用的翻译插件，功能很强大，界面很漂亮。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上搜集来的idea中好用的插件&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="www.hlblogs.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="idea" scheme="www.hlblogs.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>LinkedBlockingQueue源码阅读笔记</title>
    <link href="www.hlblogs.com/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/LinkedBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/LinkedBlockingQueue源码阅读笔记/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-26T07:48:39.360Z</updated>
    
    <content type="html"><![CDATA[<p>LinkedBlockingQueue源码阅读笔记<br>LinkedBlockingQueue是一个基于双端链表的有界阻塞队列。它底层使用了AtomicInteger+ReentrantLock+Condition+单链表 来实现。<br>不同于ArrayBlockingQueue和PriorityBlockingQueue，LinkedBlockingQueue中有两个ReentrantLock实例，一个读锁，一个作为写锁，这样在数据入列和出列的时候互不干扰，不会相互阻塞。<br><a id="more"></a></p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 队列容量范围,如果未设置，则默认为Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层链表的头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层链表的尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="生产数据-入列"><a href="#生产数据-入列" class="headerlink" title="生产数据(入列)"></a>生产数据(入列)</h1><p>offer(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//如果当前队列中的元素数量已经达到了执行的容量的上限，则入列失败</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            <span class="comment">//数据入列</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            <span class="comment">//获取元素数量并使元素数量+1，返回的是未+1的数量</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                <span class="comment">//队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) </span><br><span class="line">        <span class="comment">//如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put(E):void<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列容量已经达到上限，阻塞当前线程，加入到生产者条件队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据入列</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//获取元素数量并使元素数量+1，返回的是未+1的数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            <span class="comment">//队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer(E e, long timeout, TimeUnit unit):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列容量已经达到上限，将当前线程阻塞一段时间，加入到生产者条件队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">//如果指定的阻塞时间小于0，本次入列失败</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据入列</span></span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        <span class="comment">//获取元素数量并使元素数量+1，返回的是未+1的数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">             <span class="comment">//队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">         <span class="comment">//如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer(E):boolean、offer(E, long, TimeUnit):boolean和put(E):void的不同<br>offer: 如果队列容量已满，本次入列失败<br>offer(E, long, TimeUnit):boolean：如果对列容量已满，将当前线程阻塞一段时间，将当前线程加入到生产者等待队列中。<br>put: 如果对列容量已满，阻塞当前线程，将当前线程加入到生产者等待队列中。</p><h1 id="消费数据-出列"><a href="#消费数据-出列" class="headerlink" title="消费数据(出列)"></a>消费数据(出列)</h1><p>poll():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果当前队列是空队列，直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//元素出列</span></span><br><span class="line">            x = dequeue();</span><br><span class="line">            <span class="comment">//获取队列中的元素数量并使元素数量-1，返回的是未-1的数量</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//如果当前元素出列以后队列依然有元素存在，从消费者等待队列唤醒一个消费者。</span></span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">//如果当前元素出列之前队列是满的，那么在出列之后需要从生产者等待队列唤醒一个生产者。</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>take():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前队列是空队列，就将当前线程阻塞起来，加入到消费者等待队列中。</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="移除数据-出列"><a href="#移除数据-出列" class="headerlink" title="移除数据(出列)"></a>移除数据(出列)</h1><p>remove(Object):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//获取读锁和写锁，将读写全部阻塞住</span></span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//表头开始，找到指定的元素并断开该元素和链表的关联(删除该元素)</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">                p != <span class="keyword">null</span>;</span><br><span class="line">                trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//将读锁和写锁全部释放</span></span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LinkedBlockingQueue源码阅读笔记&lt;br&gt;LinkedBlockingQueue是一个基于双端链表的有界阻塞队列。它底层使用了AtomicInteger+ReentrantLock+Condition+单链表 来实现。&lt;br&gt;不同于ArrayBlockingQueue和PriorityBlockingQueue，LinkedBlockingQueue中有两个ReentrantLock实例，一个读锁，一个作为写锁，这样在数据入列和出列的时候互不干扰，不会相互阻塞。&lt;br&gt;
    
    </summary>
    
      <category term="java源码阅读笔记" scheme="www.hlblogs.com/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="juc" scheme="www.hlblogs.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>AtomicInteger源码阅读笔记</title>
    <link href="www.hlblogs.com/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/AtomicInteger%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>www.hlblogs.com/2018/12/13/源码阅读/java/AtomicInteger源码阅读笔记/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-26T09:06:50.648Z</updated>
    
    <content type="html"><![CDATA[<p>AtomicInteger源码阅读笔记</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment"> * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment"> * returning the updated value. The function should be</span></span><br><span class="line"><span class="comment"> * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment"> * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment"> * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment"> * and the given update as the second argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;AtomicInteger源码阅读笔记&lt;/p&gt;
    
    </summary>
    
      <category term="java源码阅读笔记" scheme="www.hlblogs.com/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="juc" scheme="www.hlblogs.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>8.Rotate String</title>
    <link href="www.hlblogs.com/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/8.Rotate%20String/"/>
    <id>www.hlblogs.com/2018/12/13/刷题/LintCode/8.Rotate String/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-21T07:10:09.801Z</updated>
    
    <content type="html"><![CDATA[<p>8.Rotate String<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Given a string and an offset, rotate string by offset. (rotate from left to right)</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset = 3</span><br><span class="line">Output:&quot;efgabcd&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset = 0</span><br><span class="line">Output: &quot;abcdefg&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset = 1</span><br><span class="line">Output: &quot;gabcdef&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br><span class="line"></span><br><span class="line">Example 4</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset =2</span><br><span class="line">Output:&quot;fgabcde&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">  Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>Rotate in-place with O(1) extra memory.</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>字符串翻转<br>1.先全部翻转，再将左边翻转，最后将右边翻转<br>2.先将左边翻转，再将右边翻转，最后全部翻转</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"cppjavapy"</span>;</span><br><span class="line">        rotate(str.toCharArray(),<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        offset %= str.length;</span><br><span class="line"></span><br><span class="line">        rotate(str,<span class="number">0</span>,str.length-<span class="number">1</span>);</span><br><span class="line">        rotate(str,<span class="number">0</span>,offset-<span class="number">1</span>);</span><br><span class="line">        rotate(str,offset,str.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str)&#123;</span><br><span class="line">            System.out.print(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">char</span>[] strs,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;8.Rotate String&lt;br&gt;&lt;strong&gt;Level : Easy&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LintCode" scheme="www.hlblogs.com/categories/LintCode/"/>
    
    
      <category term="LintCode" scheme="www.hlblogs.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue源码阅读笔记</title>
    <link href="www.hlblogs.com/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/PriorityQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>www.hlblogs.com/2018/12/13/源码阅读/java/PriorityQueue源码阅读笔记/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-27T10:23:35.569Z</updated>
    
    <content type="html"><![CDATA[<p>PriorityQueue是一个无界队列,使用了二叉堆作为底层的数据结构，并且用一个Object[]来表示这个堆。<br>PriorityQueue本身未做任何线程安全方面的处理，所以它本身是线程不安全的，在多线程环境下可能会出现线程安全问题。</p><a id="more"></a><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层存储数据的结构，Priority底层使用的是二叉堆来实现，使用数组来表示二叉堆</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue; </span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较器，如果想要使用它的话，需要开发人员自己实现，当它为空的时候会使用默认的自然排序进行比较</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中元素的数量发生改变的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="生产数据"><a href="#生产数据" class="headerlink" title="生产数据"></a>生产数据</h1><p>add(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//添加数据并维护堆结构</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// 计算新的容量</span></span><br><span class="line">    <span class="comment">// 原容量小于64，扩容后翻倍，准确来说是oldCapacity + oldCapacity + 2</span></span><br><span class="line">    <span class="comment">// 原容量大于等于64，扩容后增加百分之50，oldCapacity+(oldCapacity &gt;&gt; 1)</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                        (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                        (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果计算出的新的容量大于队列允许的最大值，需要重新计算</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//扩容，创建一个新的数组，将原数组中的数据复制过去，然后将新的数组赋值给变量queue</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果此时底层数组的长度已经达到了终极上限(Integer.MAX_VALUE)，那么再加一的话就会溢出</span></span><br><span class="line">    <span class="comment">//这里如果小于0，说明已经溢出了，抛出OutOfMemoryError</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 重新计算新的容量</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加数据、维护堆结构"><a href="#添加数据、维护堆结构" class="headerlink" title="添加数据、维护堆结构"></a>添加数据、维护堆结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果开发人员自己实现了一个比较器，就使用自己实现的那个比较器</span></span><br><span class="line">        <span class="comment">//方法逻辑比较简单，可以参考堆结构的添加数据过程</span></span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果开发人员并未实现一个定制的构造器，就使用默认的自然排序来当做比较器进行使用。</span></span><br><span class="line">        <span class="comment">//方法逻辑比较简单，可以参考堆结构的添加数据过程</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h1><p>peek():E<br>获取队列中的第一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll():E<br>获取队列中的第一个元素，并使它出列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="消费数据、维护结构"><a href="#消费数据、维护结构" class="headerlink" title="消费数据、维护结构"></a>消费数据、维护结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PriorityQueue是一个无界队列,使用了二叉堆作为底层的数据结构，并且用一个Object[]来表示这个堆。&lt;br&gt;PriorityQueue本身未做任何线程安全方面的处理，所以它本身是线程不安全的，在多线程环境下可能会出现线程安全问题。&lt;/p&gt;
    
    </summary>
    
      <category term="java源码阅读笔记" scheme="www.hlblogs.com/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java基础" scheme="www.hlblogs.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>PriorityBlockingQueue源码阅读笔记</title>
    <link href="www.hlblogs.com/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/PriorityBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/PriorityBlockingQueue源码阅读笔记/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-26T09:28:15.969Z</updated>
    
    <content type="html"><![CDATA[<p>PriorityBlockingQueue源码阅读笔记<br>PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，因为使用了可重入锁，所以它是线程安全的。<br><a id="more"></a></p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层数组的最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来存储数据的底层数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中数据的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较器，如果队列使用成员数据的自然排序规则，则此比较器为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁，保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件队列，用于队列中无数据时的线程阻塞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Spinlock for allocation, acquired via CAS.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//自旋锁，通过CAS获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br></pre></td></tr></table></figure><h1 id="生产数据"><a href="#生产数据" class="headerlink" title="生产数据"></a>生产数据</h1><p>PriorityBlockingQueue提供了off(E),add(E),put(E)三个方法实现数据的入列。</p><p>offer(E):boolean<br>因为PriorityBlockingQueue是一个无界队列，所以这个方法永远不会返回false，它可以一直添加成功，直到内存爆掉。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        <span class="comment">// 如果当前队列中的元素数量大于等于底层数组的长度，就需要扩容了</span></span><br><span class="line">        <span class="comment">// 根据既定的扩容规则扩容以后，如果依然未能满足需求，那就继续进行扩容操作。</span></span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//数据入列，并且通过自然排序比较来维持二叉堆的结构</span></span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//数据入列，通过指定的比较器来实现维持二叉堆的结构</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>add(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put(E):void<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为PriorityBlockingQueue是一个无界队列，所以这里永远不需要阻塞</span></span><br><span class="line">    offer(e); </span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 扩容</span><br><span class="line">PriorityBlockingQueue底层存储数据使用的是数组结构，当数组空间被使用完毕以后，就需要对数组进行扩容操作。</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//计算出一个新的容量</span></span><br><span class="line">            <span class="comment">//如果旧的数组容量小于64 则新的容量 = 旧的容量 + (旧的容量 + 2)</span></span><br><span class="line">            <span class="comment">//如果旧的数组容量大于等于64，则新的容量 = 旧的容量 + (旧的容量 &gt;&gt; 1)</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                    (oldCap + <span class="number">2</span>) : </span><br><span class="line">                                    (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//通过上面的方式计算出来的容量可能会超出int类型所能表示的上限，</span></span><br><span class="line">            <span class="comment">//如果新的容量已经超出了限制 并且 旧的容量已经达到了上限，抛出异常</span></span><br><span class="line">            <span class="comment">//如果新的容量已经超出了限制 并且 旧的容量未达到上限，则新的容量等于int类型上限</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据上面计算出的新的容量，创建一个新的数组实例</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有其他的线程已经处于扩容阶段，则此线程重新参与竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) </span><br><span class="line">        Thread.yield();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        <span class="comment">//将旧数组中的数组复制到新的数组中来</span></span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="维护二叉堆的结构"><a href="#维护二叉堆的结构" class="headerlink" title="维护二叉堆的结构"></a>维护二叉堆的结构</h2><p>添加数据可能会破坏底层的二叉堆结构，所以在数据入列的时候就需要同时去维护这个堆结构<br>生产数据时维护数据结构比较简单，主要就是将新节点与其父节点进行比较，然后在拿父节点和祖父节点进行比较，根据对应的排序规则对两个节点的数据进行交换操作最终找到适当的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h1><p>每一次出列的元素都是底层数组中下标为0的那个，再把队列中的最后一个元素给挪到下标为0的位置，然后再维护二叉堆的结构，这就是出列的整个过程。<br>dequeue():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="维护二叉堆的结构-1"><a href="#维护二叉堆的结构-1" class="headerlink" title="维护二叉堆的结构"></a>维护二叉堆的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用自然排序比较优先级的方式维护底层的堆结构</span></span><br><span class="line"><span class="comment"> * k: 需要填充的位置</span></span><br><span class="line"><span class="comment"> * x: 等待填充的元素，会填充在k位置</span></span><br><span class="line"><span class="comment"> * array: 堆数组</span></span><br><span class="line"><span class="comment"> * n: 堆元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;  </span><br><span class="line">        <span class="comment">// 非叶子节点无限循环，从完全二叉树的结构来看，二叉树的叶子节点一定占到总节点数的一半+1         </span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="comment">//假设左子节点的值最小</span></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果左子节点大于右子节点，就取右子节点的值比较</span></span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果key的值小于它的左子节点或右子节点，就退出循环，结构维护结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将两个子节点中比较小的节点的值赋值给父节点</span></span><br><span class="line">            array[k] = c;</span><br><span class="line">            <span class="comment">//记录左右子节点中比较小的节点的下标，用于在下一次循环中获取父节点</span></span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后将待填充的元素填充在适当的位置</span></span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的比较器来比较优先级的方式维护底层的堆结构</span></span><br><span class="line"><span class="comment"> * k: 需要填充的位置</span></span><br><span class="line"><span class="comment"> * x: 等待填充的元素，会填充在k位置</span></span><br><span class="line"><span class="comment"> * array: 堆数组</span></span><br><span class="line"><span class="comment"> * n: 堆元素的数量</span></span><br><span class="line"><span class="comment"> * cmp: 指定的比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h1><p>比较器主要用于实现优先级的比较，开发人员可以根实际情况来选择要不要做具体实现。<br>实现一个定制的比较器需要实现Comparator<t>接口.这个接口中的方法比较多，就不一一解释了，这里只对最重要的一个方法做一下解释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值代表了o1和O2的比较结果</span></span><br><span class="line"><span class="comment">     * 返回值小于0 : o1 &lt; o2</span></span><br><span class="line"><span class="comment">     * 返回值等于0 : o1==o2</span></span><br><span class="line"><span class="comment">     * 返回值大于0 : o1 &gt; o2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...此处省略接口中其他的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>开发人员实现了比较器以后，优先级队列中再做优先级比较，就会使用开发人员自己实现的比较器，而不是自然排序.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，并且每一次数据入列和出列都会相应的调整堆结构.<br>因为使用了可重入锁，所以它是线程安全的。但是，由于数据入列和出列使用同一把锁，所以在PriorityBlockingQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PriorityBlockingQueue源码阅读笔记&lt;br&gt;PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，因为使用了可重入锁，所以它是线程安全的。&lt;br&gt;
    
    </summary>
    
      <category term="java源码阅读笔记" scheme="www.hlblogs.com/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="juc" scheme="www.hlblogs.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>9.Fizz Buzz</title>
    <link href="www.hlblogs.com/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/9.Fizz%20Buzz/"/>
    <id>www.hlblogs.com/2018/12/13/刷题/LintCode/9.Fizz Buzz/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-21T07:13:25.035Z</updated>
    
    <content type="html"><![CDATA[<p>9.Fizz Buzz<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Given number n. Print number from 1 to n. But:</p><p>when number is divided by 3, print “fizz”.<br>when number is divided by 5, print “buzz”.<br>when number is divided by both 3 and 5, print “fizz buzz”.<br>when number can’t be divided by either 3 or 5, print the number itself.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">If n = 15, you should return:</span><br><span class="line">[</span><br><span class="line">  &quot;1&quot;, &quot;2&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;4&quot;, &quot;buzz&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;7&quot;, &quot;8&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;buzz&quot;, &quot;11&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;13&quot;, &quot;14&quot;, &quot;fizz buzz&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">If n = 10, you should return:</span><br><span class="line">[</span><br><span class="line">  &quot;1&quot;, &quot;2&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;4&quot;, &quot;buzz&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;7&quot;, &quot;8&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;buzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>Can you do it with only one if statement?</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        list.add(i % <span class="number">15</span> == <span class="number">0</span> ? <span class="string">"fizz buzz"</span> : i % <span class="number">3</span> == <span class="number">0</span> ? <span class="string">"fizz"</span> : i % <span class="number">5</span> == <span class="number">0</span> ? <span class="string">"buzz"</span> : i + <span class="string">""</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;9.Fizz Buzz&lt;br&gt;&lt;strong&gt;Level : Easy&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LintCode" scheme="www.hlblogs.com/categories/LintCode/"/>
    
    
      <category term="LintCode" scheme="www.hlblogs.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>jconcole连接java进程报错问题解决</title>
    <link href="www.hlblogs.com/2018/12/13/jvm/jconsole%E8%BF%9E%E6%8E%A5java%E8%BF%9B%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <id>www.hlblogs.com/2018/12/13/jvm/jconsole连接java进程报错问题/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-18T04:27:35.592Z</updated>
    
    <content type="html"><![CDATA[<p>jconcole连接java进程报错问题解决</p><a id="more"></a><p>问题:使用JConsole连接java进程的时候报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"VMPanel.connect"</span> java.lang.InternalError: Remote thread failed <span class="keyword">for</span> unknown reason</span><br><span class="line">    at sun.tools.attach.WindowsVirtualMachine.enqueue(Native Method)</span><br><span class="line">    at sun.tools.attach.WindowsVirtualMachine.&lt;init&gt;(WindowsVirtualMachine.java:<span class="number">62</span>)</span><br><span class="line">    at sun.tools.attach.WindowsAttachProvider.attachVirtualMachine(WindowsAttachProvider.java:<span class="number">69</span>)</span><br><span class="line">    at com.sun.tools.attach.VirtualMachine.attach(VirtualMachine.java:<span class="number">208</span>)</span><br><span class="line">    at sun.tools.jconsole.LocalVirtualMachine.loadManagementAgent(LocalVirtualMachine.java:<span class="number">232</span>)</span><br><span class="line">    at sun.tools.jconsole.LocalVirtualMachine.startManagementAgent(LocalVirtualMachine.java:<span class="number">98</span>)</span><br><span class="line">    at sun.tools.jconsole.ProxyClient.tryConnect(ProxyClient.java:<span class="number">333</span>)</span><br><span class="line">    at sun.tools.jconsole.ProxyClient.connect(ProxyClient.java:<span class="number">313</span>)</span><br><span class="line">    at sun.tools.jconsole.VMPanel$<span class="number">2</span>.run(VMPanel.java:<span class="number">294</span>)</span><br></pre></td></tr></table></figure></p><p>解决:<br>项目启动的时候加上启动参数-Dcom.sun.management.jmxremote</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;jconcole连接java进程报错问题解决&lt;/p&gt;
    
    </summary>
    
      <category term="jvm" scheme="www.hlblogs.com/categories/jvm/"/>
    
    
      <category term="jvm" scheme="www.hlblogs.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>DelayQueue源码阅读笔记</title>
    <link href="www.hlblogs.com/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/DelayQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/DelayQueue源码阅读笔记/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-14T01:13:45.006Z</updated>
    
    <content type="html"><![CDATA[<p>DelayQueue源码阅读笔记<br>DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。</p><a id="more"></a><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重入锁保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//优先级队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread designated to wait for the element at the head of</span></span><br><span class="line"><span class="comment">    * the queue.  This variant of the Leader-Follower pattern</span></span><br><span class="line"><span class="comment">    * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to</span></span><br><span class="line"><span class="comment">    * minimize unnecessary timed waiting.  When a thread becomes</span></span><br><span class="line"><span class="comment">    * the leader, it waits only for the next delay to elapse, but</span></span><br><span class="line"><span class="comment">    * other threads await indefinitely.  The leader thread must</span></span><br><span class="line"><span class="comment">    * signal some other thread before returning from take() or</span></span><br><span class="line"><span class="comment">    * poll(...), unless some other thread becomes leader in the</span></span><br><span class="line"><span class="comment">    * interim.  Whenever the head of the queue is replaced with</span></span><br><span class="line"><span class="comment">    * an element with an earlier expiration time, the leader</span></span><br><span class="line"><span class="comment">    * field is invalidated by being reset to null, and some</span></span><br><span class="line"><span class="comment">    * waiting thread, but not necessarily the current leader, is</span></span><br><span class="line"><span class="comment">    * signalled.  So waiting threads must be prepared to acquire</span></span><br><span class="line"><span class="comment">    * and lose leadership while waiting.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//当leader不为空时，只有leader能等待第一个元素返回，其他的元素必须无限期等待，等待leader从poll方法或take方法返回后将它们唤醒</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件等待队列，与ReentrentLocK搭配</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure><h1 id="Delayed接口"><a href="#Delayed接口" class="headerlink" title="Delayed接口"></a>Delayed接口</h1><p>DelayQueue队列中所有的元素都必须实现Delayed接口，Delayed接口中有一个getDelay方法用来返回剩余的延迟时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Delayed接口继承了Comparable接口，所以实现此接口的同时，还需要实现Comparable接口中的compareTo方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回剩余的延迟时间，0和负数代表已经过了延迟的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><p>DelayQueue中的大部分功能都沿用了PriorityQueue中的实现，非常的简单。它的特殊点主要集中在出列的时候。</p><p>poll():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="comment">//如果队列中没有元素或者第一个元素指定的延迟时间还没有到达，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll(long,TimeUnit):E<br>此方法会响应中断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeout: 等待时间数值</span></span><br><span class="line"><span class="comment"> * unit: 等待时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将等待时间转换为纳秒形式</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果等待时间小于等于0并且队列中无数据，直接返回null</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//如果等待时间大于0并且队列中无数据，将线程阻塞直到等待时间过期</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果队列不是空队列，取第一个元素的剩余延迟时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果第一个元素的剩余时间小于等于0了，就将第一个元素出列并返回。</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果第一个元素的剩余延迟时间还未过，但是等待时间已经过期了，就返回null.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果等待时间小于第一个元素的剩余延迟时间，将线程阻塞直到等待时间过期。</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//如果等待时间大于等于第一个元素的剩余延迟时间，将线程阻塞直到第一个元素的延迟时间过期</span></span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">//重新计算等待时间</span></span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            <span class="comment">//将leader置空</span></span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果leader为空并且队列不为空，唤醒正在等待中的线程。</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>take():E<br>此方法会响应中断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//如果队列是空队列，将线程阻塞起来进入条件等待队列</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果队列不是空队列，取第一个元素的剩余延迟时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果第一个元素的剩余时间小于等于0了，就将第一个元素出列并返回。</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果 队列非空&amp;&amp;剩余延迟时间&gt;0&amp;&amp;leader!=null  </span></span><br><span class="line">                    <span class="comment">//此时只有leader能得带第一个元素的延迟时间到期，其余的所有线程都将被阻塞</span></span><br><span class="line">                    <span class="comment">//等待leader线程将它们唤醒，转移到CLH队列中竞争锁</span></span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//如果 队列非空&amp;&amp;剩余延迟时间&gt;0&amp;&amp;leader=null  </span></span><br><span class="line">                        <span class="comment">//将当前线程设置为leader,使其他的线程全部阻塞，当前线程等待第一个元素的延迟时间过期</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">             <span class="comment">//如果leader为空并且队列不为空，唤醒正在等待中的线程。</span></span><br><span class="line">             <span class="comment">//之所以需要判断leader是否为null的情况，是因为此时可能leader被其他线程持有并且没有释放，在这种情况下任何非leader线程都只能等待leader被释放</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。但是，由于数据入列和出列使用同一把锁，所以在DelayQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;DelayQueue源码阅读笔记&lt;br&gt;DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。&lt;/p&gt;
    
    </summary>
    
      <category term="java源码阅读笔记" scheme="www.hlblogs.com/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="juc" scheme="www.hlblogs.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>35. Reverse Linked List</title>
    <link href="www.hlblogs.com/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/35.Reverse%20Linked%20List/"/>
    <id>www.hlblogs.com/2018/12/13/刷题/LintCode/35.Reverse Linked List/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-21T07:43:04.360Z</updated>
    
    <content type="html"><![CDATA[<ol start="35"><li>Reverse Linked List<br><strong>Level : Easy</strong></li></ol><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Reverse a linked list.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example1:</span><br><span class="line">For linked list 1-&gt;2-&gt;3, the reversed linked list is 3-&gt;2-&gt;1</span><br><span class="line">Example2:</span><br><span class="line">For linked list 1-&gt;2-&gt;3-&gt;4, the reversed linked list is 4-&gt;3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>Reverse it in-place and in one-pass</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>单链表翻转，要求原地一次翻转完成。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>非递归方式翻转:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ReverseLinkedList reverseLinkedList = <span class="keyword">new</span> ReverseLinkedList();</span><br><span class="line">        ListNode newHead = reverseLinkedList.reverse(node1);</span><br><span class="line">        System.out.println(newHead.val+<span class="string">" "</span>+newHead.next.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;ol start=&quot;35&quot;&gt;
&lt;li&gt;Reverse Linked List&lt;br&gt;&lt;strong&gt;Level : Easy&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="LintCode" scheme="www.hlblogs.com/categories/LintCode/"/>
    
    
      <category term="LintCode" scheme="www.hlblogs.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>LinkedBlockingDeque源码阅读笔记</title>
    <link href="www.hlblogs.com/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/LinkedBlockingDeque%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(waitting)/"/>
    <id>www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/LinkedBlockingDeque源码阅读笔记(waitting)/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2018-12-26T07:48:39.358Z</updated>
    
    <content type="html"><![CDATA[<p>LinkedBlockingDeque源码阅读笔记<br>LinkedBlockingDeque是一个有界阻塞队列，其底层技术为AtomicInteger+ReentrentLock+Condition+双端链表。<br><a id="more"></a></p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双端链表的头结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双端链表的尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br></pre></td></tr></table></figure><h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><p>linkFirst(Node):boolean<br>将指定节点设置为头结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkFirst</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    node.next = f;</span><br><span class="line">    first = node;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        last = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = node;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">//从消费者等待队列中唤醒一个消费者</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>linkLast(Node):boolean<br>将指定节点设置为尾结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkLast</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    node.prev = l;</span><br><span class="line">    last = node;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        first = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = node;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">//从消费者等待队列中唤醒一个消费者</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>unlinkFirst():E<br>返回并删除头结点，如果头结点为null，则返回null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = f; <span class="comment">// help GC</span></span><br><span class="line">    first = n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n.prev = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">//从生产者等待队列中唤醒一个生产者</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>unlinkLast():E<br>返回并删除尾结点，如果尾结点为null，则返回null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; p = l.prev;</span><br><span class="line">    E item = l.item;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = l; <span class="comment">// help GC</span></span><br><span class="line">    last = p;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">//从生产者等待队列中唤醒一个生产者</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;LinkedBlockingDeque源码阅读笔记&lt;br&gt;LinkedBlockingDeque是一个有界阻塞队列，其底层技术为AtomicInteger+ReentrentLock+Condition+双端链表。&lt;br&gt;
    
    </summary>
    
      <category term="java源码阅读笔记" scheme="www.hlblogs.com/categories/java%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="juc" scheme="www.hlblogs.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>idea使用问题记录</title>
    <link href="www.hlblogs.com/2018/12/13/idea/idea%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>www.hlblogs.com/2018/12/13/idea/idea使用问题记录/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-08T07:03:37.414Z</updated>
    
    <content type="html"><![CDATA[<p>idea使用问题记录</p><a id="more"></a><h1 id="idea插件下载失败"><a href="#idea插件下载失败" class="headerlink" title="idea插件下载失败"></a>idea插件下载失败</h1><p>检查了网络没有问题，试过梯子，插件始终无法下载下来。经过google找到了解决方案<br>Setting -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Updates -&gt; use secure connection(默认勾选，将它取消)</p><h1 id="Method-breakpoints-may-dramatically-slow-down-debugging"><a href="#Method-breakpoints-may-dramatically-slow-down-debugging" class="headerlink" title="Method breakpoints may dramatically slow down debugging"></a>Method breakpoints may dramatically slow down debugging</h1><p>断点打在了方法上面，导致项目启动变慢，IDEA调试越来越慢。<br>Ctrl+shift+F8 打开 Breakpoints 面板，找到对应的断点取消即可</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;idea使用问题记录&lt;/p&gt;
    
    </summary>
    
      <category term="开发工具" scheme="www.hlblogs.com/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="idea" scheme="www.hlblogs.com/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>13.Implement strStr</title>
    <link href="www.hlblogs.com/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/13.Implement%20strStr/"/>
    <id>www.hlblogs.com/2018/12/13/刷题/LintCode/13.Implement strStr/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-21T07:28:50.704Z</updated>
    
    <content type="html"><![CDATA[<p>13.Implement strStr<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>For a given source string and a target string, you should output the first index(from 0) of target string in source string.</p><p>If target does not exist in source, just return -1.</p><p><strong>Clarification</strong><br>Do I need to implement KMP Algorithm in a real interview?</p><p>Not necessary. When you meet this problem in a real interview, the interviewer may just want to test your basic implementation ability. But make sure you confirm with the interviewer first.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: source = &quot;source&quot; ，target = &quot;target&quot;</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">If the source does not contain the target content, return - 1.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:source = &quot;abcdabcdefg&quot; ，target = &quot;bcd&quot;</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">If the source contains the target content, return the location where the target first appeared in the source.</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>O(n2) is acceptable. Can you implement an O(n) algorithm? (hint: KMP)</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>查询模式串在主串中首次出现的位置<br>BF算法<br>RK算法<br>KMP算法<br>。。。<br>根据题目,这里使用KMP算法</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source==<span class="keyword">null</span> || target == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">""</span>.equals(source) &amp;&amp; <span class="string">""</span>.equals(target))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">""</span>.equals(source) &amp;&amp; !<span class="string">""</span>.equals(target))&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="string">""</span>.equals(source) &amp;&amp; <span class="string">""</span>.equals(target))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[target.length()];</span><br><span class="line">    next(target, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; source.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || source.charAt(i) == target.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == target.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(String target, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//前缀位置</span></span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;  <span class="comment">//后缀位置</span></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; next.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || target.charAt(i) == target.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;13.Implement strStr&lt;br&gt;&lt;strong&gt;Level : Easy&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LintCode" scheme="www.hlblogs.com/categories/LintCode/"/>
    
    
      <category term="LintCode" scheme="www.hlblogs.com/tags/LintCode/"/>
    
  </entry>
  
  <entry>
    <title>14.First Position of Target</title>
    <link href="www.hlblogs.com/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/14.%20First%20Position%20of%20Target/"/>
    <id>www.hlblogs.com/2018/12/13/刷题/LintCode/14. First Position of Target/</id>
    <published>2018-12-12T16:00:00.000Z</published>
    <updated>2019-01-21T07:39:10.843Z</updated>
    
    <content type="html"><![CDATA[<p>14.First Position of Target<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.</p><p>If the target number does not exist in the array, return -1.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:  [1,4,4,5,7,7,8,9,9,10]，1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">the first index of  1 is 0.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1, 2, 3, 3, 4, 5, 10]，3</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">the first index of 3 is 2.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: [1, 2, 3, 3, 4, 5, 10]，6</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Not exist 6 in array.</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>If the count of numbers is bigger than 2^32, can your code work properly?</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>给定一个有序数组和一个目标数，找出该目标数在有序数组中第一次出现的位置<br>因为给定的是有序数组，所以采用二分法比较合适。<br>需要考虑的问题:<br>1.数组中的数可能会有重复的<br>    一旦找到和目标数相等的数，不能停下来，要继续往前推进，直至找到第一次出现的位置<br>2.如果数组长度大于2^32该怎么处理<br>    目前能想到的思路就是拆分数组然后再处理</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end= nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">while</span>((mid = --mid) &gt;= <span class="number">0</span> &amp;&amp; nums[mid] == target)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ++mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;14.First Position of Target&lt;br&gt;&lt;strong&gt;Level : Easy&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="LintCode" scheme="www.hlblogs.com/categories/LintCode/"/>
    
    
      <category term="LintCode" scheme="www.hlblogs.com/tags/LintCode/"/>
    
  </entry>
  
</feed>
