{"meta":{"title":"撸猫青年的小窝","subtitle":"日拱一卒 功不唐捐","description":"94年 在上海工作 养猫 死宅","author":"撸猫青年","url":"www.hlblogs.com"},"pages":[{"title":"关于我","date":"2018-11-05T01:13:42.000Z","updated":"2018-11-19T06:43:32.869Z","comments":true,"path":"about/index.html","permalink":"www.hlblogs.com/about/index.html","excerpt":"","text":"爱生活爱编码"},{"title":"All tags","date":"2018-11-03T04:39:04.000Z","updated":"2018-11-19T06:43:32.871Z","comments":true,"path":"tags/index.html","permalink":"www.hlblogs.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-03T02:51:12.000Z","updated":"2018-11-19T06:43:32.870Z","comments":true,"path":"categories/index.html","permalink":"www.hlblogs.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"关于String的一点思考","slug":"java基础/关于String的一些思考","date":"2019-01-23T16:00:00.000Z","updated":"2019-01-24T08:25:14.029Z","comments":true,"path":"2019/01/24/java基础/关于String的一些思考/","link":"","permalink":"www.hlblogs.com/2019/01/24/java基础/关于String的一些思考/","excerpt":"对String的一些思考: 包括String的不可变性、String对‘+’的处理、String.valueOf和Integer.toString的区别、几种不同的String创建方式的区别等等。","text":"对String的一些思考: 包括String的不可变性、String对‘+’的处理、String.valueOf和Integer.toString的区别、几种不同的String创建方式的区别等等。 String的不可变性String是不可变、不可继承的，这点是众所周知的，因为它是被final修饰的(这里不对final做过多的解释)。1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; //String源码省略。。。。。。&#125; 那么为什么要把它涉及成不可变的呢？ 出于设计考虑，字符串常量池的需要对于常量来说，重复创建是比较浪费资源且没有必要的，同一个字符串常量，只需要在常量池中创建一个就够了，如果其他地方需要这个字符串常量，那么它只需要引用原来常量池中的那一个就够了。 处于效率优化考虑因为String是不可变的，所以String中的hash码也是不变的，这样就不用每一次使用的时候都去计算新的hash值。同时，因为它的hash值是不变的，它才能够在HashSet、HashMap等容器中不出问题。假如它的hash值是可变的，那该多尴尬，你计算了一个Stirng类型的key的hash值，将key和value保存在HashMap中了，然后它被修改了，新的hash值与原来不同了，那么再以这个String作为key去存取数据，结果必然是有问题的。 处于安全性考虑String在非常多的类中被用来当做参数，同时它还被用来保存配置信息，如果它是可变的，那么势必会带来一些隐蔽性很高的隐患。 处于上面这几点我们暂且认为这样设计非常好，但是为什么不把所有的类都设计成不可变的呢，毕竟它安全，效率又高？如果将所有的类都设计成不可变的，那么每一次的修改都会创建一个新的实例，这样性能就很低。同时，大量的实例产生背后是大量的实例等待回收，垃圾回收的任务太重，也会降低系统性能。一般来说我们在使用HashSet和HashMap这类容器的时候不太会用String之外的类实例来作为key，所以基本上就不需要确保hash值的唯一性。 String对‘+’的处理由于String类被设计成不可变的，所以String对象的每一次的修改都会创建一个新的String实例。对于‘+’的处理分为两种情况:第一种就是类似于String str1 = “abc”+”def”这种情况，这里设计到java编译器的一个优化手段，那就是”abc”是String常量,”def”也是一个String常量，所以在编译期间它们就会被合成一个字符串”abcdef”，然后放入字符串常量池中。第二种呢就是类似于String str2 = str1 + “def”这种情况，这里的str1是一个String变量，它是不确定的，这里的str1+”def”不会有有上面的编译期优化出现，也不会被主动放进字符串常量池中。 String.valueOf和Integer.toString的区别String.valueOf有很多个重载方法，其中形参为int类型的重载方法内部调用的的就是Integer.toString,代码如下。123public static String valueOf(int i) &#123; return Integer.toString(i);&#125; 而Integer.toString方法最终使用的是new String的方式。如果想将一个int类型的变量转化成字符串，那么使用String.valueOf和Integer.toString是没有区别的。但是如果使用int+””这种形式，区别就比较大了，因为这种方式底层使用的是StringBuilder。 几种不同的String创建方式的区别比较常见的String实例创建方式有:1234String str1 = \"abc\" + \"def\"; //常量+常量String str2 = str1 + \"ghi\"; //变量+常量 或 变量+变量String str3 = new String(\"abcdefghi\"); //使用new关键字String str4 = String.valurOf(666); //使用valueOf 常量+常量 : 这种创建方式，编译器会在编译期将多个常量合成一个，放入字符串常量池中，最后str1引用的是字符串常量池中的那个地址。变量+常量 : 这种创建方式，不会被优化，在运行期它的值才会被确定下来，并且它是不会被放入字符串常量池中的。new关键字 : 字符串参数的处理同上面的两种情况，这里还有一个不同就是new关键字会在堆内存中再创建一个String实例，所以使用new关键字实际上相当于创建了两个实例，一个在堆内存中，一个在字符串常量池中。valueOf : valueOf的创建形式内部还是使用了new关键字。 intern()intern方法的用户只有一个，那就是在运行时将字符串放入字符串常量池中并返回常量池中的那个地址。具体的情况我下面会举例。 举例来看几道笔试题吧一:12345678String str1 = \"abc\";String str2 = \"a\" + \"b\" + \"c\";System.out.println(str1 == str2);String str3 = \"ab\";String str4 = \"abc\";String str5 = str3 + \"c\";System.out.println(str4 == str5); 输出结果:12truefalse str1被创建时因为”abc”是常量，所以它在编译期就被放入了常量池中，str1引用的是常量池中的地址str2被创建时因为”a”、”b”、”c”都是常量，所以在它们会被优化成一个常量”abc”放入到常量池中，但是因为常量池中已经有一个”abc”了，所以会直接返回这个常量的地址，也就是str1引用的那个地址，所以str1 == str2为.对于str4和str5来说，str4引用的是常量池中的地址，但是由于str3是变量，所以str5应用的地址并不是常量池中的”abc”的地址，所以str4 == str5结果为false. 二 :12345678910111213String str1 = new String(\"abcd\");System.out.println(str1.intern() == str1);String str2 = \"a\";String str3 = new String(sss+\"b\");System.out.println(str3.intern() == str3);String str4 = new StringBuilder(\"abc\").append(\"def\").toString();System.out.println(str4.intern() == str4);String str5 = new StringBuilder(\"abc\").append(\"def\").toString();System.out.println(str5.intern() == str5); 输出结果:1234falsetruetruefalse “abcd”在编译期会被放入到字符串常量池中，所以str1.intern实际返回的是”abcd”在常量池中的地址,而str1是存在于堆内存中的，所以str1.intern()==str1结果为falsestr3.intern()这个操作会把str3放入到字符串常量池中，然后返回str3的地址，所以str3.intern() == str3结果为truestr4.intern()==str4结果为true的原理和上面str3.intern() == str3结果为true的原理是一样的str5.intern()将str5放入字符串常量池，但是因为str4已经被放入常量池中了，所以这里返回的其实是str4的地址，所以str5.intern() == str5结果为false。","categories":[{"name":"java基础","slug":"java基础","permalink":"www.hlblogs.com/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"www.hlblogs.com/tags/java基础/"}]},{"title":"关于int类型取值范围的一点思考","slug":"java基础/关于int取值范围的一点思考","date":"2019-01-02T16:00:00.000Z","updated":"2019-01-03T03:16:51.599Z","comments":true,"path":"2019/01/03/java基础/关于int取值范围的一点思考/","link":"","permalink":"www.hlblogs.com/2019/01/03/java基础/关于int取值范围的一点思考/","excerpt":"java中int类型占四个字节，32位的，如果是有符号的数，那么四个字节能表示的范围-2147483648（-2^31） ~ 2147483647 （2^31-1），如果是无符号数，那么四个字节能表示的范围是0–4294967295(2^32-1)。java中没有有符号和无符号的说法，都是取有符号的这种情况，所以在java中int类型的取值范围是-2147483648 ~ 2147483647，即-2^31 ~ 2^31-1。但是这个范围的底层原理是什么呢？下面讲一讲我的思考过程。","text":"java中int类型占四个字节，32位的，如果是有符号的数，那么四个字节能表示的范围-2147483648（-2^31） ~ 2147483647 （2^31-1），如果是无符号数，那么四个字节能表示的范围是0–4294967295(2^32-1)。java中没有有符号和无符号的说法，都是取有符号的这种情况，所以在java中int类型的取值范围是-2147483648 ~ 2147483647，即-2^31 ~ 2^31-1。但是这个范围的底层原理是什么呢？下面讲一讲我的思考过程。 int类型的最大值是2^31-1比较好理解，在java中，int类型转换为二进制数据的第一个位代表正负，0为正，1为负。所以int类型的最大值的二进制文件应该是 0111 1111 1111 1111 1111 1111 1111 1111。 转换为10进制int类型为 2^0 + 2^1 + 2^2 + 2^3 + … + 2^30 = 2^31 - 1。 int类型的最小值是-2^31,关于这个最小值，我钻了牛角尖，简单的以后最小值应该是 -(2^31-1),即-2147483647，但是事实上却是-2^31，即-2147483648。后来冥思苦想了很久才从牛角尖中钻出来，觉得十分有必要记录一下。 错误的思路:我为什么钻了牛角尖，刚刚说到，int类型的最大值转换为二进制为 0111 1111 1111 1111 1111 1111 1111 1111，然后又讲到二进制位的第一个位代表正负，0为正，1为负，所以最小值的表示应该是1111 1111 1111 1111 1111 1111 1111 1111，即 -(2^31-1)，看起来合情合理，所以我钻进了牛角尖。当然这也反映出我的基础还有待加强。 正确的思路:为什么上面这种思路是错误的呢？因为计算机中的负数根本就不是那么表示的(汗，大学的时候学过的，全都还给老师了。)在计算机中，所有的负数都是用补码去表示的。这里顺带提一下二进制数中的原码，反码和补码。 原码:int类型直接转换成二进制数就是原码，比如8的二进制为 0000 0000 0000 0000 0000 0000 0000 1000。 反码:将原码全部取反就得到了反码，比如上面8的二进制反码为 1111 1111 1111 1111 1111 1111 1111 0111 补码:将反码+1,得到的就是补码,比如8的二进制补码为 1111 1111 1111 1111 1111 1111 1111 1000 因为正整数的首位必须要是0，所以一个32位的二进制数，能够表示数值的，只能是后面的31位，而负整数的首位是1，这个1呢，它不能完全按照符号位来理解，它也是可以参与数值的表示的。比如int类型的最大值2^31-1，二进制为 0111 1111 1111 1111 1111 1111 1111 1111，所以它的反码为1000 0000 0000 0000 0000 0000 0000 0000，它的补码为1000 0000 0000 0000 0000 0000 0000 0001。 那么-(2^31-1)即-2147483647的二进制表示应该就是1000 0000 0000 0000 0000 0000 0000 0001，补码再减1，就是1000 0000 0000 0000 0000 0000 0000 0000，即十进制中的-2147483648，也就是-2^31。仔细看看-2^31的补码,首位为1，这个时候的首位，其实同时充当了符号位和数值位，以上面-(2^31-1)的补码为例，首位是1，所以这是一个负数，并且由于首位是1，所以首位代表的数为-2^31，同时，最后一位是1，所以应该再加上1，即-2^31+1。 所以，二进制中补码的规则，可以看成是-2^(长度-1) + (除首位以外的值的和)，比如-1的二进制表示为 11111111111111111111111111111111，它就可以看成是 -2^31 +（2^31-1） = -1。 这样一来为什么int类型的最小值为-2^31就彻底搞明白了。 int类型溢出我们都知道，Integer.MAX_VALUE + 1或者是Integer.MIN_VALUE-1都会产生溢出，Integer.MAX_VALUE+1=Integer.MIN_VALUE,Integer.MIN_VALUE-1=Integer.MAX_VALUE。只要想明白了上面的二进制表示问题，溢出的原因就很好解释了。 Integer.MAX_VALUE的二进制表示为 01111111111111111111111111111111，再加1的话就会变成1000 0000 0000 0000 0000 0000 0000 0000，这也就是Integer.MIN_VALUE的二进制值。 Integer.MIN_VALUE的二进制表示为 1000 0000 0000 0000 0000 0000 0000 0000,再减去1的话就会变成 01111111111111111111111111111111，这也就是Integer.MAX_VALUE的二进制值。","categories":[{"name":"java基础","slug":"java基础","permalink":"www.hlblogs.com/categories/java基础/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"www.hlblogs.com/tags/java基础/"}]},{"title":"最大堆与最小堆","slug":"数据结构与算法/最大堆与最小堆(writing)","date":"2018-12-16T16:00:00.000Z","updated":"2018-12-17T08:56:35.251Z","comments":true,"path":"2018/12/17/数据结构与算法/最大堆与最小堆(writing)/","link":"","permalink":"www.hlblogs.com/2018/12/17/数据结构与算法/最大堆与最小堆(writing)/","excerpt":"常用的最大/小堆其实就是一颗完全二叉树。除了完全二叉树所具有的基本特性以外，最大/小堆还有以下特性:1.最大堆父节点一定大于子节点，最小堆父节点一定小于子节点。2.因为是完全二叉树，所以一般用数组来表示，如果某个节点的节点位置在下标n处，那么其左孩子节点为：2 n + 1 ，其右孩子节点为2 (n + 1)，其父节点为(n – 1) / 2 处。","text":"常用的最大/小堆其实就是一颗完全二叉树。除了完全二叉树所具有的基本特性以外，最大/小堆还有以下特性:1.最大堆父节点一定大于子节点，最小堆父节点一定小于子节点。2.因为是完全二叉树，所以一般用数组来表示，如果某个节点的节点位置在下标n处，那么其左孩子节点为：2 n + 1 ，其右孩子节点为2 (n + 1)，其父节点为(n – 1) / 2 处。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"www.hlblogs.com/categories/数据结构与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"www.hlblogs.com/tags/数据结构/"}]},{"title":"35. Reverse Linked List","slug":"刷题/LintCode/35.Reverse Linked List","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-21T07:43:04.360Z","comments":true,"path":"2018/12/13/刷题/LintCode/35.Reverse Linked List/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/35.Reverse Linked List/","excerpt":"Reverse Linked ListLevel : Easy","text":"Reverse Linked ListLevel : Easy ProblemDescriptionReverse a linked list. Example1234Example1:For linked list 1-&gt;2-&gt;3, the reversed linked list is 3-&gt;2-&gt;1Example2:For linked list 1-&gt;2-&gt;3-&gt;4, the reversed linked list is 4-&gt;3-&gt;2-&gt;1 ChallengeReverse it in-place and in one-pass Thinking单链表翻转，要求原地一次翻转完成。 Code非递归方式翻转:12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; next = null; &#125;&#125;public class ReverseLinkedList &#123; public static void main(String[] args) &#123; ListNode node1 = new ListNode(0); ListNode node2 = new ListNode(1); node1.next = node2; ReverseLinkedList reverseLinkedList = new ReverseLinkedList(); ListNode newHead = reverseLinkedList.reverse(node1); System.out.println(newHead.val+\" \"+newHead.next.val); &#125; public ListNode reverse(ListNode head) &#123; if(head == null)&#123; return null; &#125; // write your code here ListNode pre = head; ListNode next = head.next; head.next = null; while(next != null)&#123; head = next; next = next.next; head.next = pre; pre = head; &#125; return head; &#125;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"idea使用问题记录","slug":"idea/idea使用问题记录","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-08T07:03:37.414Z","comments":true,"path":"2018/12/13/idea/idea使用问题记录/","link":"","permalink":"www.hlblogs.com/2018/12/13/idea/idea使用问题记录/","excerpt":"idea使用问题记录","text":"idea使用问题记录 idea插件下载失败检查了网络没有问题，试过梯子，插件始终无法下载下来。经过google找到了解决方案Setting -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Updates -&gt; use secure connection(默认勾选，将它取消) Method breakpoints may dramatically slow down debugging断点打在了方法上面，导致项目启动变慢，IDEA调试越来越慢。Ctrl+shift+F8 打开 Breakpoints 面板，找到对应的断点取消即可","categories":[{"name":"开发工具","slug":"开发工具","permalink":"www.hlblogs.com/categories/开发工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"www.hlblogs.com/tags/idea/"}]},{"title":"idea中好用的插件","slug":"idea/idea插件","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-18T04:30:42.851Z","comments":true,"path":"2018/12/13/idea/idea插件/","link":"","permalink":"www.hlblogs.com/2018/12/13/idea/idea插件/","excerpt":"网上搜集来的idea中好用的插件","text":"网上搜集来的idea中好用的插件 Lombok编译时自动生成set方法和get方法 google-java-format保存时自动格式化 CodeGlance代码地图 GsonFormat一键根据json文本生成java类，非常方便 Background image Plus设置idea背景图片 active-power-mode这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。 Nyan progress bar这是一个将你idea中的所有的进度条都变成萌新动画的小插件。 Rainbow Brackets彩虹颜色的括号 看着很舒服 敲代码效率变高 stackoverflow这一看似平淡的右键stackoverflow，却把其中的闷骚体现的淋漓尽致：我就这么叼，我就不去浏览器里查，只有右键才和我的右手匹配。 FindBugs-IDEA可以对多种级别的内容进行finbugs,分析完之后会有一个视图进行提示，详细的说明是哪种问题。 CheckStyle-IDEA通过检查对代码编码格式，命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，从而有效约束开发人员更好地遵循代码编写规范。 软件安装成功之后，首先要设置规则。可以通过Preferences—&gt;Other Settings —&gt;CheckStyles进行设置，可以直接将文件添加进来，然后就可以对具体的文件进行检查了。 MetricsReloaded代码复杂度检查 VisualVM Launcher运行 java 程序的时候启动 visualvm，方便查看 jvm 的情况 比如堆内存大小的分配，某个对象占用了多大的内存，jvm 调优必备工具。 MyBatisCodeHelperPromybatis 代码自动生成插件，大部分单表操作的代码可自动生成，减少重复劳动 大幅提升效率。 Translation最好用的翻译插件，功能很强大，界面很漂亮。","categories":[{"name":"开发工具","slug":"开发工具","permalink":"www.hlblogs.com/categories/开发工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"www.hlblogs.com/tags/idea/"}]},{"title":"PriorityBlockingQueue源码阅读笔记","slug":"源码阅读/java/juc/队列/PriorityBlockingQueue源码阅读笔记","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-26T09:28:15.969Z","comments":true,"path":"2018/12/13/源码阅读/java/juc/队列/PriorityBlockingQueue源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/PriorityBlockingQueue源码阅读笔记/","excerpt":"PriorityBlockingQueue源码阅读笔记PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，因为使用了可重入锁，所以它是线程安全的。","text":"PriorityBlockingQueue源码阅读笔记PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，因为使用了可重入锁，所以它是线程安全的。 字段1234567891011121314151617181920212223242526//默认的数组容量private static final int DEFAULT_INITIAL_CAPACITY = 11;//底层数组的最大长度private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;//用来存储数据的底层数组private transient Object[] queue;//队列中数据的个数private transient int size;//比较器，如果队列使用成员数据的自然排序规则，则此比较器为nullprivate transient Comparator&lt;? super E&gt; comparator;//可重入锁，保证线程安全private final ReentrantLock lock;//条件队列，用于队列中无数据时的线程阻塞private final Condition notEmpty;/** * Spinlock for allocation, acquired via CAS. *///自旋锁，通过CAS获取private transient volatile int allocationSpinLock; 生产数据PriorityBlockingQueue提供了off(E),add(E),put(E)三个方法实现数据的入列。 offer(E):boolean因为PriorityBlockingQueue是一个无界队列，所以这个方法永远不会返回false，它可以一直添加成功，直到内存爆掉。1234567891011121314151617181920212223242526public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; while ((n = size) &gt;= (cap = (array = queue).length)) // 如果当前队列中的元素数量大于等于底层数组的长度，就需要扩容了 // 根据既定的扩容规则扩容以后，如果依然未能满足需求，那就继续进行扩容操作。 tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) //数据入列，并且通过自然排序比较来维持二叉堆的结构 siftUpComparable(n, e, array); else //数据入列，通过指定的比较器来实现维持二叉堆的结构 siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true;&#125; add(E):boolean123public boolean add(E e) &#123; return offer(e);&#125; put(E):void123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public void put(E e) &#123; //因为PriorityBlockingQueue是一个无界队列，所以这里永远不需要阻塞 offer(e); &#125;``` ## 扩容PriorityBlockingQueue底层存储数据使用的是数组结构，当数组空间被使用完毕以后，就需要对数组进行扩容操作。```javaprivate void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // must release and then re-acquire main lock Object[] newArray = null; if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; //计算出一个新的容量 //如果旧的数组容量小于64 则新的容量 = 旧的容量 + (旧的容量 + 2) //如果旧的数组容量大于等于64，则新的容量 = 旧的容量 + (旧的容量 &gt;&gt; 1) int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : (oldCap &gt;&gt; 1)); //通过上面的方式计算出来的容量可能会超出int类型所能表示的上限， //如果新的容量已经超出了限制 并且 旧的容量已经达到了上限，抛出异常 //如果新的容量已经超出了限制 并且 旧的容量未达到上限，则新的容量等于int类型上限 if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; &#125; //根据上面计算出的新的容量，创建一个新的数组实例 if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; &#125; &#125; //如果有其他的线程已经处于扩容阶段，则此线程重新参与竞争锁 if (newArray == null) Thread.yield(); lock.lock(); if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; //将旧数组中的数组复制到新的数组中来 System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; 维护二叉堆的结构添加数据可能会破坏底层的二叉堆结构，所以在数据入列的时候就需要同时去维护这个堆结构生产数据时维护数据结构比较简单，主要就是将新节点与其父节点进行比较，然后在拿父节点和祖父节点进行比较，根据对应的排序规则对两个节点的数据进行交换操作最终找到适当的位置。1234567891011121314151617181920212223242526private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; if (key.compareTo((T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = key;&#125;private static &lt;T&gt; void siftUpUsingComparator(int k, T x, Object[] array, Comparator&lt;? super T&gt; cmp) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; if (cmp.compare(x, (T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = x;&#125; 消费数据每一次出列的元素都是底层数组中下标为0的那个，再把队列中的最后一个元素给挪到下标为0的位置，然后再维护二叉堆的结构，这就是出列的整个过程。dequeue():E123456789101112131415161718private E dequeue() &#123; int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; E result = (E) array[0]; E x = (E) array[n]; array[n] = null; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125;&#125; 维护二叉堆的结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 使用自然排序比较优先级的方式维护底层的堆结构 * k: 需要填充的位置 * x: 等待填充的元素，会填充在k位置 * array: 堆数组 * n: 堆元素的数量 */private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array, int n) &#123; if (n &gt; 0) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x; int half = n &gt;&gt;&gt; 1; // 非叶子节点无限循环，从完全二叉树的结构来看，二叉树的叶子节点一定占到总节点数的一半+1 while (k &lt; half) &#123; //假设左子节点的值最小 int child = (k &lt;&lt; 1) + 1; Object c = array[child]; int right = child + 1; if (right &lt; n &amp;&amp; ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0) //如果左子节点大于右子节点，就取右子节点的值比较 c = array[child = right]; if (key.compareTo((T) c) &lt;= 0) //如果key的值小于它的左子节点或右子节点，就退出循环，结构维护结束 break; //将两个子节点中比较小的节点的值赋值给父节点 array[k] = c; //记录左右子节点中比较小的节点的下标，用于在下一次循环中获取父节点 k = child; &#125; //循环结束后将待填充的元素填充在适当的位置 array[k] = key; &#125;&#125;/** * 使用指定的比较器来比较优先级的方式维护底层的堆结构 * k: 需要填充的位置 * x: 等待填充的元素，会填充在k位置 * array: 堆数组 * n: 堆元素的数量 * cmp: 指定的比较器 */private static &lt;T&gt; void siftDownUsingComparator(int k, T x, Object[] array, int n, Comparator&lt;? super T&gt; cmp) &#123; if (n &gt; 0) &#123; int half = n &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = array[child]; int right = child + 1; if (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; 0) c = array[child = right]; if (cmp.compare(x, (T) c) &lt;= 0) break; array[k] = c; k = child; &#125; array[k] = x; &#125;&#125; 比较器比较器主要用于实现优先级的比较，开发人员可以根实际情况来选择要不要做具体实现。实现一个定制的比较器需要实现Comparator接口.这个接口中的方法比较多，就不一一解释了，这里只对最重要的一个方法做一下解释。1234567891011public interface Comparator&lt;T&gt; &#123; /** * 返回值代表了o1和O2的比较结果 * 返回值小于0 : o1 &lt; o2 * 返回值等于0 : o1==o2 * 返回值大于0 : o1 &gt; o2 */ int compare(T o1, T o2); //...此处省略接口中其他的方法&#125; 开发人员实现了比较器以后，优先级队列中再做优先级比较，就会使用开发人员自己实现的比较器，而不是自然排序. 总结PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，并且每一次数据入列和出列都会相应的调整堆结构.因为使用了可重入锁，所以它是线程安全的。但是，由于数据入列和出列使用同一把锁，所以在PriorityBlockingQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"DelayQueue源码阅读笔记","slug":"源码阅读/java/juc/队列/DelayQueue源码阅读笔记","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-14T01:13:45.006Z","comments":true,"path":"2018/12/13/源码阅读/java/juc/队列/DelayQueue源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/DelayQueue源码阅读笔记/","excerpt":"DelayQueue源码阅读笔记DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。","text":"DelayQueue源码阅读笔记DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。 字段1234567891011121314151617181920212223242526//可重入锁保证线程安全private final transient ReentrantLock lock = new ReentrantLock();//优先级队列private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;();/** * Thread designated to wait for the element at the head of * the queue. This variant of the Leader-Follower pattern * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to * minimize unnecessary timed waiting. When a thread becomes * the leader, it waits only for the next delay to elapse, but * other threads await indefinitely. The leader thread must * signal some other thread before returning from take() or * poll(...), unless some other thread becomes leader in the * interim. Whenever the head of the queue is replaced with * an element with an earlier expiration time, the leader * field is invalidated by being reset to null, and some * waiting thread, but not necessarily the current leader, is * signalled. So waiting threads must be prepared to acquire * and lose leadership while waiting. *///当leader不为空时，只有leader能等待第一个元素返回，其他的元素必须无限期等待，等待leader从poll方法或take方法返回后将它们唤醒private Thread leader = null;//条件等待队列，与ReentrentLocK搭配private final Condition available = lock.newCondition(); Delayed接口DelayQueue队列中所有的元素都必须实现Delayed接口，Delayed接口中有一个getDelay方法用来返回剩余的延迟时间。123456//Delayed接口继承了Comparable接口，所以实现此接口的同时，还需要实现Comparable接口中的compareTo方法。public interface Delayed extends Comparable&lt;Delayed&gt; &#123; //返回剩余的延迟时间，0和负数代表已经过了延迟的时间 long getDelay(TimeUnit unit);&#125; DelayQueueDelayQueue中的大部分功能都沿用了PriorityQueue中的实现，非常的简单。它的特殊点主要集中在出列的时候。 poll():E1234567891011121314public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; E first = q.peek(); //如果队列中没有元素或者第一个元素指定的延迟时间还没有到达，返回null if (first == null || first.getDelay(NANOSECONDS) &gt; 0) return null; else return q.poll(); &#125; finally &#123; lock.unlock(); &#125;&#125; poll(long,TimeUnit):E此方法会响应中断12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * timeout: 等待时间数值 * unit: 等待时间单位 */public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; //将等待时间转换为纳秒形式 long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; E first = q.peek(); if (first == null) &#123; if (nanos &lt;= 0) //如果等待时间小于等于0并且队列中无数据，直接返回null return null; else //如果等待时间大于0并且队列中无数据，将线程阻塞直到等待时间过期 nanos = available.awaitNanos(nanos); &#125; else &#123; //如果队列不是空队列，取第一个元素的剩余延迟时间 long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0) //如果第一个元素的剩余时间小于等于0了，就将第一个元素出列并返回。 return q.poll(); if (nanos &lt;= 0) //如果第一个元素的剩余延迟时间还未过，但是等待时间已经过期了，就返回null. return null; first = null; // don't retain ref while waiting if (nanos &lt; delay || leader != null) //如果等待时间小于第一个元素的剩余延迟时间，将线程阻塞直到等待时间过期。 nanos = available.awaitNanos(nanos); else &#123; Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; //如果等待时间大于等于第一个元素的剩余延迟时间，将线程阻塞直到第一个元素的延迟时间过期 long timeLeft = available.awaitNanos(delay); //重新计算等待时间 nanos -= delay - timeLeft; &#125; finally &#123; if (leader == thisThread) //将leader置空 leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; q.peek() != null) //如果leader为空并且队列不为空，唤醒正在等待中的线程。 available.signal(); lock.unlock(); &#125;&#125; take():E此方法会响应中断12345678910111213141516171819202122232425262728293031323334353637383940414243public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; E first = q.peek(); if (first == null) //如果队列是空队列，将线程阻塞起来进入条件等待队列 available.await(); else &#123; //如果队列不是空队列，取第一个元素的剩余延迟时间 long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0) //如果第一个元素的剩余时间小于等于0了，就将第一个元素出列并返回。 return q.poll(); first = null; // don't retain ref while waiting if (leader != null) //如果 队列非空&amp;&amp;剩余延迟时间&gt;0&amp;&amp;leader!=null //此时只有leader能得带第一个元素的延迟时间到期，其余的所有线程都将被阻塞 //等待leader线程将它们唤醒，转移到CLH队列中竞争锁 available.await(); else &#123; Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; //如果 队列非空&amp;&amp;剩余延迟时间&gt;0&amp;&amp;leader=null //将当前线程设置为leader,使其他的线程全部阻塞，当前线程等待第一个元素的延迟时间过期 available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; q.peek() != null) //如果leader为空并且队列不为空，唤醒正在等待中的线程。 //之所以需要判断leader是否为null的情况，是因为此时可能leader被其他线程持有并且没有释放，在这种情况下任何非leader线程都只能等待leader被释放 available.signal(); lock.unlock(); &#125;&#125; 总结DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。但是，由于数据入列和出列使用同一把锁，所以在DelayQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"jconcole连接java进程报错问题解决","slug":"jvm/jconsole连接java进程报错问题","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-18T04:27:35.592Z","comments":true,"path":"2018/12/13/jvm/jconsole连接java进程报错问题/","link":"","permalink":"www.hlblogs.com/2018/12/13/jvm/jconsole连接java进程报错问题/","excerpt":"jconcole连接java进程报错问题解决","text":"jconcole连接java进程报错问题解决 问题:使用JConsole连接java进程的时候报错。12345678910Exception in thread \"VMPanel.connect\" java.lang.InternalError: Remote thread failed for unknown reason at sun.tools.attach.WindowsVirtualMachine.enqueue(Native Method) at sun.tools.attach.WindowsVirtualMachine.&lt;init&gt;(WindowsVirtualMachine.java:62) at sun.tools.attach.WindowsAttachProvider.attachVirtualMachine(WindowsAttachProvider.java:69) at com.sun.tools.attach.VirtualMachine.attach(VirtualMachine.java:208) at sun.tools.jconsole.LocalVirtualMachine.loadManagementAgent(LocalVirtualMachine.java:232) at sun.tools.jconsole.LocalVirtualMachine.startManagementAgent(LocalVirtualMachine.java:98) at sun.tools.jconsole.ProxyClient.tryConnect(ProxyClient.java:333) at sun.tools.jconsole.ProxyClient.connect(ProxyClient.java:313) at sun.tools.jconsole.VMPanel$2.run(VMPanel.java:294) 解决:项目启动的时候加上启动参数-Dcom.sun.management.jmxremote","categories":[{"name":"jvm","slug":"jvm","permalink":"www.hlblogs.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"www.hlblogs.com/tags/jvm/"}]},{"title":"CMS垃圾收集器","slug":"jvm/CMS垃圾收集器","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-25T06:29:41.945Z","comments":true,"path":"2018/12/13/jvm/CMS垃圾收集器/","link":"","permalink":"www.hlblogs.com/2018/12/13/jvm/CMS垃圾收集器/","excerpt":"CMS垃圾收集器","text":"CMS垃圾收集器 CMS出现的初衷和目的GC的出现是为了解决Throught收集器和Serial收集器在Full GC周期中的长时间停顿。 CMS的工作区域和适用场景CMS的主要工作区域是老年代，它在老年代中尽可能的并发执行，每个GC周期只有2次短停顿如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的CPU资源也比较丰富，就适合适用CMS收集器。 CMS的工作流程初始标记初始标记主要是标记GC Roots可达的老年代对象以及新生代引用的老年代对象。这个过程在jdk1.7时是单线程执行，在1.8以后是多线程并发执行(可以通过参数CMSParallelInitialMarkEnabled调整)。初始标记会暂停工作线程(Stop The World)。 并发标记并发标记主要是根据初始标记节点锁标记处的对象向下追踪，将所有可追踪到的对象标记出来，但是这个阶段是GC线程与工作线程并发工作，所以在进行并发标记的时候可能会有些已经在初始标记阶段标记出来的对象发生了改变，或者有一些对象从年轻代晋升到了老年代，或者是有些大对象被直接分配到了老年代，这些对象在并发标记阶段会被标记为dirty,在重新标记阶段对这些dirty对象进行重新标记。 重新标记重新标记阶段与初始标记阶段一样会暂停工作线程(STW),这个阶段需要重新扫描并标记堆中的对象，包括新生代，GCRoots和被标记为dirty的对象。 并发清除并发清除阶段，用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达，然后清除。 预清理阶段CMS一般常说的工作流程就上面四个，即初始标记-&gt;并发标记-&gt;重新标记-&gt;并发清除。在重新标记阶段会扫描新生代，GCRoots以及并发标记阶段标记为dirty的对象，这个过程是比较耗时的，在重新标记阶段会产生较长时间的STW。在并发标记阶段和重新标记阶段之间，其实还有一个预清理阶段，这个阶段也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：（1）老年代中card为dirty的对象；（2）幸存区(from和to)中引用的老年代对象。因此，这个阶段也需要扫描新生代+老年代。 并发重置CMS内部重置回收器状态，准备进入下一个并发回收周期。 CMS的异常情况CMS收集器也并不是每一次都能成功完成整个垃圾收集流程，当出现异常情况时，CMS可能会退出工作流程。 永久代耗尽异常默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就会触发Full GC，这种情况下CMS就会退出当前工作流程转为触发一次Full GC。 并发模式失败在CMS工作流程中的并发标记和并发清理阶段，GC线程和工作线程是同时工作的，如果在此期间有大对象直接分配到老年代，但是老年代没有足够的可用内存，就会产生异常(concurrent mode failure),CMS收集器工作停止，转为一次Full GC. 晋升失败异常新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象。如果担保机制发现老年代的可用内存不够，或者如果担保机制判断老年代可用内存是够的，但是实际上由于碎片问题或者确实内存不够导致无法分配，就会产生异常，这个时候minor gc失败，cms的工作流程退出，全部转化为一次Full GC。 CMS调优","categories":[{"name":"jvm","slug":"jvm","permalink":"www.hlblogs.com/categories/jvm/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"www.hlblogs.com/tags/jvm/"}]},{"title":"LinkedBlockingDeque源码阅读笔记","slug":"源码阅读/java/juc/队列/LinkedBlockingDeque源码阅读笔记(waitting)","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-26T07:48:39.358Z","comments":true,"path":"2018/12/13/源码阅读/java/juc/队列/LinkedBlockingDeque源码阅读笔记(waitting)/","link":"","permalink":"www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/LinkedBlockingDeque源码阅读笔记(waitting)/","excerpt":"LinkedBlockingDeque源码阅读笔记LinkedBlockingDeque是一个有界阻塞队列，其底层技术为AtomicInteger+ReentrentLock+Condition+双端链表。","text":"LinkedBlockingDeque源码阅读笔记LinkedBlockingDeque是一个有界阻塞队列，其底层技术为AtomicInteger+ReentrentLock+Condition+双端链表。 字段1234567891011121314151617181920//双端链表的头结点transient Node&lt;E&gt; first;//双端链表的尾节点transient Node&lt;E&gt; last;//当前队列中的元素数量private transient int count;//队列的最大容量private final int capacity;//可重入锁final ReentrantLock lock = new ReentrantLock();//消费者等待队列private final Condition notEmpty = lock.newCondition();//生产者等待队列private final Condition notFull = lock.newCondition(); 重要方法linkFirst(Node):boolean将指定节点设置为头结点12345678910111213141516private boolean linkFirst(Node&lt;E&gt; node) &#123; // assert lock.isHeldByCurrentThread(); if (count &gt;= capacity) return false; Node&lt;E&gt; f = first; node.next = f; first = node; if (last == null) last = node; else f.prev = node; ++count; //从消费者等待队列中唤醒一个消费者 notEmpty.signal(); return true;&#125; linkLast(Node):boolean将指定节点设置为尾结点12345678910111213141516private boolean linkLast(Node&lt;E&gt; node) &#123; // assert lock.isHeldByCurrentThread(); if (count &gt;= capacity) return false; Node&lt;E&gt; l = last; node.prev = l; last = node; if (first == null) first = node; else l.next = node; ++count; //从消费者等待队列中唤醒一个消费者 notEmpty.signal(); return true;&#125; unlinkFirst():E返回并删除头结点，如果头结点为null，则返回null12345678910111213141516171819private E unlinkFirst() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; f = first; if (f == null) return null; Node&lt;E&gt; n = f.next; E item = f.item; f.item = null; f.next = f; // help GC first = n; if (n == null) last = null; else n.prev = null; --count; //从生产者等待队列中唤醒一个生产者 notFull.signal(); return item;&#125; unlinkLast():E返回并删除尾结点，如果尾结点为null，则返回null12345678910111213141516171819private E unlinkLast() &#123; // assert lock.isHeldByCurrentThread(); Node&lt;E&gt; l = last; if (l == null) return null; Node&lt;E&gt; p = l.prev; E item = l.item; l.item = null; l.prev = l; // help GC last = p; if (p == null) first = null; else p.next = null; --count; //从生产者等待队列中唤醒一个生产者 notFull.signal(); return item;&#125;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"LinkedBlockingQueue源码阅读笔记","slug":"源码阅读/java/juc/队列/LinkedBlockingQueue源码阅读笔记","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-26T07:48:39.360Z","comments":true,"path":"2018/12/13/源码阅读/java/juc/队列/LinkedBlockingQueue源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/LinkedBlockingQueue源码阅读笔记/","excerpt":"LinkedBlockingQueue源码阅读笔记LinkedBlockingQueue是一个基于双端链表的有界阻塞队列。它底层使用了AtomicInteger+ReentrantLock+Condition+单链表 来实现。不同于ArrayBlockingQueue和PriorityBlockingQueue，LinkedBlockingQueue中有两个ReentrantLock实例，一个读锁，一个作为写锁，这样在数据入列和出列的时候互不干扰，不会相互阻塞。","text":"LinkedBlockingQueue源码阅读笔记LinkedBlockingQueue是一个基于双端链表的有界阻塞队列。它底层使用了AtomicInteger+ReentrantLock+Condition+单链表 来实现。不同于ArrayBlockingQueue和PriorityBlockingQueue，LinkedBlockingQueue中有两个ReentrantLock实例，一个读锁，一个作为写锁，这样在数据入列和出列的时候互不干扰，不会相互阻塞。 字段123456789101112131415161718192021222324// 队列容量范围,如果未设置，则默认为Integer.MAX_VALUEprivate final int capacity;//当前队列中的元素数量private final AtomicInteger count = new AtomicInteger();//底层链表的头节点transient Node&lt;E&gt; head;//底层链表的尾节点private transient Node&lt;E&gt; last;//消费者锁private final ReentrantLock takeLock = new ReentrantLock();//消费者等待队列private final Condition notEmpty = takeLock.newCondition();//生产者锁private final ReentrantLock putLock = new ReentrantLock();//生产者等待队列private final Condition notFull = putLock.newCondition(); 节点1234567static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125;&#125; 生产数据(入列)offer(E):boolean12345678910111213141516171819202122232425262728public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final AtomicInteger count = this.count; //如果当前队列中的元素数量已经达到了执行的容量的上限，则入列失败 if (count.get() == capacity) return false; int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; putLock.lock(); try &#123; if (count.get() &lt; capacity) &#123; //数据入列 enqueue(node); //获取元素数量并使元素数量+1，返回的是未+1的数量 c = count.getAndIncrement(); if (c + 1 &lt; capacity) //队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。 notFull.signal(); &#125; &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) //如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者 signalNotEmpty(); return c &gt;= 0;&#125; put(E):void12345678910111213141516171819202122232425262728public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; //如果队列容量已经达到上限，阻塞当前线程，加入到生产者条件队列中 while (count.get() == capacity) &#123; notFull.await(); &#125; //数据入列 enqueue(node); //获取元素数量并使元素数量+1，返回的是未+1的数量 c = count.getAndIncrement(); if (c + 1 &lt; capacity) //队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。 notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) //如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者 signalNotEmpty();&#125; offer(E e, long timeout, TimeUnit unit):boolean1234567891011121314151617181920212223242526272829303132public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); long nanos = unit.toNanos(timeout); int c = -1; final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; //如果队列容量已经达到上限，将当前线程阻塞一段时间，加入到生产者条件队列中 while (count.get() == capacity) &#123; //如果指定的阻塞时间小于0，本次入列失败 if (nanos &lt;= 0) return false; nanos = notFull.awaitNanos(nanos); &#125; //数据入列 enqueue(new Node&lt;E&gt;(e)); //获取元素数量并使元素数量+1，返回的是未+1的数量 c = count.getAndIncrement(); if (c + 1 &lt; capacity) //队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。 notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) //如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者 signalNotEmpty(); return true;&#125; offer(E):boolean、offer(E, long, TimeUnit):boolean和put(E):void的不同offer: 如果队列容量已满，本次入列失败offer(E, long, TimeUnit):boolean：如果对列容量已满，将当前线程阻塞一段时间，将当前线程加入到生产者等待队列中。put: 如果对列容量已满，阻塞当前线程，将当前线程加入到生产者等待队列中。 消费数据(出列)poll():E123456789101112131415161718192021222324252627public E poll() &#123; final AtomicInteger count = this.count; if (count.get() == 0) //如果当前队列是空队列，直接返回null return null; E x = null; int c = -1; final ReentrantLock takeLock = this.takeLock; takeLock.lock(); try &#123; if (count.get() &gt; 0) &#123; //元素出列 x = dequeue(); //获取队列中的元素数量并使元素数量-1，返回的是未-1的数量 c = count.getAndDecrement(); if (c &gt; 1) //如果当前元素出列以后队列依然有元素存在，从消费者等待队列唤醒一个消费者。 notEmpty.signal(); &#125; &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) //如果当前元素出列之前队列是满的，那么在出列之后需要从生产者等待队列唤醒一个生产者。 signalNotFull(); return x;&#125; take():E12345678910111213141516171819202122public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; //如果当前队列是空队列，就将当前线程阻塞起来，加入到消费者等待队列中。 notEmpty.await(); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125; 移除数据(出列)remove(Object):boolean1234567891011121314151617181920public boolean remove(Object o) &#123; if (o == null) return false; //获取读锁和写锁，将读写全部阻塞住 fullyLock(); try &#123; //表头开始，找到指定的元素并断开该元素和链表的关联(删除该元素) for (Node&lt;E&gt; trail = head, p = trail.next; p != null; trail = p, p = p.next) &#123; if (o.equals(p.item)) &#123; unlink(p, trail); return true; &#125; &#125; return false; &#125; finally &#123; //将读锁和写锁全部释放 fullyUnlock(); &#125;&#125;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"ArrayBlockingQueue源码阅读笔记","slug":"源码阅读/java/juc/队列/ArrayBlockingQueue源码阅读笔记","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-26T09:28:15.967Z","comments":true,"path":"2018/12/13/源码阅读/java/juc/队列/ArrayBlockingQueue源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/12/13/源码阅读/java/juc/队列/ArrayBlockingQueue源码阅读笔记/","excerpt":"ArrayBlockingQueue是一个有界阻塞队列，它的可容纳的最大的数据量取决于队列初始化时的设置，它的内部通过Object[],ReentrentLock和两个Condition实现了一个非常经典的生产者消费者场景，","text":"ArrayBlockingQueue是一个有界阻塞队列，它的可容纳的最大的数据量取决于队列初始化时的设置，它的内部通过Object[],ReentrentLock和两个Condition实现了一个非常经典的生产者消费者场景， 基本使用源码分析底层技术: Object[] + ReentrentLock + Condition(两个Condition,生产者消费者场景)1234567891011121314151617181920//队列中的保存数据的容器final Object[] items;//下一次从队列中获取数据的位置偏移量int takeIndex;//下一次添加数据到队列中的位置偏移量int putIndex;//队列中的数据量int count;//可重入锁final ReentrantLock lock;//消费者条件队列private final Condition notEmpty;//生产者条件队列private final Condition notFull; 生产数据数据入列1234567891011121314private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; //添加数据到队列中 items[putIndex] = x; //修改下一次添加数据到队列的数据偏移量，如果已经到达了数组的终点边界， //就将偏移量置为0，循环使用数组 if (++putIndex == items.length) putIndex = 0; count++; //唤醒消费者队列中的第一个节点去消费数据 notEmpty.signal();&#125; offer(E)1234567891011121314151617//返回值代表是否成功生产数据public boolean offer(E e) &#123; checkNotNull(e); //使用可重入锁，保证生产数据的安全 final ReentrantLock lock = this.lock; lock.lock(); try &#123; if (count == items.length) return false; else &#123; enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; add(E):1234567891011//返回值代表是否成功生产数据。public boolean add(E e) &#123; return super.add(e);&#125;public boolean add(E e) &#123; if (offer(e)) return true; else throw new IllegalStateException(\"Queue full\");&#125; put(E)12345678910111213141516public void put(E e) throws InterruptedException &#123; checkNotNull(e); //使用可重入锁保证生产数据时的安全问题 final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) //如果当前队列中的数据已经达到了可以容纳的上限，就将当先线程阻塞进入生产者队列, //等待消费者将数据消费了以后，会将生产者队列中的第一个节点唤醒 notFull.await(); //数据入列 enqueue(e); &#125; finally &#123; lock.unlock(); &#125;&#125; ArrayBlockingQueue中提供了三个方法用来生产数据，offer(E),add(E)以及put(E)，这其中add(E)和put(E)内部也是通过调用offer(E)来实现的。put(E)在队列中数据已达上限的时候会将线程阻塞，直至有消费者将队列中的数据消费掉。offer(E)和add(E)在队列中数据已达上限的时候不会阻塞，而是会添加失败。 消费数据数据出列1234567891011121314151617181920private E dequeue() &#123; // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; @SuppressWarnings(\"unchecked\") //取出队列中的第一个可消费数据 E x = (E) items[takeIndex]; //将被消费的数据所占用的空间释放 items[takeIndex] = null; if (++takeIndex == items.length) //如果可消费数据的偏移量已经到了队列的终点，就回到0的位置循环消费 takeIndex = 0; count--; if (itrs != null) //每次有数据出列都会调用，用来处理迭代器的相关逻辑，此处就不再细说了 itrs.elementDequeued(); //消费数据以后将生产者队列中的第一个节点唤醒来继续生产数据 notFull.signal(); return x;&#125; peek():E返回队列中的第一条数据，但是不会从队列中将之移除12345678910111213public E peek() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return itemAt(takeIndex); &#125; finally &#123; lock.unlock(); &#125;&#125;final E itemAt(int i) &#123; return (E) items[i];&#125; poll():E返回队列中的第一条数据,并且从队列中将之移除123456789public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; take():E返回队列中的第一条数据,如果队列为空，就将线程阻塞等待生产者生产数据。123456789101112public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) //队列为空，就将线程阻塞等待生产者生产数据。 notEmpty.await(); return dequeue(); &#125; finally &#123; lock.unlock(); &#125;&#125; ArrayBlockingQueue中提供了三个方法用来消费数据，peek():E,pool():E以及take():E,这三个方法内部都是通过调用dequeue():E来实现的。peek():E方法返回队列中的第一条数据，但是不会从队列中将之移除，pool():E方法返回队列中的第一条数据,并且从队列中将之移除。take():E方法返回队列中的第一条数据,如果队列为空，就将线程阻塞等待生产者生产数据。 总结ArrayBlockingQueue使用了一个Object数组作为底层数据存储的容器，用putIndex和takeIndex两个字段来表示数据入列和出列的位置。生产数据的时候从putIndex开始将数据按照数组的下标插入，消费数据的时候从takeIndex将数据一一删除。通过这种形式可以将底层数组循环使用。当putIndex和takeIndex重合的时候，表明当前队列中没有数据，那么所有的消费者都将被阻塞，等待生产者生产数据。当size等于当前数组的容量的时候，表面当前队列已满，那么所有的生产者都将被阻塞，等待消费者消费数据。 另外，由于数据入列和出列使用同一把锁，所以在ArrayBlockingQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"28. Search a 2D Matrix","slug":"刷题/LintCode/28. Search a 2D Matrix","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-21T07:40:14.393Z","comments":true,"path":"2018/12/13/刷题/LintCode/28. Search a 2D Matrix/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/28. Search a 2D Matrix/","excerpt":"Search a 2D MatrixLevel : Easy","text":"Search a 2D MatrixLevel : Easy ProblemDescriptionWrite an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties: Integers in each row are sorted from left to right.The first integer of each row is greater than the last integer of the previous row. Example1234567891011121314151617Example 1: Input: [[5]],2 Output: false Explanation: false if not included. Example 2: Input: [ [1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 50]],3 Output: true Explanation: return true if included. ChallengeO(log(n) + log(m)) time Thinking思路1:将二维数组转换为一维数组，然后做二分查找，时间复杂度O(n^2) 思路2:对每一个子数组做二分查找，时间复杂度O(mlogn) Code思路1:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class SearchA2DMatrix &#123; public static void main(String[] args) &#123; int[][] matrix = &#123;&#123;1, 3, 5,7&#125;, &#123;10,11,16,20&#125;, &#123;23,30,34,50&#125;&#125;; int target = 7; SearchA2DMatrix searchA2DMatrix = new SearchA2DMatrix(); boolean result = searchA2DMatrix.searchMatrix(matrix, target); System.out.println(result); &#125; public boolean searchMatrix(int[][] matrix, int target) &#123; // write your code here if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; int length = matrix.length * matrix[0].length; int[] arr = new int[length]; int arrIndex = 0; for (int i = 0; i &lt; matrix.length; i++) &#123; for (int j = 0; j &lt; matrix[0].length; j++) &#123; arr[arrIndex] = matrix[i][j]; arrIndex++; &#125; &#125; int pos = binarySearch(arr, 0, arr.length - 1,target); if (pos != -1) &#123; return true; &#125; return false; &#125; public int binarySearch(int[] arr, int start, int end, int target) &#123; int i = start; int j = end; while (start &lt;= end) &#123; int mid = (start + end) / 2; if (arr[mid] &gt; target) &#123; end = mid - 1; &#125; else if (arr[mid] == target) &#123; return mid; &#125; else &#123; start = mid + 1; &#125; &#125; return -1; &#125;&#125; 思路2:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class SearchA2DMatrix2 &#123; public static void main(String[] args) &#123; int[][] matrix = &#123;&#123;1, 3, 5,7&#125;, &#123;10,11,16,20&#125;, &#123;23,30,34,50&#125;&#125;; int target = 7; SearchA2DMatrix2 searchA2DMatrix = new SearchA2DMatrix2(); boolean result = searchA2DMatrix.searchMatrix(matrix, target); System.out.println(result); &#125; public boolean searchMatrix(int[][] matrix, int target) &#123; // write your code here if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123; return false; &#125; for (int i = 0; i &lt; matrix.length; i++) &#123; if(matrix[i][0] &lt;= target &amp;&amp; matrix[i][matrix[i].length-1] &gt;= target) &#123; int pos = binarySearch(matrix[i], 0, matrix[i].length - 1, target); if (pos != -1) &#123; return true; &#125; &#125; &#125; return false; &#125; public int binarySearch(int[] arr, int start, int end, int target) &#123; int i = start; int j = end; while (start &lt;= end) &#123; int mid = (start + end) / 2; if (arr[mid] &gt; target) &#123; end = mid - 1; &#125; else if (arr[mid] == target) &#123; return mid; &#125; else &#123; start = mid + 1; &#125; &#125; return -1; &#125;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"PriorityQueue源码阅读笔记","slug":"源码阅读/java/PriorityQueue源码阅读笔记","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-27T10:23:35.569Z","comments":true,"path":"2018/12/13/源码阅读/java/PriorityQueue源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/12/13/源码阅读/java/PriorityQueue源码阅读笔记/","excerpt":"PriorityQueue是一个无界队列,使用了二叉堆作为底层的数据结构，并且用一个Object[]来表示这个堆。PriorityQueue本身未做任何线程安全方面的处理，所以它本身是线程不安全的，在多线程环境下可能会出现线程安全问题。","text":"PriorityQueue是一个无界队列,使用了二叉堆作为底层的数据结构，并且用一个Object[]来表示这个堆。PriorityQueue本身未做任何线程安全方面的处理，所以它本身是线程不安全的，在多线程环境下可能会出现线程安全问题。 字段12345678910111213private static final int DEFAULT_INITIAL_CAPACITY = 11;//底层存储数据的结构，Priority底层使用的是二叉堆来实现，使用数组来表示二叉堆transient Object[] queue; //队列中元素的数量private int size = 0;//比较器，如果想要使用它的话，需要开发人员自己实现，当它为空的时候会使用默认的自然排序进行比较private final Comparator&lt;? super E&gt; comparator;//队列中元素的数量发生改变的次数transient int modCount = 0; 生产数据add(E):boolean123public boolean add(E e) &#123; return offer(e);&#125; offer(E):boolean12345678910111213141516public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length) //扩容 grow(i + 1); size = i + 1; if (i == 0) queue[0] = e; else //添加数据并维护堆结构 siftUp(i, e); return true;&#125; 扩容1234567891011121314151617181920212223242526private void grow(int minCapacity) &#123; int oldCapacity = queue.length; // 计算新的容量 // 原容量小于64，扩容后翻倍，准确来说是oldCapacity + oldCapacity + 2 // 原容量大于等于64，扩容后增加百分之50，oldCapacity+(oldCapacity &gt;&gt; 1) int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); if (newCapacity - MAX_ARRAY_SIZE &gt; 0) // 如果计算出的新的容量大于队列允许的最大值，需要重新计算 newCapacity = hugeCapacity(minCapacity); //扩容，创建一个新的数组，将原数组中的数据复制过去，然后将新的数组赋值给变量queue queue = Arrays.copyOf(queue, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; // 如果此时底层数组的长度已经达到了终极上限(Integer.MAX_VALUE)，那么再加一的话就会溢出 //这里如果小于0，说明已经溢出了，抛出OutOfMemoryError if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); // 重新计算新的容量 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 添加数据、维护堆结构1234567891011121314151617181920212223242526272829303132333435363738private void siftUp(int k, E x) &#123; if (comparator != null) //如果开发人员自己实现了一个比较器，就使用自己实现的那个比较器 //方法逻辑比较简单，可以参考堆结构的添加数据过程 siftUpUsingComparator(k, x); else //如果开发人员并未实现一个定制的构造器，就使用默认的自然排序来当做比较器进行使用。 //方法逻辑比较简单，可以参考堆结构的添加数据过程 siftUpComparable(k, x);&#125; @SuppressWarnings(\"unchecked\")private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key;&#125;@SuppressWarnings(\"unchecked\")private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = x;&#125; 消费数据peek():E获取队列中的第一个元素123public E peek() &#123; return (size == 0) ? null : (E) queue[0];&#125; poll():E获取队列中的第一个元素，并使它出列123456789101112public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result;&#125; 消费数据、维护结构123456789101112131415161718192021222324252627282930313233343536373839404142private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125;private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = key;&#125;@SuppressWarnings(\"unchecked\")private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x;&#125;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"www.hlblogs.com/tags/java基础/"}]},{"title":"AtomicInteger源码阅读笔记","slug":"源码阅读/java/AtomicInteger源码阅读笔记","date":"2018-12-12T16:00:00.000Z","updated":"2018-12-26T09:06:50.648Z","comments":true,"path":"2018/12/13/源码阅读/java/AtomicInteger源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/12/13/源码阅读/java/AtomicInteger源码阅读笔记/","excerpt":"AtomicInteger源码阅读笔记","text":"AtomicInteger源码阅读笔记 123456789101112public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue);&#125;public final int getAndSetInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var4)); return var5;&#125; 123456789101112public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta);&#125;public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 123456789101112public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 123456789101112public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1;&#125;public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 123public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta;&#125; 12345678public final int getAndUpdate(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return prev;&#125; 12345678public final int updateAndGet(IntUnaryOperator updateFunction) &#123; int prev, next; do &#123; prev = get(); next = updateFunction.applyAsInt(prev); &#125; while (!compareAndSet(prev, next)); return next;&#125; 123456789public final int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return prev;&#125; 1234567891011121314151617181920212223/** * Atomically updates the current value with the results of * applying the given function to the current and given values, * returning the updated value. The function should be * side-effect-free, since it may be re-applied when attempted * updates fail due to contention among threads. The function * is applied with the current value as its first argument, * and the given update as the second argument. * * @param x the update value * @param accumulatorFunction a side-effect-free function of two arguments * @return the updated value * @since 1.8 */public final int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction) &#123; int prev, next; do &#123; prev = get(); next = accumulatorFunction.applyAsInt(prev, x); &#125; while (!compareAndSet(prev, next)); return next;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"6.Merge Two Sorted Arrays","slug":"刷题/LintCode/6.Merge Two Sorted Arrays","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-18T03:49:56.664Z","comments":true,"path":"2018/12/13/刷题/LintCode/6.Merge Two Sorted Arrays/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/6.Merge Two Sorted Arrays/","excerpt":"6.Merge Two Sorted ArraysLevel : Easy","text":"6.Merge Two Sorted ArraysLevel : Easy ProblemDescriptionMerge two given sorted integer array A and B into a new sorted integer array. Example12345678910111213Example 1: Input: A=[1], B=[1] Output: [1,1] Explanation: return array merged.Example 2: Input: A=[1,2,3,4], B=[2,4,5,6] Output: [1,2,2,3,4,4,5,6] Explanation: return array merged. Thinking合并两个有序数组，只需要创建一个新的数组，将两个数组一一对比然后按照排序规则加入到新数组中，等其中一个数组中的数据全部放入到新数组以后，再将另一个数组中剩下的数据全部放心新数组即可。 Code12345678910111213141516171819202122232425262728private static int[] merge(int[] a,int[] b)&#123; long start = Calendar.getInstance().getTime().getTime(); int index = 0; //新数组下标 int aIndex = 0; //a数组下标 int bIndex = 0; //b数组下标 int[] newArray = new int[a.length+b.length]; while(aIndex &lt; a.length &amp;&amp; bIndex &lt; b.length)&#123; if(a[aIndex] &lt;= b[bIndex])&#123; newArray[index++] = a[aIndex++]; &#125;else&#123; newArray[index++] = b[bIndex++]; &#125; &#125; while(aIndex &lt; a.length)&#123; newArray[index++] = a[aIndex++]; &#125; while(bIndex &lt; b.length)&#123; newArray[index++] = b[bIndex++]; &#125; long end = Calendar.getInstance().getTime().getTime(); System.out.println(end - start); return newArray;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"9.Fizz Buzz","slug":"刷题/LintCode/9.Fizz Buzz","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-21T07:13:25.035Z","comments":true,"path":"2018/12/13/刷题/LintCode/9.Fizz Buzz/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/9.Fizz Buzz/","excerpt":"9.Fizz BuzzLevel : Easy","text":"9.Fizz BuzzLevel : Easy ProblemDescriptionGiven number n. Print number from 1 to n. But: when number is divided by 3, print “fizz”.when number is divided by 5, print “buzz”.when number is divided by both 3 and 5, print “fizz buzz”.when number can’t be divided by either 3 or 5, print the number itself. Example12345678910111213141516If n = 15, you should return:[ &quot;1&quot;, &quot;2&quot;, &quot;fizz&quot;, &quot;4&quot;, &quot;buzz&quot;, &quot;fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;fizz&quot;, &quot;buzz&quot;, &quot;11&quot;, &quot;fizz&quot;, &quot;13&quot;, &quot;14&quot;, &quot;fizz buzz&quot;]If n = 10, you should return:[ &quot;1&quot;, &quot;2&quot;, &quot;fizz&quot;, &quot;4&quot;, &quot;buzz&quot;, &quot;fizz&quot;, &quot;7&quot;, &quot;8&quot;, &quot;fizz&quot;, &quot;buzz&quot;] ChallengeCan you do it with only one if statement? ThinkingCode1234567891011121314public List&lt;String&gt; fizzBuzz(int n) &#123; // write your code here if(n&lt;0)&#123; return new ArrayList&lt;&gt;(0); &#125; List&lt;String&gt; list = new ArrayList&lt;&gt;(); int i = 1; while (i &lt;= n) &#123; list.add(i % 15 == 0 ? \"fizz buzz\" : i % 3 == 0 ? \"fizz\" : i % 5 == 0 ? \"buzz\" : i + \"\"); i++; &#125; return list;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"idea快捷键记录","slug":"idea/idea快捷键","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-09T05:50:45.382Z","comments":true,"path":"2018/12/13/idea/idea快捷键/","link":"","permalink":"www.hlblogs.com/2018/12/13/idea/idea快捷键/","excerpt":"","text":"ctrl+shift+F8 : 打开breakpoint","categories":[{"name":"开发工具","slug":"开发工具","permalink":"www.hlblogs.com/categories/开发工具/"}],"tags":[{"name":"idea","slug":"idea","permalink":"www.hlblogs.com/tags/idea/"}]},{"title":"8.Rotate String","slug":"刷题/LintCode/8.Rotate String","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-21T07:10:09.801Z","comments":true,"path":"2018/12/13/刷题/LintCode/8.Rotate String/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/8.Rotate String/","excerpt":"8.Rotate StringLevel : Easy","text":"8.Rotate StringLevel : Easy ProblemDescriptionGiven a string and an offset, rotate string by offset. (rotate from left to right) Example123456789101112131415161718192021222324252627Example 1: Input: str=&quot;abcdefg&quot;, offset = 3 Output:&quot;efgabcd&quot; Explanation: Given a string and an offset, rotate string by offset. (rotate from left to right)Example 2: Input: str=&quot;abcdefg&quot;, offset = 0 Output: &quot;abcdefg&quot; Explanation: Given a string and an offset, rotate string by offset. (rotate from left to right)Example 3: Input: str=&quot;abcdefg&quot;, offset = 1 Output: &quot;gabcdef&quot; Explanation: Given a string and an offset, rotate string by offset. (rotate from left to right)Example 4 Input: str=&quot;abcdefg&quot;, offset =2 Output:&quot;fgabcde&quot; Explanation: Given a string and an offset, rotate string by offset. (rotate from left to right) ChallengeRotate in-place with O(1) extra memory. Thinking字符串翻转1.先全部翻转，再将左边翻转，最后将右边翻转2.先将左边翻转，再将右边翻转，最后全部翻转 Code1234567891011121314151617181920212223242526272829303132333435public class RotateString &#123; public static void main(String[] args) &#123; String str = \"cppjavapy\"; rotate(str.toCharArray(),25); &#125; private static void rotate(char[] str,int offset)&#123; if(str == null || str.length == 0 )&#123; return ; &#125; offset %= str.length; rotate(str,0,str.length-1); rotate(str,0,offset-1); rotate(str,offset,str.length-1); for(char c : str)&#123; System.out.print(c); &#125; &#125; private static void rotate(char[] strs,int start,int end)&#123; for(int i=start,j=end;i&lt;j;i++,j--)&#123; char temp = strs[i]; strs[i] = strs[j]; strs[j] = temp; &#125; &#125;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"14.First Position of Target","slug":"刷题/LintCode/14. First Position of Target","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-21T07:39:10.843Z","comments":true,"path":"2018/12/13/刷题/LintCode/14. First Position of Target/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/14. First Position of Target/","excerpt":"14.First Position of TargetLevel : Easy","text":"14.First Position of TargetLevel : Easy ProblemDescriptionFor a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity. If the target number does not exist in the array, return -1. Example1234567891011121314151617181920Example 1: Input: [1,4,4,5,7,7,8,9,9,10]，1 Output: 0 Explanation: the first index of 1 is 0.Example 2: Input: [1, 2, 3, 3, 4, 5, 10]，3 Output: 2 Explanation: the first index of 3 is 2.Example 3: Input: [1, 2, 3, 3, 4, 5, 10]，6 Output: -1 Explanation: Not exist 6 in array. ChallengeIf the count of numbers is bigger than 2^32, can your code work properly? Thinking给定一个有序数组和一个目标数，找出该目标数在有序数组中第一次出现的位置因为给定的是有序数组，所以采用二分法比较合适。需要考虑的问题:1.数组中的数可能会有重复的 一旦找到和目标数相等的数，不能停下来，要继续往前推进，直至找到第一次出现的位置2.如果数组长度大于2^32该怎么处理 目前能想到的思路就是拆分数组然后再处理 Code1234567891011121314151617181920212223public int binarySearch(int[] nums, int target) &#123; // write your code here int start = 0; int end= nums.length - 1; while(start &lt;= end)&#123; int mid = (start + end) / 2; if(nums[mid] == target)&#123; while((mid = --mid) &gt;= 0 &amp;&amp; nums[mid] == target)&#123; &#125; return ++mid; &#125; if(nums[mid] &gt; target)&#123; end = mid - 1; &#125; if(nums[mid] &lt; target)&#123; start = mid+1; &#125; &#125; return -1;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"1.A+B Problem","slug":"刷题/LintCode/1.A+B Problem","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-18T03:17:45.859Z","comments":true,"path":"2018/12/13/刷题/LintCode/1.A+B Problem/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/1.A+B Problem/","excerpt":"1.A+B ProblemLevel : Easy","text":"1.A+B ProblemLevel : Easy ProblemClarificationAre a and b both 32-bit integers?Yes. Can I use bit operation?Sure you can. ExampleGiven a=1 and b=2 return 3. ChallengeOf course you can just return a + b to get accepted. But Can you challenge not do it like that?(You should not use + or any arithmetic operators.) Thinking这道题的意思是给定两个32位的整数a和b,要求返回a和b的和，当然，这道题的的意义肯定不会是直接让你返回a+b，题目中的Challenge说的很明白了。那么它的考点在哪呢？题目也给了暗示了，那就是bit operation，也就是位运算！ 这道题可以用异或运算配合与运算来处理，异或运算的特点是当两个数一样时异或运算的结果为0，两个数不一样时异或运算的结果为1。简单来说就是同为0，异为1。单纯的异或运算得到的结果会有一个问题，那就是没有办法处理进位，所以异或运算得到的值只是没有进位的值。那么如何处理进位问题呢?可以使用与运算来处理这个问题，与运算的特点是，同1为1，否则为0。即当两个数都是1的时候与运算的结果才是1，其他的情况都是0.而当两个数都是1的时候，也正是需要进位的时候，所以与运算后为1的位置，就是需要进1的位置。与运算的结果左移一位，得到的就是需要被进一位的位置。 处理思路有了，按照上面的思路，可以得到a+b的结果，但是还是会有问题，如果两个数都很大，得到的结果溢出了该怎么办呢？LintCode中的原题中给出的代码模板将返回值限定死了，我们没办法改变，但是自己私下里处理一下还是可以的。如果想要处理溢出的问题，可以使用字符串来做大整数的加法运算，这里就不细说了，代码会给出来。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Problem1 &#123; public static void main(String[] args) &#123; problem1_2(3,5); //处理溢出问题 problem1_2(2111111111,2111111111); &#125; /** * 位运算 * 异或运算: 无法处理溢出，除非将int类型转换为long类型 * @param a * @param b */ private static void problem1_1(int a,int b)&#123; while(b != 0)&#123; int aa = a^b; int bb = (a &amp; b) &lt;&lt; 1; a = aa; b = bb; &#125;// return a; System.out.println(a); &#125; /** * 处理边界溢出问题 * */ public static void problem1_2(int a,int b)&#123; String strA = a+\"\"; String strB = b+\"\"; //如果不存在溢出的可能 if(strA.length() &lt;= 9 || strB.length() &lt;= 9)&#123; problem1_1(a,b); return ; &#125; //如果存在溢出的可能 //两个数相加，只有其中一个数的长度是10，才有可能出现溢出 //如果存在溢出，就使用数组来处理 if((strA.length() == 10 &amp;&amp; strB.length() &gt;= 9) || (strA.length() &gt;= 9 &amp;&amp; strB.length() == 10))&#123; int[] arrA = new int[strA.length()]; int[] arrB = new int[strB.length()]; int[] result = new int[10]; for(int i=0;i&lt;strA.length();i++)&#123; arrA[i] = Integer.parseInt(strA.charAt(strA.length()-1-i)+\"\"); &#125; for(int i=0;i&lt;strB.length();i++)&#123; arrB[i] = Integer.parseInt(strA.charAt(strB.length()-1-i)+\"\"); &#125; for(int i=0;i&lt;result.length;i++)&#123; if(i &lt; 9)&#123; int r = arrA[i] + arrB[i]; if(r &lt; 10)&#123; result[i] = r; &#125;else&#123; result[i] = result[i]+(r-10); result[i+1] = 1; &#125; &#125;else&#123; if(arrA.length == 10)&#123; result[i] = result[i]+arrA[i]; &#125; if(arrB.length == 10)&#123; result[i] = result[i]+arrB[i]; &#125; &#125; &#125; for(int i=0;i&lt;result.length;i++)&#123; System.out.print(result[result.length-1-i]); &#125; &#125; &#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"35. Recover Rotate Sorted Array","slug":"刷题/LintCode/38.Recover Rotated Sorted Array","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-21T07:07:46.931Z","comments":true,"path":"2018/12/13/刷题/LintCode/38.Recover Rotated Sorted Array/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/38.Recover Rotated Sorted Array/","excerpt":"Recover Rotate Sorted ArrayLevel : Easy","text":"Recover Rotate Sorted ArrayLevel : Easy ProblemDescriptionGiven a rotated sorted array, recover it to sorted array in-place. ClarificationWhat is rotated array? For example, the orginal array is [1,2,3,4], The rotated array of it can be [1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]Example[4, 5, 1, 2, 3] -&gt; [1, 2, 3, 4, 5] ChallengeIn-place, O(1) extra space and O(n) time. Thinking思路类似于Problem8 Rotate String可先将左边部分翻转，再将右边部分翻转，然后再全部翻转 Code12345678910111213141516171819202122232425262728public void recoverRotatedSortedArray(List&lt;Integer&gt; nums)&#123; if(nums == null)&#123; return ; &#125; for(int i = 0;i&lt;nums.size()-1;i++)&#123; if(nums.get(i) &gt; nums.get(i+1))&#123; //翻转左边 rotate(nums,0,i); //翻转右边 rotate(nums,i+1,nums.size()-1); //全部翻转 rotate(nums,0,nums.size()-1); &#125; &#125; System.out.println(nums);&#125;public void rotate(List&lt;Integer&gt; nums,int start,int end)&#123; int i = start; int j = end; for(;i&lt;j;i++,j--)&#123; Integer temp = nums.get(i); nums.set(i,nums.get(j)); nums.set(j,temp); &#125;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"2.Trailing Zeros","slug":"刷题/LintCode/2.Trailing Zeros","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-18T03:17:45.860Z","comments":true,"path":"2018/12/13/刷题/LintCode/2.Trailing Zeros/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/2.Trailing Zeros/","excerpt":"2.Trailing ZerosLevel : Easy","text":"2.Trailing ZerosLevel : Easy ProblemDescriptionWrite an algorithm which computes the number of trailing zeros in n factorial. Example12345678910111213Example 1: Input: 11 Output: 2 Explanation: 11! = 39916800, so the output should be 2Example 2: Input: 5 Output: 1 Explanation: 5! = 120, so the output should be 1. Thinking这道题的意思是给定一个数字，求出这个数字的阶乘结果尾部的0的个数。最好是代码的时间复杂度是O(log N)。比如11的阶乘是39916800，末尾有2个0，所以结果是2。 我看到这道题的时候第一想法就是先求出这个数的阶乘，然后再计算末尾的0的个数。这样是最简单的，也最好实现，但是这种算法的时间复杂度是O(N)，这里就不对这种方法做过多的解释了。 接下来说一种复杂度更低，性能更高的方法:两数相乘，要想末尾出现0，那么这两个数需要达成以下两个条件的其中一个:121.其中一个数末尾是02.其中一个数末尾是5，另一个数是偶数 通过这两个条件，我们可以想到，只要是阶乘中能整除5的数，就一定能使得阶乘结果的末尾多一个0，比如15，它和任何偶数相乘都能使结果的末尾是0。那么如果给定一个整数n，它的阶乘结果末尾的0就是n/5。但是是这样吗？并不是！我们再来想想，当n的阶乘中有一个数是25的时候，他能带来几个0呢？很明显，是两个! 254=100,258=200….当阶乘中有一个数是50呢？ 504=200,506=300。到这里，我们可以想到，如果是5的平方的倍数，那它能带来两个0。那么如果是5的三次方的倍数呢？ 1258 = 1000,12516 = 2000…很明显，阶乘中的每一个5的三次方的倍数都能带来三个0。…. 根据上面的思路，可以看出:n的阶乘末尾的0的个数 = n/5 + n/5^2 + n/5^3 +… Code12345678public long trailingZeros(long n) &#123; long sum = 0; while (n != 0) &#123; sum += n / 5; n /= 5; &#125; return sum;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"13.Implement strStr","slug":"刷题/LintCode/13.Implement strStr","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-21T07:28:50.704Z","comments":true,"path":"2018/12/13/刷题/LintCode/13.Implement strStr/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/13.Implement strStr/","excerpt":"13.Implement strStrLevel : Easy","text":"13.Implement strStrLevel : Easy ProblemDescriptionFor a given source string and a target string, you should output the first index(from 0) of target string in source string. If target does not exist in source, just return -1. ClarificationDo I need to implement KMP Algorithm in a real interview? Not necessary. When you meet this problem in a real interview, the interviewer may just want to test your basic implementation ability. But make sure you confirm with the interviewer first. Example12345678910111213Example 1: Input: source = &quot;source&quot; ，target = &quot;target&quot; Output: -1 Explanation: If the source does not contain the target content, return - 1.Example 2: Input:source = &quot;abcdabcdefg&quot; ，target = &quot;bcd&quot; Output: 1 Explanation: If the source contains the target content, return the location where the target first appeared in the source. ChallengeO(n2) is acceptable. Can you implement an O(n) algorithm? (hint: KMP) Thinking查询模式串在主串中首次出现的位置BF算法RK算法KMP算法。。。根据题目,这里使用KMP算法 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public int strStr(String source, String target) &#123; if(source==null || target == null)&#123; return -1; &#125; if(\"\".equals(source) &amp;&amp; \"\".equals(target))&#123; return 0; &#125; if(\"\".equals(source) &amp;&amp; !\"\".equals(target))&#123; return -1; &#125; if(!\"\".equals(source) &amp;&amp; \"\".equals(target))&#123; return 0; &#125; int i = 0; int j = 0; int[] next = new int[target.length()]; next(target, next); while(i &lt; source.length() &amp;&amp; j &lt; target.length())&#123; if(j == -1 || source.charAt(i) == target.charAt(j))&#123; i++; j++; &#125;else&#123; j = next[j]; &#125; if(j == target.length())&#123; return i - j; &#125; &#125; return -1;&#125;public void next(String target, int[] next) &#123; int i = 0; //前缀位置 int j = -1; //后缀位置 next[0] = -1; while(i &lt; next.length-1)&#123; if(j == -1 || target.charAt(i) == target.charAt(j))&#123; i++; j++; next[i] = j; &#125;else&#123; j = next[j]; &#125; &#125;&#125;","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"6.Flatten List","slug":"刷题/LintCode/22.Flatten List","date":"2018-12-12T16:00:00.000Z","updated":"2019-01-18T03:48:09.379Z","comments":true,"path":"2018/12/13/刷题/LintCode/22.Flatten List/","link":"","permalink":"www.hlblogs.com/2018/12/13/刷题/LintCode/22.Flatten List/","excerpt":"6.Flatten ListLevel : Easy","text":"6.Flatten ListLevel : Easy ProblemDescriptionGiven a list, each element in the list can be a list or integer. flatten it into a simply list with integers. Example1234567891011121314151617181920Example 1: Input: [[1,1],2,[1,1]] Output: [1,1,2,1,1] Explanation: flatten it into a simply list with integers.Example 2: Input: [1,2,[1,2]] Output:[1,2,1,2] Explanation: flatten it into a simply list with integers.Example 3: Input: [4,[3,[2,[1]]]] Output:[4,3,2,1] Explanation: flatten it into a simply list with integers. ChallengeDo it in non-recursive. Thinking比较简单，看代码。 Code1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; // @param nestedList a list of NestedInteger // @return a list of integer public List&lt;Integer&gt; flatten(List&lt;NestedInteger&gt; nestedList) &#123; // Write your code here if(nestedList == null)&#123; return null; &#125; boolean hasList = true; while(hasList)&#123; List&lt;NestedInteger&gt; nestedIntegerList = new ArrayList&lt;&gt;(); hasList = false; for(NestedInteger nestedInteger : nestedList)&#123; if(nestedInteger.isInteger())&#123; nestedIntegerList.add(nestedInteger); &#125;else&#123; nestedIntegerList.addAll(nestedInteger.getList()); hasList = true; &#125; &#125; nestedList = nestedIntegerList; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(NestedInteger nestedInteger : nestedList)&#123; list.add(nestedInteger.getInteger()); &#125; return list; &#125;&#125; 此方法用时3109 ms 优化:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * // This is the interface that allows for creating nested lists. * // You should not implement it, or speculate about its implementation * public interface NestedInteger &#123; * * // @return true if this NestedInteger holds a single integer, * // rather than a nested list. * public boolean isInteger(); * * // @return the single integer that this NestedInteger holds, * // if it holds a single integer * // Return null if this NestedInteger holds a nested list * public Integer getInteger(); * * // @return the nested list that this NestedInteger holds, * // if it holds a nested list * // Return null if this NestedInteger holds a single integer * public List&lt;NestedInteger&gt; getList(); * &#125; */public class Solution &#123; // @param nestedList a list of NestedInteger // @return a list of integer public List&lt;Integer&gt; flatten(List&lt;NestedInteger&gt; nestedList) &#123; // Write your code here if(nestedList == null)&#123; return null; &#125; if(nestedList.size() == 0)&#123; return new ArrayList&lt;&gt;(0); &#125; boolean hasList = true; while(hasList)&#123; hasList = false; for(int i=0;i&lt;nestedList.size();i++)&#123; // NestedInteger nestedInteger = nestedList.get(i); if(!nestedList.get(i).isInteger())&#123; nestedList.addAll(i+1,nestedList.get(i).getList()); nestedList.remove(i); hasList = true; &#125; &#125; // nestedList = nestedIntegerList; &#125; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for(NestedInteger nestedInteger : nestedList)&#123; list.add(nestedInteger.getInteger()); &#125; return list; &#125;&#125; 优化后用时2823ms","categories":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/categories/LintCode/"}],"tags":[{"name":"LintCode","slug":"LintCode","permalink":"www.hlblogs.com/tags/LintCode/"}]},{"title":"担保支付1.0业务理解","slug":"业务/支付相关","date":"2018-12-09T16:00:00.000Z","updated":"2018-12-18T07:53:06.056Z","comments":true,"path":"2018/12/10/业务/支付相关/","link":"","permalink":"www.hlblogs.com/2018/12/10/业务/支付相关/","excerpt":"线上直付、担保支付、委受托支付、穿透支付、归集支付","text":"线上直付、担保支付、委受托支付、穿透支付、归集支付 支付线上直付A(付款方) to B(收款方)A可用 to B可用A：add flowupdate wallet,reduce money availableadd paymentsend messageupdate Order/Contract GroupB：add flowupdate wallet,add money availableadd paymentsend messageupdate Order/Contract Group 担保支付担保支付即买方将货款付给买卖双方之外的第三方，第三方收到款项后通知已收到买方货款，并同时通知卖方发货，卖方即可将货物发运给买方，买方通知第三方收到满意的卖方货物，第三方便将货款付给卖方。目前在电子商务领域应用广泛。 A(付款方) to B(收款方)A可用 to A冻结 (解冻？？)add flowupdate wallet,A available to A freezeadd paymentsend messageupdate Order/Contract Group 委受托支付委受托支付 是专款专用的，冻结资金只能在订单内进行支付,例如A、B、C1、 C2签订了买卖合同，B只能用A付给B的钱去支付给C。A B C之间的关系可参考 如皋-康迪-供应商 委托支付A(付款方) to B(收款方)A可用 to B冻结A：add flowupdate wallet,reduce A available moneyadd paymentsend messageupdate Order/Contract Group B：add flowupdate wallet,add B freeze moneyadd paymentsend messageupdate Order/Contract Group 受托支付B(付款方) to C(收款方)依赖于委托支付，受托支付中B给C付款只能使用委托支付中A付给B的款两个金额: A付给B的金额 B已使用的金额B冻结 to C冻结B：add flowupdate wallet,reduce B freeze moneyadd paymentsend messageupdate Order/Contract Group C：add flowupdate wallet,add C freeze moneyadd paymentsend messageupdate Order/Contract Group 穿透支付A(付款方) to B(收款方) -&gt; B(付款方，资金来源于A) to C(收款方)A和B需要合同 B和C也许要有合同 形成一个合同组A可用 to B冻结 (类似于2.0里面的担保支付)B冻结 to C冻结A to B -&gt; A：add flowupdate wallet,reduce A available moneyadd paymentsend messageupdate Order/Contract Group A to B -&gt; B：add flowupdate wallet,add B freeze moneyadd paymentsend messageupdate Order/Contract Group B to C -&gt; B：add flowupdate wallet,add reduce freeze moneyadd paymentsend messageupdate Order/Contract Group B to C -&gt; C：add flowupdate wallet,add add freeze moneyadd paymentsend messageupdate Order/Contract Group 归集支付资金归集资金归集是指将集团公司中所有下属公司指定账户上的资金归集到总公司指定的账户的服务，也称资金清扫。2013年1月初，某股份制商业银行推出一项新业务——可以给老公的银行卡设个存款上限，比如1000元，从此老公卡上的资金只要超过1000元，超过的部分就一分不留地自动划到老婆的银行卡上，不仅不需要每月转账，而且免费转。 解冻申请解冻线上直付 : 可用到可用，不需要解冻 担保支付 : 付款时A可用到A冻结 ，解冻时A冻结到B可用 委托支付 : 付款时A可用到B冻结 ，解冻时B冻结到B可用 受托支付 : 付款时B冻结到C冻结 ，解冻时C冻结到C可用 穿透支付 : A付款时A可用到B冻结，然后B付款时B冻结到C冻结，解冻时C冻结到C可用 确认解冻担保支付 : A冻结到B可用 委托支付 : B冻结到B可用 受托支付 : C冻结到C可用 穿透支付 : B冻结到B可用，C冻结到C可用","categories":[{"name":"业务","slug":"业务","permalink":"www.hlblogs.com/categories/业务/"}],"tags":[{"name":"业务","slug":"业务","permalink":"www.hlblogs.com/tags/业务/"}]},{"title":"索引入门","slug":"mysql/索引","date":"2018-12-07T16:00:00.000Z","updated":"2019-01-14T09:06:41.850Z","comments":true,"path":"2018/12/08/mysql/索引/","link":"","permalink":"www.hlblogs.com/2018/12/08/mysql/索引/","excerpt":"","text":"索引简介在数据本身以外，mysql还维护着一个满足特定查找算法的数据结构，这种数据结构中的数据以某种方式指向数据库中的用户数据，这样就可以在这种数据结构的基础上实现高效的查找算法，这种数据结构就是索引。索引就是一种可以帮助mysql高效查询数据的数据结构，可以简单理解为已经排好序的快速查找数据结构。 由于内存中的数据重启计算机以后就会丢失，并且在很多情况下索引的大小甚至要比数据本身还要大，不大可能全部保存在内存中，因此索引一般以索引文件的形式保存在磁盘上。 优势和劣势优势1.IO成本: 索引能够提高查询效率，降低了数据库的IO成本2.CPU成本: 通过索引对数据进行排序，能够降低数据排序的成本，降低了CPU的消耗。 劣势1.空间成本: 索引本身也会占据一定的空间，甚至它所占的空间可能比数据本身还要大2.维护成本: 索引并不是一次创建永久有效的，对相关数据的每一次修改都要同时修改对应的索引，如果是频繁修改的数据，那么索引的维护成本也会非常之高。 索引分类按功能单值索引复合索引唯一索引聚簇索引覆盖索引 按结构BTREE索引RTREE索引hash索引full-text全文索引 适用场合与非适用场合适用场合1.数据库会自动为每张表的主键建立唯一索引2.如果是频繁作为查询条件的字段，应该建立索引3.查询中与其他表关连的字段应该建立索引4.查询中排序的字段应该建立索引，可以大大增加排序速度5.查询中统计或者分组字段 非适用场合1.频繁更新的字段不适合建立索引2.频繁增删改的表不适合建立索引3.查询中用不到的字段不适合建立索引4.表记录太少的情况下没必要建立索引 基本语法 索引优化 最佳左前缀法则: 如果索引了多列,要遵守最佳左前缀法则,指的是查询从索引的最左前列开始并且不跳过索引中的列.查询时所用字段尽量与索引中的字段进行全值匹配 不在索引列上做任何操作,如计算,函数,类型转换(自动/手动),会导致索引失效而转向全表扫描 存储引擎不能使用范围条件右边的列,范围以后索引全失效 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select*的使用 mysql在使用不等于 != / &lt;&gt; 的时候无法使用索引会导致全表扫描 is null , is not null也无法使用索引 like以通配符开头会导致索引失效导致全表扫描 varchar类型(字符串类型)不加单引号会导致索引失效 使用or连接时会导致索引失效 优化器会在索引存在的情况下，通过符合 RANGE 范围的条数和总数的比例来选择是使用索引还是进行全表遍历当需要读取的数据超过一个临界值时，优化器会放弃从索引中读取而改为进行全表扫描","categories":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/tags/mysql/"}]},{"title":"一些简单的sql优化手段","slug":"mysql/一些简单的sql优化手段","date":"2018-12-07T16:00:00.000Z","updated":"2019-01-15T01:27:17.722Z","comments":true,"path":"2018/12/08/mysql/一些简单的sql优化手段/","link":"","permalink":"www.hlblogs.com/2018/12/08/mysql/一些简单的sql优化手段/","excerpt":"","text":"执行计划简介使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的，分析你的查询语句或者是表结构的性能瓶颈。 通过执行计划可以得出以下信息: 表的读取顺序 数据读取操作的操作类型 哪些索引可以使用 哪些索引被实际使用 表之间的引用 每张表有多少行被优化器查询 使用方式:explain+sql语句 explain所包含的信息主要有id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra等等。 详情idid是selec查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序。id一般有三种情况:id相同: 执行顺序由上至下id不同: 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行id相同和不同同时存在: id相同的可以认为是一组，一组之中按顺序从上往下执行，在所有的组中，id越大的优先级越高，越先被执行。 select_type查询的类型，主要用于区别普通查询、联合查询、子查询等复杂查询。 SIMPLE 简单的select查询，不包含子查询或者union PRIMARY 查询中如果包含任意的子查询部分，则最外层被标记为PRIMARY SUBQUERY 在select或者WHERE列表中包含了子查询 DERIVED 在from列表中中包含的子查询会被标记为DERIVED，mysql会递归的执行这些子查询，把结果放在临时表里。 UNION 如果第二个select出现在union之后，则会被标记为union,如果union包含在from子句的子查询中，外层被标记为DERIVED。 UNION RESULT 从union表获取结果的select table显示这一行数据是关于哪张表的 type访问类型排列，可以反映查询语句的性能从最好到最差的完整指标:system &gt; const &gt; eq_ref &gt; ref &gt; fulltest &gt; ref_or_null &gt; index_merge &gt; unique_query &gt; index_subquery &gt; range &gt; index &gt; all 比较常见的:system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all一般来说，查询语句最好能保持在range以上。 possible_keys表示可能应用在这张表中的一个或多个索引，查询设计到的字段如果存在索引，则此索引将被列出，但是不一定会被实际使用 key实际使用的索引，如果该字段为NULL,则没有使用索引，查询中如果使用了覆盖索引，则该索引和查询的select字段重叠。 key_len表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。key_len显示的值是索引字段最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。 ref显示索引的哪一列被使用了，如果可能的话，是一个常数 rows根据表的统计信息及索引的选用情况，大致估算出找到所需的记录所需要读取的行数。 Extra包含不适合在其他列中显示但十分重要的额外信息 Using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，MYSQL中无法使用索引完成的排序成为”文件排序”。 Using temporary使用了临时表保存中间结果，mysql在对查询结果排序时使用了临时表，常见于排序order by和分组group by. Using index表示相应的select语句中使用了覆盖索引，避免了访问的表的数据行，效率不错。如果同时出现using where,表明索引被用来执行索引键值的查找,虽然用到了索引，但是没有索引覆盖，产生了回表。如果没有同时出现using where，表明索引用来执行读取数据而非执行查找动作。 Using where表明使用了where过滤。有一种情况，就是说使用了覆盖索引，但是还有额外的where条件，最后虽然使用了索引，但是extra却不显示using index using index conditionICP的目的是减少全行读取的次数，从而减少IO操作查询的列不全在索引中，还需要进行额外的字段过滤 NULL意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引，Extra中为NULL using where;using index &amp;&amp; using index condition &amp;&amp; NULLNULL : 索引用到了，但是部分字段没有被索引覆盖，同时，where条件中没有额外的需要回表的条件(比如范围判断)using where;using index : 索引用到了，字段被索引覆盖了，where条件有需要回表的条件(比如范围判断)using index condition : 索引用到了，但是部分字段没有被索引覆盖，同时，where条件中有会产生回表的条件(比如范围判断)，或者是有没有建立索引的字段 Using join buffer使用了连接缓存 impossible wherewhere子句的值总是false，不能用来查询任何元素。 select tables optimized away在没有group by的情况下，基于索引优化MIN/MAX操作或者对于MYISAM引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 distinct优化distinct操作，在找到匹配的第一行元素以后停止继续寻找同样值的动作。 order by和group by优化order by优化Mysql支持两种排序方式,Index和FileSort. Index方式 :Index方式效率比较高,它是指MySql扫描索引本身完成排序以下两种情况会使用Index排序方式:1.OrderBy子句使用索引最佳左前列2.使用Where子句与OrderBy子句条件列组合满足索引最左前列 FileSort方式:如果不在索引列上排序,就会使用FiIeSort方式FileSort方式有两种排序算法,双路排序和单路排序1.双路排序: 从磁盘读取排序字段,在buffer中排序,再根据排序结果从磁盘中读取其他字段.取一批字段要对磁盘进行两次扫描.2.单路排序: IO是很耗时的,所以Mysql4.1以后出现了另一种算法,单路排序算法,这种算法回一次将所有的列都读出来,在buffer中对它们进行排序,这样避免了二次IO,并且把随机IO变成了顺序IO,所以它的效率更快.但是它更加的浪费空间,因为它把所有的数据都放在了buffer中.单路排序的弊端 : 用来排序的buffer是有限的,如果需要取出的数据量大于buffer,就会导致每次只能查出buffer大小的数据量,这样就可能造成多次IO,得不偿失解决思路:1.增大sort_buffer_size参数2.增大max_length_for_sort_data参数 group by优化GroupBy子句的实质是先排序后分组,遵循索引键的最佳左前缀增大sort_buffer_size参数和max_length_for_sort_data参数Where高于Having,能写在Where限定的条件,就不要去having限定了 in和exists多表联查时,永远是小表驱动大表,即小的数据集驱动大的数据集 Select * from A where id in (select id from B)当B的数据集必须小于A的数据集时,使用in优于exists Select * from A where exists (select 1 from B where B.id = A.id)此处注意:A表与B表相关联的字段应该建立索引 Exists(subquery)select * from table Where Exists(subquery)该语法可以理解为: 将主查询到数据放到子查询中去做条件验证,根据验证结果(true/false)来决定主查询得到的数据结果是否得以保留 提示:Exists(subquery)只返回true/false,因此 子查询 中可以是select* 也可以使select 1 或者select ‘X’,官方的说法是实际执行时会忽略select清单,因此没有区别 慢查询日志和SHOW PROFILE什么是慢查询日志","categories":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/tags/mysql/"}]},{"title":"事务的隔离级别","slug":"mysql/事务的隔离级别","date":"2018-12-06T16:00:00.000Z","updated":"2018-12-26T01:49:25.004Z","comments":true,"path":"2018/12/07/mysql/事务的隔离级别/","link":"","permalink":"www.hlblogs.com/2018/12/07/mysql/事务的隔离级别/","excerpt":"SQL标准的隔离级别总共有四个: 读未提交，读已提交，可重复读，串行化读。如果隔离级别使用不当，在多个事务并发执行的时候就可能会遇到脏读、幻读、不可重复读等问题。","text":"SQL标准的隔离级别总共有四个: 读未提交，读已提交，可重复读，串行化读。如果隔离级别使用不当，在多个事务并发执行的时候就可能会遇到脏读、幻读、不可重复读等问题。 脏读脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个未提交的数据。 幻读第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。 不可重复读是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。 读未提交读未提交级别下，事务还未提交，它做的更新就能被别的事务看到。读未提交可能会产生脏读、幻读、不可重复读问题。 读已提交读已提交级别下，事务提交之后，它做的更新才能被别的事务看到。读已提交解决了脏读的问题，但是还是有可能出现幻读和不可重复读的问题。 可重复读可重复读级别下，一个事务执行过程中看到的数据，始终与事务开始时看到的数据一致，即使有其他事务对这条数据做了修改也没有影响。同时，事务在可重复读级别下做的更新也必须等到提交以后才能被其他事务看到，这点和读已提交是一样的。可重复读解决了不可重复读的问题，但是还是有可能出现幻读。 串行化对于同一条记录，写操作会加‘写锁’，读操作会加‘读锁’，当遇到读写冲突的时候，后面的事务必须等到前面的事务完成以后才能继续进行。串行化解决幻读问题，这是目前最高的隔离级别，彻底解决了脏读、幻读、不可重复读的问题，但是它的吞吐量也是最低的。","categories":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/tags/mysql/"}]},{"title":"LockSupport","slug":"源码阅读/java/juc/锁/LockSupport","date":"2018-12-06T16:00:00.000Z","updated":"2018-12-26T07:48:39.342Z","comments":true,"path":"2018/12/07/源码阅读/java/juc/锁/LockSupport/","link":"","permalink":"www.hlblogs.com/2018/12/07/源码阅读/java/juc/锁/LockSupport/","excerpt":"","text":"","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"Condition源码理解","slug":"源码阅读/java/juc/AQS/Condition源码理解","date":"2018-12-06T16:00:00.000Z","updated":"2018-12-26T09:28:15.967Z","comments":true,"path":"2018/12/07/源码阅读/java/juc/AQS/Condition源码理解/","link":"","permalink":"www.hlblogs.com/2018/12/07/源码阅读/java/juc/AQS/Condition源码理解/","excerpt":"在AQS简介这一章里讲到过AQS中有两个队列，一个是CLH队列，一个是Condition条件等待队列。CLH队列已经在前面做过分析，今天通过这篇文章来分析一下条件等待队列及其与CLH队列的关系。","text":"在AQS简介这一章里讲到过AQS中有两个队列，一个是CLH队列，一个是Condition条件等待队列。CLH队列已经在前面做过分析，今天通过这篇文章来分析一下条件等待队列及其与CLH队列的关系。 Condition接口1234567891011121314151617181920212223public interface Condition &#123; //使当前线程进入等待状态直到它被唤醒或者被中断 void await() throws InterruptedException; //使当前线程进入等待状态直到它被唤醒，不响应中断 void awaitUninterruptibly(); ////使当前线程进入等待状态，指定时间后自动退出等待状态 long awaitNanos(long nanosTimeout) throws InterruptedException; //使当前线程进入等待状态，指定时间后自动退出等待状态，返回值为是否已经超过等待时间 boolean await(long time, TimeUnit unit) throws InterruptedException; //使当前线程进入等待状态直到某个时间点，返回值为是否已经吵过指定的时间点 boolean awaitUntil(Date deadline) throws InterruptedException; //唤醒一个线程 void signal(); //唤醒等待中的全部线程 void signalAll();&#125; ConditionObjectawait123456789101112131415161718192021222324252627public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); //将当前线程封装为新的节点，加入到等待队列以后返回这个节点。 Node node = addConditionWaiter(); //将当前节点持有的同步状态全部释放 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //这里会阻塞线程，当它被通知唤醒或者当前线程被中断以后， //阻塞的线程就会恢复继续往下执行 LockSupport.park(this); //checkInterruptWhileWaiting方法: 检查线程中断状态，用来响应中断 //如果在取消等待之前已经被中断了，就抛出异常，如果在取消等待以后被中断了，就从新设置中断状态 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //节点独占式获取同步状态，获取成功才会退出此方法 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) //清除条件等待队列中的已取消等待(状态不为Condition)的节点 unlinkCancelledWaiters(); if (interruptMode != 0) //被唤醒以后处理中断状态 reportInterruptAfterWait(interruptMode);&#125; 将线程封装成新节点加入到条件等待队列123456789101112131415161718192021private Node addConditionWaiter() &#123; Node t = lastWaiter; // 如果等待队列中的最后一个节点已经取消了，就将它清除出去 if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; //将当前线程封装成一个新的节点 Node node = new Node(Thread.currentThread(), Node.CONDITION); //*********个人认为这个if else里的操作应该是线程不安全的，暂时没明白这里是怎么规避这个问题的 //明白了: Condition一般都是配合独占锁进行使用，创建Condition实例只能使用AQS实现类所实现的newCondition方法来创建 //在整个jdk1.8中，Condition几乎都是配合ReentrentLock一起使用的。 //在执行这个方法的时候一定是已经持有了独占锁的，所以这里就不存在线程安全问题了。 if (t == null) firstWaiter = node; else //注意这里设置的是nextWaiter，而不是CLH队列中才会用到的next t.nextWaiter = node; lastWaiter = node; return node;&#125; 判断节点是否在CLH队列中1234567891011121314151617181920212223final boolean isOnSyncQueue(Node node) &#123; //CLH队列中的节点，waitStatus绝不可能是Node.CONDITION， //如果node.prev == null,这个节点肯定不会在CLH队列中，因为这个时候它没有获取同步状态，所以就不可能是头结点 //在CLH队列中，如果不是头结点，那么node.prev不可能为null if (node.waitStatus == Node.CONDITION || node.prev == null) return false; if (node.next != null) return true; return findNodeFromTail(node);&#125;//从CLH队列的尾节点开始，倒叙遍历整个CLH队列，寻找当前节点。private boolean findNodeFromTail(Node node) &#123; Node t = tail; for (;;) &#123; if (t == node) return true; if (t == null) return false; t = t.prev; &#125;&#125; 1234567891011121314151617181920212223//返回一个interruptMode，这个interruptMode有三种情况//THROW_IE : 线程被中断了并且是在signal之前被中断的//REINTERRUPT : 线程被中断并且是在signal之后被中断的//0: 未中断private int checkInterruptWhileWaiting(Node node) &#123; return Thread.interrupted() ? (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) : 0;&#125;//如果节点在是在signal之前被中断的，返回truefinal boolean transferAfterCancelledWait(Node node) &#123; //如果此时当前节点的等待状态还是Node.Condition，说明当前节点是signal之前被中断的 if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123; enq(node); return true; &#125; //上面的CAS失败了才会到这里，到这里就说明当前的节点是在signal之后被中断的。 while (!isOnSyncQueue(node)) Thread.yield(); return false;&#125; 清除条件等待队列中状态不为Condition的节点12345678910111213141516171819private void unlinkCancelledWaiters() &#123; Node t = firstWaiter; Node trail = null; while (t != null) &#123; Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) &#123; t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; &#125; else trail = t; t = next; &#125;&#125; 处理中断状态1234567private void reportInterruptAfterWait(int interruptMode) throws InterruptedException &#123; if (interruptMode == THROW_IE) throw new InterruptedException(); else if (interruptMode == REINTERRUPT) selfInterrupt();&#125; signal1234567891011121314151617181920212223242526272829303132333435public final void signal() &#123; //判断当前线程是否持有独占锁，只有持有独占锁的线程才能执行通知操作。 if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125;//从头往后遍历找到第一个需要转移到CLH队列的节点，将它转移到CLH队列的尾端private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125;final boolean transferForSignal(Node node) &#123; //如果CAS失败了，说明该节点已经取消了等待 if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; //自旋进入阻塞队列的队尾 Node p = enq(node); int ws = p.waitStatus; //ws &gt; 0,说明该节点已经被取消了 //CAS失败说明ws在此期间被修改了 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; AQS中的ConditionObject对这个接口进行了实现，为AQS提供了条件等待队列。 await方法：1.生成新节点并添加到条件队列中2.释放线程所持有的全部锁，包括重入锁3.自旋等待进入阻塞队列，检测自己在不在阻塞队列中，如果不在，就阻塞等待被唤醒后进入阻塞队列4.被唤醒后进入阻塞队列5.获取独占锁6.清除条件等待队列中状态不为Condition的节点7.处理中断状态 signal方法：1.判断当前线程是否持有锁，没有的话抛出异常2.从头往后遍历找到第一个需要转移到CLH队列的节点，将它转移到CLH队列的尾端","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"秒杀系统设计专题","slug":"专题/秒杀系统设计专题","date":"2018-12-06T16:00:00.000Z","updated":"2018-12-07T05:43:37.158Z","comments":true,"path":"2018/12/07/专题/秒杀系统设计专题/","link":"","permalink":"www.hlblogs.com/2018/12/07/专题/秒杀系统设计专题/","excerpt":"秒杀系统设计专题","text":"秒杀系统设计专题 五大原则四要一不要:1.数据要尽量少2.请求要尽量少3.路径要尽量短4.依赖要尽量少5.不要有单点 动静分离热点数据流量削峰性能提升库存扣减兜底方案","categories":[{"name":"专题","slug":"专题","permalink":"www.hlblogs.com/categories/专题/"}],"tags":[{"name":"专题","slug":"专题","permalink":"www.hlblogs.com/tags/专题/"}]},{"title":"sql执行流程","slug":"mysql/sql执行流程","date":"2018-12-03T16:00:00.000Z","updated":"2019-01-10T03:41:33.696Z","comments":true,"path":"2018/12/04/mysql/sql执行流程/","link":"","permalink":"www.hlblogs.com/2018/12/04/mysql/sql执行流程/","excerpt":"sql的执行流程","text":"sql的执行流程 mysql结构简介mysql大致可分为Server层和存储引擎层两部分。server层大概包括连接器,查询缓存,分析器,优化器,执行器等，涵盖MYSQL大多数的核心功能以及所有的内置函数，所有的跨存储引擎功能都在这一层实现，如存储过程，触发器，视图等等。 而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB,MyISAM等多个存储引擎。默认的存储引擎是InnoDB。 查询sql的执行流程一条查询sql的执行流程大概需要经过mysql的以下几个流程: 连接器 -&gt; 查询缓存 -&gt; 分析器 -&gt; 优化器 -&gt; 执行器(调用存储引擎接口) 连接器主要功能: 建立连接、获取权限、维持连接、管理连接。流程: 请求建立连接(TCP握手) -&gt; 输入密码 -&gt; 认证 -&gt; 获取权限 -&gt;建立连接:建立连接的命令:1mysql -h$ip -P$port -u$user -p 获取权限:如果用户名和密码认证通过，连接器会到权限表中读出当前用户的权限，在此连接内的权限判断都依赖此时读出的结果。 维持/管理连接:连接建立，经过使用以后如果没有后续操作这个连接会进入空闲状态，使用show processlist可以查出空闲状态的连接列表，如果超过了指定的时间还是没有任何操作，连接器就会断开这个连接,这里的时间由wait_timeout指定,默认8小时。 长连接和短连接:在数据库中，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个,但是建立连接是非常复杂的，所以不建议使用短连接。长连接过度使用会占用大量的内存,因为在mysql执行过程中使用的临时内存时在连接中管理的这部分内存在断开连接以后才会释放，如果连接不释放，这部分内存就会一直被占据。解决方案:1.隔一段时间或执行完一个比较复杂的操作以后就断开一次连接，将占用的内存释放掉，之后要使用的时候再重新建立连接。2.mysql5.7以上版本可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个操作会将连接恢复到刚刚建立的状态。 查询缓存查询缓存功能在mysql8.0以后被彻底删除了，因为使用这个功能是弊大于利的。查询缓存的失效非常的频繁，只要有一个对表的更新操作，这个表上的所有缓存都会被删除。查询缓存如果启用了的话，它会将执行过的语句及其结果以Key-Value的形式保存在内存中。 分析器1.词法分析2.语法分析 优化器优化器在表有多个索引的时候决定使用哪个索引，或者一个语句有多表关联的时候决定join的顺序。 执行器MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。无索引: 全表扫描 第一行-&gt;下一行有索引: 非全表扫描 满足条件的第一行-&gt;满足条件的下一行 更新sql的执行流程一条查询sql的执行流程大概需要经过mysql的以下几个流程: 连接器 -&gt; 查询缓存 -&gt; 分析器 -&gt; 优化器 -&gt; 执行器(调用存储引擎接口) 同样的，一条更新的sql语句也会经过这些步骤，不同的是在查询sql执行时，如果在缓存中能找到缓存的数据，就可以直接返回了。而在更新的sql中，会将被更新表的缓存全部清除掉。同时，更新sql涉及到两个比较重要的日志的更新，即redo log和binlog。关于这两个日志，打算重开一篇来记录。 1.首先客户端通过tcp/ip发送一条sql语句到server层的SQL interface2.SQL interface接到该请求后，先对该条语句进行解析，验证权限是否匹配3.验证通过以后，分析器会对该语句分析,是否语法有错误等4.接下来是优化器器生成相应的执行计划，选择最优的执行计划5.之后会是执行器根据执行计划执行这条语句。在这一步会去open table,如果该table上有MDL，则等待。如果没有，则加在该表上加短暂的MDL(S)(如果opend_table太大,表明open_table_cache太小。需要不停的去打开frm文件)6.进入到引擎层，首先会去innodb_buffer_pool里的data dictionary(元数据信息)得到表信息7.通过元数据信息,去lock info里查出是否会有相关的锁信息，并把这条update语句需要的锁信息写入到lock info里(锁这里还有待补充)8.然后涉及到的老数据通过快照的方式存储到innodb_buffer_pool里的undo page里,并且记录undolog修改的redo(如果data page里有就直接载入到undo page里，如果没有，则需要去磁盘里取出相应page的数据，载入到undo page里)9.在innodb_buffer_pool的data page做update操作。并把操作的物理数据页修改记录到redo logbuffer里由于update这个事务会涉及到多个页面的修改，所以redo log buffer里会记录多条页面的修改信息。因为group commit的原因，这次事务所产生的redo log buffer可能会跟随其它事务一同flush并且sync到磁盘上10.同时修改的信息，会按照event的格式,记录到binlog_cache中。(这里注意binlog_cache_size是transaction级别的,不是session级别的参数,一旦commit之后，dump线程会从binlog_cache里把event主动发送给slave的I/O线程)11.之后把这条sql,需要在二级索引上做的修改，写入到change buffer page，等到下次有其他sql需要读取该二级索引时，再去与二级索引做merge(随机I/O变为顺序I/O,但是由于现在的磁盘都是SSD,所以对于寻址来说,随机I/O和顺序I/O差距不大)12.此时update语句已经完成，需要commit或者rollback。这里讨论commit的情况，并且双113.commit操作，由于存储引擎层与server层之间采用的是内部XA(保证两个事务的一致性,这里主要保证redo log和binlog的原子性),所以提交分为prepare阶段与commit阶段14.prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗时)15.commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记commit16.当binlog和redo log都已经落盘以后，如果触发了刷新脏页的操作，先把该脏页复制到doublewritebuffer里，把doublewrite buffer里的刷新到共享表空间，然后才是通过page cleaner线程把脏页写入到磁盘中老师，你看我的步骤中有什么问题嘛？我感觉第6步那里有点问题,因为第5步已经去open table了，第6步还有没有必要去buffer里查找元数据呢?这元数据是表示的系统的元数据嘛,还是所有表的？谢谢老师指正","categories":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/tags/mysql/"}]},{"title":"redolog和binlog","slug":"mysql/redolog和binlog","date":"2018-12-03T16:00:00.000Z","updated":"2019-01-10T03:38:24.045Z","comments":true,"path":"2018/12/04/mysql/redolog和binlog/","link":"","permalink":"www.hlblogs.com/2018/12/04/mysql/redolog和binlog/","excerpt":"参考资料维基百科https://dev.mysql.com/doc/refman/5.5/en/innodb-redo-log.htmlhttps://dev.mysql.com/doc/refman/5.5/en/innodb-undo-logs.html","text":"参考资料维基百科https://dev.mysql.com/doc/refman/5.5/en/innodb-redo-log.htmlhttps://dev.mysql.com/doc/refman/5.5/en/innodb-undo-logs.html 其中redolog是InnoDB特有的日志，只有InnoDB引擎可以使用，而binlog是mysql的server层提供的日志，它是可以被所有的引擎使用的。 WAL简介WAL(预写式日志)全称Write-ahead logging,是关系数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术。在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中。log文件中通常包括redo和undo信息。这样做的目的可以通过一个例子来说明。假设一个程序在执行某些操作的过程中机器断电了。在重新启动时，程序可能需要知道当时执行的操作是成功了还是部分成功或者是失败了。如果使用了WAL，程序就可以检查log文件，并对突然掉电时计划执行的操作内容跟实际上执行的操作内容进行比较。在这个比较的基础上，程序就可以决定是撤销已做的操作还是继续完成已做的操作，或者是保持原样。 —–摘自维基百科 通过维基百科中对WAL的描述，我们已经能够对WAL有个基本的认识,WAL能够通过两种日志文件来保证意外发生时数据库中数据的准确性。 undolog和redologundolog保存的修改之前的数据，redolog保存的是修改之后的数据。这两个日志可以看做是相反的，比如说如果redolog中记录了一条delete日志，那么undoLog就会对应的记录一条insert日志。 redologredolog(重做日志)是一种基于磁盘的数据结构，作用是用来在崩溃恢复期间纠正由未完成的事务写入的数据。在正常操作期间，redolog会记录由sql或者是低级api调用产生的表数据的更改，如果由于断电或者其他意外情况导致mysql崩溃，那么mysql在重启之后，可以借助redolog在初始化期间，客户端与mysql服务器建立连接之前,对崩溃之前未能更新到数据文件的修改进行更新。 默认情况下,redolog有两个文件ib_logfile0和ib_logfile1，文件个数可以通过参数innodb_log_files_in_group来调整。redolog的文件是循环写入的，从0号文件开始写，写到最后一个文件的末尾处，会再次回到0号文件的开头开始写。这里要顺带提出两个概念: checkpoint和writeposition。checkpoint代表的是上一次将数据持久化到磁盘的位置，持久化以后会把这部分日志给清除，writeposition代表的是当前日志文件写到的位置。所以checkpoint后面以及writeposition前面的部分，都是可用的。如果writeposition一直往前写，最后到达了checkpoint的位置，mysql会停下来先将数据全部持久化到磁盘中，然后将日志清除，等到这两步操作完成，才会继续处理业务。 redolog的落盘并不是事务提交以后才开始的，而是在事务的执行过程中就逐步落盘了。重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘 1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。 2，每个事务提交时会将重做日志刷新到重做日志文件。 3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件 对应的数据落盘以后，redolog的作用就结束了，这个时候它就可以覆盖了。 默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2 innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。 innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2 关于文件的大小和数量，由一下两个参数配置 innodb_log_file_size 重做日志文件的大小。 innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1 innodb_flush_log_at_trx_commit这个参数设置为1的时候表示每次事务的redolog都持久化到磁盘中，可以保证崩溃以后数据不丢失。 undologundolog保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC）。undolog是在事务发生之前生成的事务提交以后undolog并不会马上被删除，而是会被放入待清理的链表中，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。 binlog1，用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。2，用户备份欢颜,用于数据库的基于时间点的还原。 binlog是在事务提交的时候一次性写入binlog文件中的。binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。 sync_binlog这个参数设置为1的时候表示每次事务的binlog都持久化到磁盘中，可以保证崩溃重启以后binlog不丢失,用来备份恢复的时候数据不丢失。 两阶段写日志redolog(prepare) -&gt; binlog -&gt; redolog(commit)","categories":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"www.hlblogs.com/tags/mysql/"}]},{"title":"AQS之线程的阻塞与唤醒","slug":"源码阅读/java/juc/AQS/AQS之线程的阻塞与唤醒","date":"2018-11-26T16:00:00.000Z","updated":"2018-12-26T07:48:39.302Z","comments":true,"path":"2018/11/27/源码阅读/java/juc/AQS/AQS之线程的阻塞与唤醒/","link":"","permalink":"www.hlblogs.com/2018/11/27/源码阅读/java/juc/AQS/AQS之线程的阻塞与唤醒/","excerpt":"竞争同步状态失败的线程会被封装成节点进入CLH队列，然后可能如果CLH队列不是空的队列，那么它可能会被阻塞住，等待它的前置节点释放同步状态以后将它唤醒。这节要讲的就是AQS中线程的阻塞与唤醒。","text":"竞争同步状态失败的线程会被封装成节点进入CLH队列，然后可能如果CLH队列不是空的队列，那么它可能会被阻塞住，等待它的前置节点释放同步状态以后将它唤醒。这节要讲的就是AQS中线程的阻塞与唤醒。 阻塞普通阻塞获取同步状态失败的节点会被封装成节点进入CLH队列中，在这里它一般会进入阻塞状态等待它的前置节点将它唤醒。回顾一下独占式获取同步状态和共享式获取同步状态的代码:独占式:12345678910111213141516171819202122232425262728public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 共享式:123456789101112131415161718192021222324252627282930313233public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125;private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 观察代码可以发现无论是独占式获取同步状态还是共享式获取同步状态，代码中都有这么一段:123if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; 这段代码的作用是: 判断当前节点是否需要被阻塞，如果当前节点需要被阻塞,就将它阻塞起来并且在节点被唤醒以后返回节点所代表线程的中断状态。shouldParkAfterFailedAcquire方法用来判断当前节点是否需要阻塞，parkAndCheckInterrupt方法用来阻塞当前线程然后返回中断状态。shouldParkAfterFailedAcquire方法:12345678910111213141516171819private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) //如果当前节点的前置节点的等待状态已经被设置为Node.SIGNAL，那么当前节点就可以被安全的阻塞。 //注: 持有同步状态的头结点在释放同步状态以后,如果其等待状态为Node.SIGNAL就会唤醒后继节点。 return true; if (ws &gt; 0) &#123; //waitStatus &gt; 0说明该节点已经取消了获取同步状态 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //代码执行到这里，前置节点的waitStatus的状态只能是默认的0或者是Node.PROPAGATE, //不管是默认的0还是Node.PROPAGATE都需要将它修改为Node.SIGNAL,目的是在前置节点释放同步状态以后能将后置节点唤醒。 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; parkAndCheckInterrupt方法:123456private final boolean parkAndCheckInterrupt() &#123; //阻塞当前线程 LockSupport.park(this); //被唤醒后返回线程的中断状态 return Thread.interrupted();&#125; 定时阻塞AQS中还有一种定时阻塞的情况存在,即节点只在固定的时间内阻塞，过了这个时间以后就会自我唤醒，而不用等待其他的节点来唤醒。这个情况只在超时获取同步状态的时候存在。如下代码1234if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) //阻塞时长nanosTimeout，然后自动醒来。 LockSupport.parkNanos(this, nanosTimeout); 唤醒当持有同步状态的头结点释放同步状态以后,如果它有后继节点(waitStatus==Node.SIGNAL),那么它会将它的后继节点从阻塞中唤醒。AQS中的unparkSuccessor方法就是用来实现这一功能的。12345678910111213141516171819202122private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) //如果当前头结点的waitStatus&lt;0,将之设置为默认的0. compareAndSetWaitStatus(node, ws, 0); Node s = node.next; //s==null: 头结点的next可能null //s.waitStatus&gt;0 该节点可能由于中断或者超时已经取消了获取同步状态 if (s == null || s.waitStatus &gt; 0) &#123; s = null; //从尾节点开始向前遍历，找到第一个可以唤醒的节点 //这么做的原因是当前持有同步状态的头结点的next可能为null或者它的后继节点已经取消了获取同步状态。 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) //唤醒后继节点 LockSupport.unpark(s.thread);&#125; AQS中的阻塞与唤醒都是通过LockSupport这个工具类来实现的，LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，这个类总体来说还是比较简单容易理解的，这里就不细说了。","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"散列表","slug":"数据结构与算法/散列表随记(writing)","date":"2018-11-26T16:00:00.000Z","updated":"2018-12-17T02:27:50.281Z","comments":true,"path":"2018/11/27/数据结构与算法/散列表随记(writing)/","link":"","permalink":"www.hlblogs.com/2018/11/27/数据结构与算法/散列表随记(writing)/","excerpt":"散列表","text":"散列表 散列冲突解决办法:1.开放寻址法 适合在数据量小，加载因子较小的场景下使用 java中的ThreadLocalMap2.链表法 适合在数据量较大，存储大对象，加载因子较大的场景下使用 java中的HashMap,LinkedHashMap","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"www.hlblogs.com/categories/数据结构与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"www.hlblogs.com/tags/数据结构/"}]},{"title":"ThreadLocal源码阅读笔记","slug":"源码阅读/java/juc/ThreadLocal源码阅读笔记","date":"2018-11-26T16:00:00.000Z","updated":"2018-12-28T01:18:33.369Z","comments":true,"path":"2018/11/27/源码阅读/java/juc/ThreadLocal源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/11/27/源码阅读/java/juc/ThreadLocal源码阅读笔记/","excerpt":"参考资料https://www.jianshu.com/p/ee8c9dccc953https://www.jianshu.com/p/ee8c9dccc953","text":"参考资料https://www.jianshu.com/p/ee8c9dccc953https://www.jianshu.com/p/ee8c9dccc953","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"2018年12月1日","slug":"他和他的猫/猫咪的日常/2018-12-01","date":"2018-11-26T16:00:00.000Z","updated":"2018-12-04T11:07:51.530Z","comments":true,"path":"2018/11/27/他和他的猫/猫咪的日常/2018-12-01/","link":"","permalink":"www.hlblogs.com/2018/11/27/他和他的猫/猫咪的日常/2018-12-01/","excerpt":"","text":"","categories":[{"name":"猫咪的日常","slug":"猫咪的日常","permalink":"www.hlblogs.com/categories/猫咪的日常/"}],"tags":[{"name":"猫咪的日常","slug":"猫咪的日常","permalink":"www.hlblogs.com/tags/猫咪的日常/"}]},{"title":"ThreadPoolExecutor源码阅读笔记","slug":"源码阅读/java/juc/线程池/ThreadPoolExecutor源码阅读笔记","date":"2018-11-26T16:00:00.000Z","updated":"2019-01-14T01:13:45.005Z","comments":true,"path":"2018/11/27/源码阅读/java/juc/线程池/ThreadPoolExecutor源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/11/27/源码阅读/java/juc/线程池/ThreadPoolExecutor源码阅读笔记/","excerpt":"ThreadPoolExecutor源码阅读笔记","text":"ThreadPoolExecutor源码阅读笔记 字段12345678910111213141516171819202122232425262728/** * 主池的控制状态，这个状态包含了两个概念 * 1.workerCount: 表示线程池中的有效线程数 * 2.runState: 表示当前线程池的状态，是否打开 关闭等等 * ctl的高3位表示”线程池状态”，低29位表示”线程池中的任务数量”。 */private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;// 以下是五个状态// RUNNING: 接收新任务并且处理排队任务// SHUTDOWN: 不再接收新任务，但是会继续处理未完成的排队任务// STOP: 不再接收新任务，也不再处理未完成的排队任务，同时中断进行中的任务// TIDYING: 所有的任务都被终止了，workerCount等于0，转换到TIDYING状态的线程将会调用terminated()方法// TERMINATED: terminated()方法执行完成。//状态转换// RUNNING -&gt; SHUTDOWN 发生在调用shutdown()方法时，可能隐藏在finalize()方法中。// (RUNNING or SHUTDOWN) -&gt; STOP 发生在调用shutdownNow()时// SHUTDOWN -&gt; TIDYING 发生在当队列和线程池中正在执行的任务都为空的时候// STOP -&gt; TIDYING 发生在当线程池为空的时候// TIDYING -&gt; TERMINATED 发生在terminated()方法执行完成的时候private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; //对应的高3位的值为111.private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //对应的高3位的值为000 .private static final int STOP = 1 &lt;&lt; COUNT_BITS; //对应的高3位的值为001.private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; //对应的高3位的值为010.private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; //对应的高3位的值为011. 初始化123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; ThreadPoolExecutor有四个构造方法，上面贴出来的这个是参数最全的，一共七个参数,每个参数的具体含义如下:corePoolSize线程池中核心线程的数量。每当提交一个任务时，线程池会新建一个线程来执行任务，直到当前线程数等于corePoolSize。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。 maximumPoolSize线程池中允许的最大线程数。当线程池中的线程都处于工作状态时，如果依然有新任务提交上来，这些任务会被加入到阻塞队列中。阻塞队列满了之后，如果还有任务提交，如果当前的线程数小于maximumPoolSize，则会新建线程来执行任务。注意，如果使用的是无界队列，该参数也就没有什么效果了。 keepAliveTime线程的可空闲时间，这个参数只有在当前线程池中的线程数量大于corePoolSize时才有用。 unitkeepAliveTime的时间单位。 workQueue用来保存等待执行的任务的阻塞队列，它是BlockingQueue类型，java中有四个实现了BlockingQueue接口的阻塞队列可供选择使用。ArrayBlockingQueue: 基于数组的有界阻塞队列，FIFO。LinkedBlockingQueue:基于链表的有界阻塞队列，FIFO。PriorityBlockingQueue: 基于二叉堆的优先级队列，它是一个无界队列。SynchronousQueue: 不存储元素的阻塞队列，它的每一个入列操作都必须等待一个出列操作完成。入列出列交替进行。 threadFactory用于创建线程的工厂。 handler线程池的拒绝策略。当向线程池中提交任务时，如果此时线程池中的线程已经饱和了，而且阻塞队列也已经满了，则线程池会选择一种拒绝策略来处理该任务。线程池提供了四种拒绝策略:AbortPolicy:直接抛出异常，默认策略；CallerRunsPolicy:用调用者所在的线程来执行任务；DiscardOldestPolicy:丢弃阻塞队列中靠最前的任务，并执行当前任务；DiscardPolicy:直接丢弃任务； 线程工厂ThreadFactory是用来创建线程的工厂，根据其他的构造方法可以看到默认的实现:123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125; ThreadPoolExecutor中默认的构造方法实现为Executors.defaultThreadFactory(),返回的是DefaultThreadFactory的实例123public static ThreadFactory defaultThreadFactory() &#123; return new DefaultThreadFactory();&#125; 1234567891011121314151617181920212223242526static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = \"pool-\" + poolNumber.getAndIncrement() + \"-thread-\"; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125;&#125; DefaultThreadFactory实例通过newThread()方法创建线程，创建出来的线程都是非守护线程，线程的优先级都是NORM_PRIORITY。同时，使用newThread方法创建需要提供一个Runnable实例，这个在任务队列中也有体现，任务队列的类型为BlockingQueue，说明所有的任务都必须实现了Runnable接口。 拒绝策略当向线程池中提交任务时，如果此时线程池中的线程已经饱和了，而且阻塞队列也已经满了，则线程池会选择一种拒绝策略来处理该任务。线程池提供了四种拒绝策略: AbortPolicy:直接抛出异常，默认策略；12345678910public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException(\"Task \" + r.toString() + \" rejected from \" + e.toString()); &#125;&#125; CallerRunsPolicy:直接使用调用execute()方法的线程来执行这个任务。1234567891011public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; DiscardOldestPolicy:丢弃阻塞队列中靠最前的任务，并执行当前任务；123456789101112public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; //任务队列出列 e.getQueue().poll(); e.execute(r); &#125; &#125;&#125; DiscardPolicy:什么也不做，直接丢弃任务;1234567public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125;&#125; 执行任务新增任务、新增工作线程1234567891011121314151617181920212223242526272829public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); if (workerCountOf(c) &lt; corePoolSize) &#123; //如果当前线程中的线程数量小于corePoolSize，就调用addWorker方法创建一个新的工作线程去处理这个任务。 if (addWorker(command, true)) return; c = ctl.get(); &#125; //如果当前线程池处于RUNNING状态，就尝试将该任务加入到阻塞队列中(***新增任务***)。 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //加入阻塞队列成功 //进行一次二次检测 if (! isRunning(recheck) &amp;&amp; remove(command)) //如果当前线程池不是RUNNING状态，就将刚刚添加的任务移除,然后拒绝掉 reject(command); else if (workerCountOf(recheck) == 0) //如果当前线程池是RUNNING状态，并且线程池中的线程数为0，创建新的线程 addWorker(null, false); &#125; else if (!addWorker(command, false)) //如果当前线程不是RUNNING状态，或者新任务加入到阻塞队列失败，创建新线程处理这个任务，直到线程数量达到maxPoolSize //如果创建新线程失败，就将这个任务拒绝掉。 reject(command);&#125; 执行任务的流程如下: 如果线程池当前线程数小于corePoolSize，则调用addWorker创建新线程执行任务，成功返回true，失败执行步骤2。 如果线程池处于RUNNING状态，则尝试加入阻塞队列，如果加入阻塞队列成功，则尝试进行Double Check，如果加入失败，则执行步骤3。 如果线程池不是RUNNING状态或者加入阻塞队列失败，则尝试创建新线程直到maxPoolSize，如果失败，则调用reject()方法运行相应的拒绝策略。 新增工作线程当线程池中的当前线程数小于corePoolSize，或者阻塞队列已满并且当前线程数小于maxPoolSize时，调用addWorker()创建新线程执行任务，当前线程数则是根据ctl变量来获取的，调用workerCountOf(ctl)获取低29位即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); /** * rs &gt;= SHUTDOWN : 线程池的状态是SHUTDOWN / STOP / TIDYING / TERMINATED * rs == SHUTDOWN &amp;&amp; firstTask != null : 线程池为SHUTDOWN时不接受新任务 * rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue is empty : * 当rs == SHUTDOWN &amp;&amp; firstTask == null时可以看做是增加一个没有任务的线程， * 然后这个线程从队列中获取任务并执行，但是当workQueue是空队列时，增加这个线程就没有意义。 */ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) //如果当前的线程池的数量已经达到了可创建线程数量的最大值， //就不能再继续创建线程了，直接返回false. return false; if (compareAndIncrementWorkerCount(c)) //CAS使workerCount加1，如果成功，退出内外两层循环。 //如果workerCount的值发生了改变导致本次CAS失败，内层循环直到成功 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) //如果线程池的状态发生了改变，退出内层循环，在外层循环中重新对线程池的状态进行判断。 continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; /** * 1.创建新的工作线程 * 2.加入到线程池中 * 3.启动线程 */ boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) //如果线程已经启动，抛出异常 throw new IllegalThreadStateException(); //将刚刚创建的工作线程加入到线程池中 workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) //修改线程池的最大池大小 largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123; //如果线程已经添加到了线程池中，启动这个线程。 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) //如果线程启动失败，走添加失败的处理逻辑 addWorkerFailed(w); &#125; return workerStarted;&#125; 执行任务上面讲到，创建新的工作线程添加到线程池以后，紧接着会启动这个线程。大家都知道，线程执行的时候实际上是执行了run()方法:12345678private Runnable target;public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 在没有实现run方法覆盖的情况下，最终执行的是Thread内部的Runnable实例的run方法，线程池中的Thread肯定是没有覆盖run方法的，所以执行的一定是传进去的Runnable实例的run方法。再来看看Worker的创建:12345678Worker w = null; try &#123; w = new Worker(firstTask); //.....此处省略 &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; 在创建工作线程的时候，我们将第一个任务作为参数传递过去，再来看看Worker类的构造方法:12345Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this);&#125; 构建Worker实例的时候，接收了第一个任务，并且创建新的线程的时候将Worker实例作为参数传递。再来看看创建线程的逻辑:12345678910public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t;&#125; 这里直接new了一个Thread实例，并且将Worker实例作为Runnable实例进行传参。由于Worker实例实现了Runnable接口，并且实现了run方法，所以最终这个线程在执行的时候，执行的是Worker实例的run方法:123public void run() &#123; runWorker(this);&#125; runWorker方法:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //如果Worker实例中的第一个任务为空，就从任务队列中获取一个任务。 //注意这里维护了一个循环，当前Worker执行完任务以后不会被回收， //而是会不停的从队列中获取任务并处理，直到队列中的任务被处理完毕。 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; //执行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; //执行完毕 回收线程 processWorkerExit(w, completedAbruptly); &#125;&#125; 从任务队列中获取一个任务:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //如果线程池已经停止不在处理任务或者当前线程池已经处于SHUTDOWN装填并且任务队列已经空了 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; //调整工作线程的数量 decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); //如果允许核心线程超时或者是当前工作线程数量大于核心线程数，这个值为true. boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //调整工作线程的数量 if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; /** * 这里的操作能够体现keepAliveTime的作用，如果当前任务队列中的任务已经处理完毕， * 并且 (设置了允许核心线程超时或者设置了不允许核心线程超时但当前工作线程的数量大于核心线程的数量) * 那么就超时的获取任务，超时以后将该线程回收掉 * * 如果设置了不允许核心线程超时并且当前的工作线程数量不大于设置的核心线程数量 * 那么当前线程会一直阻塞，知道有新的任务进来。 */ Runnable r = timed ? //超时的获取一个任务，超时以后返回null workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 线程回收processWorkerExit:12345678910111213141516171819202122232425262728293031323334353637/** * completedAbruptly : 代表当前worker是否是执行完任务以后正常退出的，false代表正常退出。 */private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; if (completedAbruptly) //如果不是正常完成的，调整workerCount decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks; workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); int c = ctl.get(); if (runStateLessThan(c, STOP)) &#123; if (!completedAbruptly) &#123; //获取最小线程数，如果允许核心线程超时，则需要留存的最小线程数为0，默认就是核心线程数 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; if (min == 0 &amp;&amp; ! workQueue.isEmpty()) //如果允许核心线程超时吧并且当前任务队列中还有任务没有执行， //那么最少需要留下一个线程来执行任务 min = 1; //如果当前线程数大于或等于需要留存的最小线程数，那么不需要创建新的线程，直接返回即可， //否则就需要创建一个新的线程加入到线程池中去。 if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; //增加一个新的没有首任务的工作线程 addWorker(null, false); &#125;&#125; 线程的回收主要分为两种情况: 当前工作队列中的任务可能还没有执行完毕，执行某个任务的途中发生了异常:异常以后当前线程会释放所有的资源，这个时候需要调整工作线程的数量，然后再增加一个新的没有首任务的工作线程。 当前工作队列中已经没有任务可供当前Worker执行，执行途中没有发生异常。这种情况下需要修改已完成的任务数量，然后将当前Worker从线程池中移除。然后根据设置的allowCoreThreadTimeOut参数及当前线程池中的线程数来判断线程池中是否需要创建新的线程。 线程池的运行状态转换开头讲到，线程池有五种状态，分别是RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED. 线程池的五种状态及其特点RUNNING: 接收新任务并且处理排队任务SHUTDOWN: 不再接收新任务，但是会继续处理未完成的排队任务STOP: 不再接收新任务，也不再处理未完成的排队任务，同时中断进行中的任务TIDYING: 所有的任务都被终止了，workerCount等于0，转换到TIDYING状态的线程将会调用terminated()方法TERMINATED: terminated()方法执行完成。 线程池状态的转换线程池中的状态是不可逆的，只能按照RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED这种顺序一一转换.RUNNING -&gt; SHUTDOWN 发生在调用shutdown()方法时，可能隐藏在finalize()方法中。(RUNNING or SHUTDOWN) -&gt; STOP 发生在调用shutdownNow()时SHUTDOWN -&gt; TIDYING 发生在当队列和线程池中正在执行的任务都为空的时候STOP -&gt; TIDYING 发生在当线程池为空的时候TIDYING -&gt; TERMINATED 发生在terminated()方法执行完成的时候 下面来对这五种转换座一下讲解: RUNNING -&gt; SHUTDOWN发生在调用shutdown()方法时，可能隐藏在finalize()方法中。1234567891011121314public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); //修改线程池的运行状态为SHUTDOWN advanceRunState(SHUTDOWN); interruptIdleWorkers(); onShutdown(); // hook for ScheduledThreadPoolExecutor &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate();&#125; (RUNNING or SHUTDOWN) -&gt; STOP发生在调用shutdownNow()时12345678910111213141516public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); //修改线程池的运行状态为STOP advanceRunState(STOP); interruptWorkers(); tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; tryTerminate(); return tasks;&#125; SHUTDOWN -&gt; TIDYING发生在当队列和线程池中正在执行的任务都为空的时候123456789101112131415161718192021222324252627282930final void tryTerminate() &#123; for (;;) &#123; int c = ctl.get(); if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; if (workerCountOf(c) != 0) &#123; // Eligible to terminate interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; terminated(); &#125; finally &#123; ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; // else retry on failed CAS &#125;&#125; STOP -&gt; TIDYING发生在当线程池为空的时候 TIDYING -&gt; TERMINATED发生在terminated()方法执行完成的时候","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"二叉树的遍历","slug":"数据结构与算法/二叉树的遍历(done)","date":"2018-11-18T16:00:00.000Z","updated":"2018-12-17T02:27:24.616Z","comments":true,"path":"2018/11/19/数据结构与算法/二叉树的遍历(done)/","link":"","permalink":"www.hlblogs.com/2018/11/19/数据结构与算法/二叉树的遍历(done)/","excerpt":"分别使用递归和非递归的方式实现二叉树的前中后序遍历以及广度优先遍历和深度优先遍历。","text":"分别使用递归和非递归的方式实现二叉树的前中后序遍历以及广度优先遍历和深度优先遍历。 二叉树的节点:1234567891011121314public class Node &#123; public Node(String key,String val)&#123; this.key = key; this.value = val; &#125; public String key; public String value; public Node left; public Node right;&#125; 创建一颗二叉树:1234567891011121314151617181920212223242526272829303132333435public Node root = new Node(\"A\",\"A-VAL\");public void initBinaryTree()&#123; Node B = new Node(\"B\",\"B-VAL\"); Node C = new Node(\"C\",\"C-VAL\"); Node D = new Node(\"D\",\"D-VAL\"); Node E = new Node(\"E\",\"E-VAL\"); Node F = new Node(\"F\",\"F-VAL\"); Node G = new Node(\"G\",\"G-VAL\"); Node H = new Node(\"H\",\"H-VAL\"); Node I = new Node(\"I\",\"I-VAL\"); root.left = B; root.right = C; B.left = D; B.right = E; C.left = F; D.left = G; E.right = H; F.right = I; /** * A * B C * D E F * G H I */&#125; 使用递归的方式实现二叉树的前序遍历: 12345678public void preErgodic(Node root)&#123; if(root == null)&#123; return ; &#125; System.out.print(root.key+\" \"); preErgodic(root.left); preErgodic(root.right);&#125; 使用非递归的方式实现二叉树的前序遍历:123456789101112131415161718public void preErgodic2(Node root)&#123; if(root == null)&#123; return ; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.empty())&#123; Node node = stack.pop(); System.out.print(node.key+\" \"); if(node.right != null)&#123; stack.push(node.right); &#125; if(node.left != null)&#123; stack.push(node.left); &#125; &#125;&#125; 使用递归的方式实现二叉树的中序遍历:12345678public void cenErgodic(Node root)&#123; if(root == null)&#123; return ; &#125; cenErgodic(root.left); System.out.print(root.key+\" \"); cenErgodic(root.right);&#125; 使用非递归的方式实现二叉树的后续遍历:12345678910111213141516public void cenErgodic2(Node root)&#123; if(root == null)&#123; return ; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); while(root!=null || !stack.empty())&#123; if(root != null)&#123; stack.push(root); root = root.left; &#125;else&#123; Node node = stack.pop(); System.out.print(node.key+\" \"); root = node.right; &#125; &#125;&#125; 使用递归的方式实现二叉树的后序遍历:12345678public void postErgodic(Node root)&#123; if(root == null)&#123; return ; &#125; postErgodic(root.left); postErgodic(root.right); System.out.print(root.key+\" \");&#125; 使用非递归的方式实现二叉树的后序遍历:123456789101112131415161718192021222324public void postErgodic2(Node root)&#123; Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;(); Node node = root; Node lastVisit = root; while (node != null || !stack.isEmpty()) &#123; while (node != null) &#123; stack.push(node); node = node.left; &#125; //查看当前栈顶元素 node = stack.peek(); //如果其右子树也为空，或者右子树已经访问 //则可以直接输出当前节点的值 if (node.right == null || node.right == lastVisit) &#123; System.out.print(node.key + \" \"); stack.pop(); lastVisit = node; node = null; &#125; else &#123; //否则，继续遍历右子树 node = node.right; &#125; &#125;&#125; 二叉树的广度优先遍历(BFS):1234567891011121314151617public void breadthFirstErgodic(Node root)&#123; if(root == null)&#123; return; &#125; Queue&lt;Node&gt; stack = new ArrayDeque&lt;&gt;(); stack.add(root); while(!stack.isEmpty())&#123; Node node = stack.remove(); System.out.print(node.key+\" \"); if(node.left != null)&#123; stack.add(node.left); &#125; if(node.right != null)&#123; stack.add(node.right); &#125; &#125;&#125; 二叉树的深度优先遍历(DFS):1234567891011121314151617public void depthFirstErgodic(Node root)&#123; if(root == null)&#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.add(root); while(!stack.isEmpty())&#123; Node node = stack.pop(); System.out.print(node.key+\" \"); if(node.right != null)&#123; stack.add(node.right); &#125; if(node.left != null)&#123; stack.add(node.left); &#125; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"www.hlblogs.com/categories/数据结构与算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"www.hlblogs.com/tags/数据结构/"}]},{"title":"AQS之状态的获取与释放","slug":"源码阅读/java/juc/AQS/AQS之状态的获取与释放","date":"2018-11-17T16:00:00.000Z","updated":"2018-12-26T07:48:39.243Z","comments":true,"path":"2018/11/18/源码阅读/java/juc/AQS/AQS之状态的获取与释放/","link":"","permalink":"www.hlblogs.com/2018/11/18/源码阅读/java/juc/AQS/AQS之状态的获取与释放/","excerpt":"上一篇博客AQS之CLH队列大致分析了一下AQS中的CLH队列的情况，本节来分析一下AQS中状态的获取与释放","text":"上一篇博客AQS之CLH队列大致分析了一下AQS中的CLH队列的情况，本节来分析一下AQS中状态的获取与释放 同步状态的获取同步状态的获取分为独占式获取和共享式获取，这两种获取方式根据是否响应中断和超时，又有不同的获取特点。 独占式获取同步状态独占式的获取同步状态的特点是同步状态只能被一个线程所获取，其他所有的线程都会获取失败并且进入CLH队列等待持有同步状态的线程释放状态。 不响应中断和超时的获取不响应中断和超时的获取方式无视任何线程对当前线程中断状态的标记，并且在没有其他不可控异常的情况下会一直等待直到获取同步状态，AQS中提供了acquire(int arg):void方法用来获取同步状态。12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 这个方法在获取状态之前是不会退出的，所以它执行完毕以后一定是成功获取状态的。这个方法的代码比较简单，如果tryAcquire(arg)这个方法返回false,就执行addWaiter方法，然后执行acquireQueued方法，等到acquireQueued方法执行完毕执行selfInterrupt方法。上节我们讲到addWaiter方法是用来将获取同步状态失败的线程封装成节点并加入到CLH队列的，那么我们可以根据这一方法的功能和其他方法的名称来猜想一下，tryAcquire方法是用来尝试获取同步状态的，而acquireQueued方法是用来使队列中的节点获取同步状态的，那么究竟是不是这样呢？我们接下来一点点的看。首先来看tryAcquire方法的代码:123protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException();&#125; what?这个方法什么也没做直接抛出了异常，这还怎么玩。。。我们来看看这个方法的注释是怎么说的:1234567891011121314/** * Attempts to acquire in exclusive mode. This method should query * if the state of the object permits it to be acquired in the * exclusive mode, and if so to acquire it. * * &lt;p&gt;This method is always invoked by the thread performing * acquire. If this method reports failure, the acquire method * may queue the thread, if it is not already queued, until it is * signalled by a release from some other thread. This can be used * to implement method &#123;@link Lock#tryLock()&#125;. * * &lt;p&gt;The default * implementation throws &#123;@link UnsupportedOperationException&#125;. */ 这段注释详细的解释了这个方法的作用:这个方法尝试以独占模式来获取状态，它需要查询当前的同步状态是否允许它以独占模式获取同步状态，如果允许的话，它就能获取同步状态。这个方法永远只会在线程获取同步状态的时候被调用，如果这个方法返回了失败的信息并且这个线程不在CLH队列中，acquire方法将会使当前线程入列排队(调用addWaiter方法)，直到它被释放了同步状态的线程唤醒,这可以被用来实现Lock接口中的tryLock方法(此处请先忽略)。 默认的实现将抛出UnsupportedOperationException异常 注意上面这一句，默认的实现将会直接抛出异常，既然默认的实现不能使用，那就说明还有其他的实现并且这个实现可能在不同的地方根据不同的使用场景有不同的具体实现。根据方法追溯我们可以发现，这个方法在ReentrantLock，ReentrantReadWriteLock和ThreadPoolExecutor三个类中被重写了。具体是如何实现的我们日后讲到这三个类的时候再说，这里我们只需要明白两个问题，一是这个方法需要被子类做具体实现才能使用，二是这个方法的作用是返回是否成功获取同步状态。 接下来我们再来看看acquireQueued探一探方法的虚实:123456789101112131415161718192021222324final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取该节点的前置节点 final Node p = node.predecessor(); //如果该节点的前置节点是头节点，就执行tryAcquire方法 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; //判断当前节点是否需要阻塞，如果需要阻塞，就阻塞起来 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 通过具体代码可以看出acquireQueued方法内部主要就是一个死循环，在没有异常的情况下想退出这个循环就只有一条路，那就是满足for循环内的第一个if条件并执行内部的代码。if内的条件我已经注释出来了，如果当前节点的前置节点是头节点，就尝试获取同步状态，在当前节点获取到同步状态以后。获取同步状态以后，将当前节点设置为头节点，并断开前置节点与当前节点的联系。这里解释一下为什么获取同步状态要先判断当前节点的前置节点是否是头节点，我们知道，获取同步状态失败的线程，将会被封装成节点进入CLH队列，CLH队列是一个FIFO队列，为了满足其FIFO的特性，就需要按照队列内的顺序来一次获取同步状态，而头节点一定是当前持有同步状态的节点，按照FIFO的规则，下一个能获取到同步状态的节点一定得是阻塞队列的第一个节点，也就是头节点的后置节点。所以这里必须要先判断当前节点的前置节点是否是头节点。 到这里整个不响应中断和超时的独占式获取同步状态的过程就结束了，我们来总结一下目前锁了解到的整个过程: 首先尝试独占式获取同步状态，如果获取失败，就把当前节点封装成节点进入CLH队列，进入队列以后节点将会在队列内无限循环直到成功获取了同步状态以后才能退出，退出也就意味着当前线程获取同步状态一定成功了，但是这里不是所有的节点都在进行无限的for循环，事实上几乎所有进入队列的节点都会阻塞起来，只有每个节点的前置节点是头节点，并且前置节点释放了同步状态以后将后置节点唤醒以后，才能继续进行循环的操作。 响应中断的获取响应中断的获取方式和上面的获取方式的过程几乎是一样的，唯一的不同是加入了对中断状态的响应。AQS中的acquireInterruptibly方法提供了中断获取同步状态的功能。它的源码如下:12345678public final void acquireInterruptibly(int arg) throws InterruptedException &#123; //响应中断,如果此时发现线程被中断了，就抛出中断异常 if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; 首先我们可以看到，进入方法以后首先对中断状态进行判断，这一步是acquire方法所没有的。tryAcquire方法我们上面已经讲过了，它是用来尝试获取同步状态的，如果能够获取成功，方法就执行结束了，如果获取失败，执行doAcquireInterruptibly方法，接下来我们看一下这个方法的内部是什么样的:123456789101112131415161718192021222324private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; //将当前线程封装成节点加入到CLH队列中 final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) //如果线程被唤醒以后发现被中断了，直接抛出异常 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; doAcquireInterruptibly方法的内部实现与acquireQueued是非常相似的，最大的不同在于下面这段代码:123if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); 这里我们来简单的说一下shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法的作用，至于具体实现，下一篇博客中会做具体分析。shouldParkAfterFailedAcquire方法的作用是判断当前节点需不需要阻塞，需要则返回true,不需要返回false.parkAndCheckInterrupt方法的作用是阻塞当前节点，并且在被唤醒以后返回当前线程的中断状态。那么这端代码的意思就很明显了，如果当前节点需要被阻塞，那么它就会进入阻塞状态。在节点被唤醒以后，会返回节点的中断状态。如果发现在阻塞的过程中节点已经被中断了，就会抛出InterruptedException。 响应超时的获取响应超时的获取方式会同时响应中断和超时两种情况，在响应中断的基础上加上了对超时时间的控制，如果达到了超时时间还没能获取到同步状态，就直接退出。AQS中的tryAcquireNanos方法提供了这个功能:1234567public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; 这里需要说一下nanosTimeout这个long类型参数，它的单位是纳秒，它的意义是多长时间以后超时。整个方法还是比较简单的，相比大家都能看明白，这里还有一点需要注意，这个方法是有返回值的，而且是boolean类型，前面讲的acquire方法和acquireInterruptibly方法都时没有返回值的，方法顺利执行完毕就默认是一定获取到同步状态的，而这里是需要判断返回值来确定是否已经成功获取同步状态的。接下来我们看一下doAcquireNanos这个方法:1234567891011121314151617181920212223242526272829303132333435private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; //计算超时时间 final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; //计算剩余超时时间还有多少时间 nanosTimeout = deadline - System.nanoTime(); //如果当前已经超时了，返回false，本次获取同步状态失败。 if (nanosTimeout &lt;= 0L) return false; //如果节点需要阻塞并且当前剩余的超时时间大于1000纳秒(spinForTimeoutThreshold==1000L), //那么就将当前节点阻塞一段时间(时间长度等于剩余超时时间) if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; doAcquireNanos方法的整理逻辑还是比较简单的，重点的地方都加了注释了。关于中断的处理就不再赘述了，这里稍微整理一下超时的逻辑:首先计算出超时的时间点，然后每一次循环都去计算一次剩余的超时时间，当超时时间小于等于0，说明已经达到了超时的时间点或者已经超时了，那么本次获取就结束了。如果当前节点需要被阻塞，并且剩余超时时间大于1000纳秒，就让当前线程阻塞一段时间(剩余超时时间)，这个阻塞是不需要其他线程来唤醒的，到了时间线程会自动苏醒。有一个地方我觉比较需要单独说一下，就是说我们在tryAcquireNanos中传入的超时参数nanosTimeout并不一定就是准确的超时返回时间，它只是提供一个大致的时间点，实际上这个时间可能是会浮动的，而且一般上往上浮动。比如你设置2000纳秒以后超时，但是实际上可能2200纳秒以后才会超时返回。 共享式获取同步状态共享式获取同步状态和独占式获取同步状态的不同之处在于独占式获取共享状态任何时刻只有一个线程能获取成功，其他的线程必须进入CLH队列中等待持有同步状态的线程释放同步状态以后才能继续尝试获取，而共享式获取同步状态并不需要获取同步状态的线程释放就能获取成功，在同一时刻可以有多个线程持有同步状态。 不响应中断和超时的获取12345public final void acquireShared(int arg) &#123; //尝试获取同步状态 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 共享式获取tong不状态的流程和独占式获取非常相似。首先我们来看tryAcquireShared方法:123protected int tryAcquireShared(int arg) &#123; throw new UnsupportedOperationException();&#125; 是不是觉得似曾相识？对，这个方法和tryAcquire方法几乎是一模一样，都需要子类去做具体实现。不同的是这个方法的返回值是int类型。tryAcquireShared方法的返回值有三种形式，大于0，等于0，小于0，具体点就是-1,0和1返回值为-1: 获取同步状态失败返回值为0: 获取同步状态成功，但是后续将不会有线程能获取成功。返回值为1: 获取同步状态成功，并且后续的线程也能获取成功。 再来看看doAcquireShared(int arg)方法:12345678910111213141516171819202122232425262728293031private void doAcquireShared(int arg) &#123; //将线程封装成节点进入CLH队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; //如果前置节点为头结点，尝试获取同步状态。 int r = tryAcquireShared(arg); //tryAcquireShared方法的返回值大于等于0的时候说明当前节点获取同步状态成功。 if (r &gt;= 0) &#123; //如果当前节点获取同步状态成功，将当前节点设置为头结点并传播。 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; doAcquireShared方法的逻辑还是比较容易理解的，这里有一个比较重要的方法setHeadAndPropagate方法需要了解一下:1234567891011private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below //将当前节点设置为头结点 setHead(node); if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; setHeadAndPropagate的作用有两个，一是将获取到同步状态的节点设置为头结点，二是调用doReleaseShared实现释放同步状态以后的逻辑。但是我们得要明白，这里头结点并没有释放同步状态，只是要做释放同步状态以后需要做的事，即唤醒后继节点:1234567891011121314151617181920212223private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases //唤醒后继节点 unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; //进入CLH队尾的节点默认ws都是0，但是如果在执行这一句之前有一个新的节点进入队列成为新的尾节点， //原尾节点的ws就会被修改为Node.SIGNAL，这里的CAS语句就会执行失败。 //如果执行成功，说明当前节点是CLH队列的尾节点，没有后继节点需要唤醒。 !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 我刚开始看这里的代码的时候一直卡着没想明白为什么第一个CAS语句会存在执行失败的问题,想了很久才恍然大悟。相信也有人跟我一样会钻进死胡同，下面就来说一下原因: 我们知道新的节点进入CLH队列以后会将前置节点的waitStatus设置为Node.SIGNAL,在执行第一个CAS的时候必定是已经将当前节点的waitStatus设置成了Node.SIGNAL(外层if条件判断),这样的话执行成功好像是顺理成章的，但是不然。我们假设现在有个节点a,它是头结点，它的后继节点是b,b的后继节点是c,a和b的waitStatus都是Node.SIGNAL。假设当前节点a第一次执行CAS语句的时候执行成功了,然后唤醒了后继节点b,b被唤醒了以后迅速抢占了头结点，成为新的头结点。那么a节点继续往下执行的时候因为头结点已经变了，就没法退出当前循环，只能再一次进入for循环。这个时候可能节点b也进入了for循环，并且a和b同时执行第一个CAS语句，二者竞争必定有一个会失败。 响应中断的获取理解了上面的获取流程，响应中断的获取就非常好理解了，只是加上了对中断状态的响应:12345678public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) //响应中断，抛出异常 throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 1234567891011121314151617181920212223242526private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) //响应中断，抛出异常 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 响应超时的获取关于超时获取的流程，可以参考独占式获取同步状态的超时处理，两种获取方式对于超时获取的处理是相同的:12345678public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) //响应中断，抛出异常 throw new InterruptedException(); return tryAcquireShared(arg) &gt;= 0 || doAcquireSharedNanos(arg, nanosTimeout);&#125; 1234567891011121314151617181920212223242526272829303132333435363738private boolean doAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; //计算超时时间点 final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return true; &#125; &#125; //计算剩余超时时间还有多少 nanosTimeout = deadline - System.nanoTime(); //如果当前已经超时了，返回false，本次获取同步状态失败。 if (nanosTimeout &lt;= 0L) return false; //如果节点需要阻塞并且当前剩余的超时时间大于1000纳秒(spinForTimeoutThreshold==1000L), //那么就将当前节点阻塞一段时间(时间长度等于剩余超时时间) if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 同步状态的释放独占模式独占模式的同步状态释放有两种形式，一种是指定数量的释放，另一种是全部释放 指定数量释放指定数量的释放方式每一次会释放指定的数量的同步状态。1234567891011public final boolean release(int arg) &#123; //释放同步状态 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //唤醒后继节点 unparkSuccessor(h); return true; &#125; return false;&#125; 123protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException();&#125; 可以看到指定数量释放同步状态其实做了两件事，第一件事是释放同步状态，第二件事是在同步状态全部释放以后唤醒后继节点。tryRelease方法也是需要子类来做具体实现具体逻辑的，这个方法的作用是释放同步状态并返回是否已经将同步状态全部释放，只有在持有同步状态的线程将同步状态全部释放此方法才会返回true. 全部释放全部数量的方式方式会一次将持有同步状态的线程所持有的同步状态全部释放，它是调用release方法来实现的。。123456789101112131415final int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125;&#125; 共享模式1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 共享模式的释放主要就是两个方法，释放状态的tryReleaseShared方法和传播释放动作唤醒后继节点的doReleaseShared方法，tryReleaseShared需要由子类实现，方法内部通过CAS和for循环来确保释放状态。 取消获取同步状态在获取同步状态之前，是可以取消获取同步状态的动作的12345678910111213141516171819202122232425262728293031323334353637383940414243private void cancelAcquire(Node node) &#123; // Ignore if node doesn't exist if (node == null) return; node.thread = null; // Skip cancelled predecessors Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; // predNext is the apparent node to unsplice. CASes below will // fail if not, in which case, we lost race vs another cancel // or signal, so no further action is necessary. Node predNext = pred.next; // Can use unconditional write instead of CAS here. // After this atomic step, other Nodes can skip past us. // Before, we are free of interference from other threads. node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"Git使用日常记录","slug":"Git/Git使用日常记录","date":"2018-11-16T16:00:00.000Z","updated":"2018-12-03T03:25:16.958Z","comments":true,"path":"2018/11/17/Git/Git使用日常记录/","link":"","permalink":"www.hlblogs.com/2018/11/17/Git/Git使用日常记录/","excerpt":"Git使用日常记录","text":"Git使用日常记录","categories":[{"name":"Git","slug":"Git","permalink":"www.hlblogs.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"www.hlblogs.com/tags/Git/"}]},{"title":"AQS简介","slug":"源码阅读/java/juc/AQS/AQS简介","date":"2018-11-14T16:00:00.000Z","updated":"2018-12-26T07:48:39.305Z","comments":true,"path":"2018/11/15/源码阅读/java/juc/AQS/AQS简介/","link":"","permalink":"www.hlblogs.com/2018/11/15/源码阅读/java/juc/AQS/AQS简介/","excerpt":"AQS是什么？AQS全称AbstractQueuedSynchronizer,jdk中对AQS的解释是Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.意思就是AQS它是一个依赖于先进先出队列(FIFO)的用于实现阻塞锁及相关同步器(信号量，事件等等)的框架。","text":"AQS是什么？AQS全称AbstractQueuedSynchronizer,jdk中对AQS的解释是Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.意思就是AQS它是一个依赖于先进先出队列(FIFO)的用于实现阻塞锁及相关同步器(信号量，事件等等)的框架。 AQS被设计成一个对大多数的同步器都有用的基础组件,它使用一个int类型的原子变量来代表同步器的同步状态。这个int变量被声明为volatile变量。1234/** * The synchronization state. */private volatile int state; AQS的子类必须定义AQS中相关的pretected方法用于实现具体的修改同步状态的逻辑，并且从获取和释放的角度来定义该同步状态的意义。说白了就是AQS并没有提供修改同步同步状态的具体逻辑实现,需要子类根据自身的场景去做具体的实现,这里说的修改同步同步状态其实就是获取锁和释放锁的过程。目前AQS中提供的这类方法比较重要的有以下这四个:tryAcquire(int):boolean 尝试独占式获取同步状态,返回true说明同步状态获取成功tryRelease(int):boolean 尝试独占式释放同步状态,返回true说明同步状态释放成功tryAcquireShared(int):int 尝试共享式获取同步状态,返回值大于0说明同步状态获取成功tryReleaseShared(int):boolean 尝试共享式释放同步状态,返回true说明同步状态释放成功(全部释放) 除了这几个方法以外的其他大部分方法都是用于实现排队和阻塞队列的逻辑，AQS中有一个CLH队列，用于处理多线程之间出现锁竞争时线程的排队和阻塞的逻辑。除了CLH阻塞队列以外，AQS内部还提供了一个Condition接口的实现类ConditionObject，用于实现条件等待队列。 我所理解的AQS，其核心就是一个同步状态，一种修改方式，两种操作，两个队列，两种锁 一个状态一个状态指的是同步状态，AQS中用一个32位的int类型变量state的值来代表当前的同步状态。state&gt;0说明同步同步状态已经被一个或多个线程持有,state=0锁未被任何线程持有，这里不存在小于0的情况在ReentrantReadWriteLock中32位的state被分为高低两个16位 高16位代表读锁重入次数 低16位代表写锁重入次数，在读写锁中读锁和写锁的最大可重入次数均为65535 一种方式CAS: Compare And Swap 比较并交换,使用这种方式修改某个值，可以保证在同一时刻多线程企图对某一个值进行修改时只有一个线程能成功。 两个操作同步状态的获取: 使用CAS尝试修改同步状态，一般是对同步状态进行+n操作，对应锁的获取同步状态的释放: 使用CAS尝试修改同步状态，一般是对同步状态进行-n操作，对应锁的释放 两个队列CLH队列：在AQS中获取锁失败的线程会被封装成一个节点加入到阻塞队列中，每一个持有锁的线程在释放锁的时候都会唤醒其后继节点。Condition队列：根据开发人员定义好的条件，为满足条件的线程将会进入到条件队列中并进入阻塞同步状态，但是条件队列中的线程在被唤醒之后不会继续往下执行，而是会出列并进入CLH队列的队尾，等待获取锁后再继续执行。 两种锁独占锁：以独占模式获取到的排他锁，同一时刻只能有一个线程获取到锁，对应独占式获取同步状态共享锁：以共享模式获取到的非排他锁，同一时刻能有多个线程获取到，对应共享式获取同步状态","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"next主题优化","slug":"next主题优化/next主题优化","date":"2018-11-14T16:00:00.000Z","updated":"2018-11-28T02:13:13.127Z","comments":true,"path":"2018/11/15/next主题优化/next主题优化/","link":"","permalink":"www.hlblogs.com/2018/11/15/next主题优化/next主题优化/","excerpt":"next主题优化","text":"next主题优化 实现点击出现桃心效果打开/themes/next/source/js/src ， 新建love.js文件，复制此处的代码到love.js里面。1!function(e,t,a)&#123;function r()&#123;for(var e=0;e&lt;n.length;e++)n[e].alpha&lt;=0?(t.body.removeChild(n[e].el),n.splice(e,1)):(n[e].y--,n[e].scale+=.004,n[e].alpha-=.013,n[e].el.style.cssText=&quot;left:&quot;+n[e].x+&quot;px;top:&quot;+n[e].y+&quot;px;opacity:&quot;+n[e].alpha+&quot;;transform:scale(&quot;+n[e].scale+&quot;,&quot;+n[e].scale+&quot;) rotate(45deg);background:&quot;+n[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;var n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;,function(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),function()&#123;var a=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;a&amp;&amp;a(),function(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,n.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;),t.body.appendChild(a)&#125;(e)&#125;&#125;(),r()&#125;(window,document); 打开/themes/next/layout/_layout.swig文件， 在head标签内最后位置添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 左上角/右上角的Github样式点击这里选择你喜欢的样式，复制其中的代码到themes/next/layout/_layout.swig文件中(放在&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;的下面)，并把href改为你的github地址。","categories":[{"name":"next主题","slug":"next主题","permalink":"www.hlblogs.com/categories/next主题/"}],"tags":[{"name":"next主题","slug":"next主题","permalink":"www.hlblogs.com/tags/next主题/"}]},{"title":"AQS之CLH同步队列","slug":"源码阅读/java/juc/AQS/AQS之CLH队列","date":"2018-11-14T16:00:00.000Z","updated":"2018-12-26T07:48:39.239Z","comments":true,"path":"2018/11/15/源码阅读/java/juc/AQS/AQS之CLH队列/","link":"","permalink":"www.hlblogs.com/2018/11/15/源码阅读/java/juc/AQS/AQS之CLH队列/","excerpt":"在上一篇AQS简介中有提到过AQS内部提供了一个CLH(Craig, Landin, and Hagersten)同步队列，用于处理多线程同时获取状态时的排队和阻塞的逻辑。CLH同步队列是一个FIFO双向队列，在多线程竞争获取状态的情况下，将获取失败的线程及其等待状态等信息封装成节点加入到CLH队列中，并可能会使该节点阻塞起来。当持有同步状态的节点释放同步状态以后，会将其后继节点唤醒。CLH队列中非阻塞状态的节点会判断自己的前置节点是否为头结点，如果前置节点是头结点，就会尝试获取同步状态。","text":"在上一篇AQS简介中有提到过AQS内部提供了一个CLH(Craig, Landin, and Hagersten)同步队列，用于处理多线程同时获取状态时的排队和阻塞的逻辑。CLH同步队列是一个FIFO双向队列，在多线程竞争获取状态的情况下，将获取失败的线程及其等待状态等信息封装成节点加入到CLH队列中，并可能会使该节点阻塞起来。当持有同步状态的节点释放同步状态以后，会将其后继节点唤醒。CLH队列中非阻塞状态的节点会判断自己的前置节点是否为头结点，如果前置节点是头结点，就会尝试获取同步状态。 队列节点一个CLH节点中包含的信息主要有当前线程的引用，等待状态，前置节点的引用，后继节点的引用等等,详情如下:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980static final class Node &#123; /** * 标识当前节点为共享模式 */ static final Node SHARED = new Node(); /** * 标识当前节点为独占模式 */ static final Node EXCLUSIVE = null; /** * 等待状态: 代表该节点已经取消获取状态的行为,一般是由于中断或者超时 */ static final int CANCELLED = 1; /** * 等待状态: 代表该节点的下一个节点需要被唤醒，在该节点释放状态以后将会唤醒后继节点 */ static final int SIGNAL = -1; /** * 等待状态: 这个状态以后再说 */ static final int CONDITION = -2; /** * 等待状态: 这个状态以后再说 */ static final int PROPAGATE = -3; /** * 等待状态 */ volatile int waitStatus; /** * 前置节点的引用 */ volatile Node prev; /** * 后继节点的引用 */ volatile Node next; /** * 指定线程的引用 */ volatile Thread thread; /** * 指向下一个条件等待节点,用于条件队列中 */ Node nextWaiter; /** * 返回true代表当前节点是以共享模式在等待 */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 队列结构CLH同步队列的结构如下:这里来解释一下，为什么Head头结点没有被算在队列中,上面我们有讲到，当线程获取状态失败才会被封装成节点加入到CLH队列中,而头结点可以看成是一定已经成功获取同步状态的节点,所以头节点没有被算在CLH同步队列中。 入列123456789101112131415161718private Node addWaiter(Node mode) &#123; //将当前线程和节点模式等信息封装成一个新的节点 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; //尝试入列,如果尾节点不为空，尝试将新生成的节点设置为尾节点。 if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; //如果当前尾节点为空或者尝试将新节点设置为尾节点的动作失败了， //就用一个死循环来重复处理，确保新的节点一定能加入到CLH队列中 enq(node); return node;&#125; addWaiter方法中的参数是标识节点模式，这个参数只有两个选项，即Node.SHARED和Node.EXCLUSIVE。方法的内容比较简单，注释写的很清晰了。 enq方法用于一个无限的for循环来确保新生成的节点一定能加入到队列中。1234567891011121314151617181920private Node enq(final Node node) &#123; //无限循环 for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize //如果尾节点为空，说明当前队列是一个空队列， //生成一个默认的新的节点作为头结点和尾节点 //这个默认的新节点并没有持有同步状态，它会马上被队列中的后继节点取代。 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; //只有成功将节点设置为尾节点，即成功加入队列，才能退出这个死循环 if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 新节点在进入CLH队列以后会将前置节点的等待状态waitStatus设置为Node.SIGNAL,以用来将来前置节点释放同步状态以后将其后置节点(也就是刚刚入列的这个新节点)唤醒。这个设置非常的重要，我们来看看AQS是怎么做的:1234567891011121314151617private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) //如果当前节点的前置节点的等待状态已经被设置为waitStatus已经被设置为Node.SIGNAL, //那么当前节点就是可以阻塞的 return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //将前置节点的waitStatus设置为Node.SIGNAL compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; AQS中提供了一个shouldParkAfterFailedAcquire方法来实现修改等待状态的功能，注意这个方法的真实作用是用来判断当前节点是否需要阻塞的。这个方法将来会用的比较多,等我们讲到AQS的阻塞和唤醒的时候再细说，这里粗略的了解一下即可。 出列出列的过程也非常的简单，CLH队列是一个FIFO队列，头节点线程在释放状态以后会唤醒当前头节点的后继节点，而后继节点在被唤醒以后把自己设置为头节点，并断开与前置节点的关联，这样前置节点就出列了。因为只有一个节点能获取到状态，所以这里是不需要使用CAS方式来保证的。","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"Semaphore源码阅读笔记","slug":"源码阅读/java/juc/同步工具/Semaphore源码阅读笔记","date":"2018-11-13T16:00:00.000Z","updated":"2018-12-26T07:48:39.337Z","comments":true,"path":"2018/11/14/源码阅读/java/juc/同步工具/Semaphore源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/11/14/源码阅读/java/juc/同步工具/Semaphore源码阅读笔记/","excerpt":"Semphore底层是利用了AQS的共享式获取同步状态的机制","text":"Semphore底层是利用了AQS的共享式获取同步状态的机制 公平锁和非公平锁Sync:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; Sync(int permits) &#123; setState(permits); &#125; final int getPermits() &#123; return getState(); &#125; //非公平的获取同步状态 final int nonfairTryAcquireShared(int acquires) &#123; //通过一个无限循环去不停的尝试获取同步状态，没有排队机制 for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; //释放共享式获取的同步状态 protected final boolean tryReleaseShared(int releases) &#123; //通过一个无限循环去释放同步状态，确保能够成功的释放同步状态 for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error(\"Maximum permit count exceeded\"); if (compareAndSetState(current, next)) return true; &#125; &#125; //减少可获取的同步状态 final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); int next = current - reductions; if (next &gt; current) // underflow throw new Error(\"Permit count underflow\"); if (compareAndSetState(current, next)) return; &#125; &#125; //将可获取的同步状态数量置为0 final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125; &#125;&#125; FairSync(公平获取同步状态):1234567891011121314151617181920static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; //如果当前节点在CLH队列中有前置节点，本次获取同步状态失败。 if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; &#125; NonfairSync(非公平的获取同步状态):1234567891011static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125; 获取同步状态acquire()1234567891011121314public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); //尝试获取同步状态 if (tryAcquireShared(arg) &lt; 0) //尝试获取同步状态失败以后，进入CLH队列,在CLH队列中获取锁 doAcquireSharedInterruptibly(arg);&#125; release()123456789101112public void release() &#123; sync.releaseShared(1);&#125;public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; //释放同步状态成功以后，唤醒后继节点 doReleaseShared(); return true; &#125; return false;&#125;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"Exchanger源码阅读笔记","slug":"源码阅读/java/juc/同步工具/Exchanger源码阅读笔记","date":"2018-11-13T16:00:00.000Z","updated":"2018-12-26T07:48:39.334Z","comments":true,"path":"2018/11/14/源码阅读/java/juc/同步工具/Exchanger源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/11/14/源码阅读/java/juc/同步工具/Exchanger源码阅读笔记/","excerpt":"Exchanger源码阅读笔记","text":"Exchanger源码阅读笔记","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"Cyclicbarrier和CountDownLatch对比","slug":"源码阅读/java/juc/同步工具/CyclicBarrier和CountDownLatch对比","date":"2018-11-12T16:00:00.000Z","updated":"2018-12-26T07:48:39.323Z","comments":true,"path":"2018/11/13/源码阅读/java/juc/同步工具/CyclicBarrier和CountDownLatch对比/","link":"","permalink":"www.hlblogs.com/2018/11/13/源码阅读/java/juc/同步工具/CyclicBarrier和CountDownLatch对比/","excerpt":"Cyclicbarrier和CountDownLatch在功能和实现上的对比","text":"Cyclicbarrier和CountDownLatch在功能和实现上的对比 使用场景CountDownLatch和CyclicBarrier对比 CountDownLatch比较适合使用在多个参与方(参与方的数量是不固定的)约定好了某些条件(可能一个也可能多个，但数量是固定的)，条件完成以后就能做某些事，但是这些条件要依赖于外部(可能是其他线程)来完成的情况下。CyclicBarrier比较适合使用在多个参与方(参与方的数量是固定的)约定好了某一个条件，条件完成以后就能做某些事，但是这个条件必须要每个参与方都达到的情况下。 举例:假如现在有一扇门，CountDownLatch和CyclicBarrier可以理解为门闩和门锁，CountDownLatch相当于门闩，CyclicBarrier相当于门锁。CountDownLatch就像是门上的门闩，屋内的每个人可以拉开一个门闩，等到将门上的门闩全部拉开打开才能大门走向外面的世界。这个门闩是一开始就插好的。CyclicBarrier就像是门上的门锁，几个人分别在几个不同的屋子里，大家相约一起出去，这样必须得等到所有的人都把门锁好了大家才能走，先锁好门的人等待没有锁好门的人。最后一个锁好门的人通知其他人以后大家才可以离开 代码实现CountDownLatch: AQS共享锁CountDownLatch中只有释放锁的操作，各个线程其实并没有获取锁的操作，使用独占锁不划算 CyclicBarrier: ReentrantLock + Condition 1.如果CyclicBarrier采用共享锁会有什么问题？使用共享锁,因为有阻塞队列的存在,多线程的执行就会变成串行的。 2.如果CountDownLatch采用ReentrantLock + Condition会有什么问题？如果CountDownLatch使用ReentrantLock + Condition实现会变的比较复杂，因为ReentranLock和Condition背后代表着两个队列，即AQS中的CLH队列和Condition中的条件队列。CountDownLatch中需要扣除的数量是有限的，每个调用countDown方法线程只需要将指定的数量-1即可，使用CAS也不会存在长时间的自旋，对CPU的影响不会很大。个人认为Doug lea大神是在比较小的性能开销和较高的实现复杂度之间选择了前者。","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"Cyclicbarrier源码阅读笔记","slug":"源码阅读/java/juc/同步工具/CyclicBarrier源码阅读笔记","date":"2018-11-08T16:00:00.000Z","updated":"2018-12-26T07:48:39.328Z","comments":true,"path":"2018/11/09/源码阅读/java/juc/同步工具/CyclicBarrier源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/11/09/源码阅读/java/juc/同步工具/CyclicBarrier源码阅读笔记/","excerpt":"CyclicBarrier是juc中的并发工具类之一，它的特点是使得多条线程约定一个共同的点，等到相关的线程全部到达这个点再继续往下进行。以参加旅行团为例，到达某个景点以后所有的游客自由活动两小时，大家约定在某个点集合，然后去下一个景点，那么导游必须要等所有的游客全部到达约定好的集合地点以后才能带着游客前往下一个景点。","text":"CyclicBarrier是juc中的并发工具类之一，它的特点是使得多条线程约定一个共同的点，等到相关的线程全部到达这个点再继续往下进行。以参加旅行团为例，到达某个景点以后所有的游客自由活动两小时，大家约定在某个点集合，然后去下一个景点，那么导游必须要等所有的游客全部到达约定好的集合地点以后才能带着游客前往下一个景点。 案例12345678910111213141516171819202122232425262728293031public class CyclicBarrierTest &#123; private static CyclicBarrier cyclicBarrier; static class CyclicBarrierThread extends Thread &#123; public void run() &#123; System.out.println(Thread.currentThread().getName() + \"到达\"); //等待 try &#123; int index = cyclicBarrier.await(); System.out.println(index + \"============\" + Thread.currentThread().getName()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; cyclicBarrier = new CyclicBarrier(5, new Runnable() &#123; @Override public void run() &#123; System.out.println(\"所有线程全部到达了....\"); &#125; &#125;); for (int i = 0; i &lt; 5; i++) &#123; new CyclicBarrierThread().start(); &#125; &#125;&#125; 运行结果:1234567891011Thread-1到达Thread-3到达Thread-2到达Thread-0到达Thread-4到达各线程全部到达了....0============Thread-43============Thread-21============Thread-04============Thread-12============Thread-3 源码分析主要流程CyclicBarrier中的字段1234567891011121314151617/** The lock for guarding barrier entry */private final ReentrantLock lock = new ReentrantLock();/** Condition to wait on until tripped */private final Condition trip = lock.newCondition();/** The number of parties */private final int parties;/* The command to run when tripped */private final Runnable barrierCommand;/** The current generation */private Generation generation = new Generation();/** * Number of parties still waiting. Counts down from parties to 0 * on each generation. It is reset to parties on each new * generation or when broken. */private int count; CyclicBarrier有两个构造函数123456789101112public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125; public CyclicBarrier(int parties) &#123; this(parties, null);&#125; 两个构造函数，根据源码可知下面只有一个参数的构造函数内部调用的也是上面双参数的构造函数。在上面的案例中使用的也是双参数的构造函数。 这里我们先来埋下一个问题: 为什么传入的Runnable实例会比我们在循环中生成的线程更早执行？ 下面我们带着这个问题来进入CyclicBarrier的源码 首先来解释一下构造函数中的parties和count12private final int parties;private int count; 在构造函数中我们可以看到，parties和count的初始化数量是相同的，那么它们的作用分别是什么呢？parties代表的是当前这个屏障所需要达到达到目标的总数量，它是不变的。count代表的是当前未到达目标的数量，实际上CyclicBarrier的使用中，各线程所修改的就是count这个变量。 以上面的案例作为例子，我们假设for循环中生成的五条线程分别为t1,t2,t3,t4,t5.假设五条线程的开始执行顺序为t1-&gt;t2-&gt;t3-&gt;t4-&gt;t5. 首先t1开始执行，输出Thread-1到达，然后执行await方法：1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; 可以看到await方法内部只是调用了dowait方法，这个dowait方法是非常重要的核心方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; //这里t1率先获取到锁，所以后续的线程会进入阻塞队列等待。 lock.lock(); try &#123; final Generation g = generation; if (g.broken) throw new BrokenBarrierException(); if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; int index = --count; if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // loop until tripped, broken, interrupted, or timed out for (;;) &#123; try &#123; if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // \"belong\" to subsequent execution. Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; //t1线程在释放锁以后会唤醒后继节点。 lock.unlock(); &#125;&#125; 我们先不考虑中断和Generation.brokent1线程进入这个方法以后，int index = –count; count的初始化值为5，index的值为4，然后就进入for循环内，因为传入的timed为false,所以会执行trip.wait，这个方法主要做了三件事:1.将当前线程加入到条件队列2.释放当前线程所持有的锁，全部！3.如果当前线程不在阻塞队列中，阻塞当前线程这里就不再对Condition做详细说明了。t1线程会在这里被阻塞起来加入到条件队列中并释放它所持有的全部的锁，它的锁释放以后，t2线程获取到锁，最终它和t1一样也被阻塞在这里，后续的t3,t4也是一样。最后t5线程获取到锁，t5到达以后，经过前面t1,t2,t3,t4的执行，再执行int index = –count，得到的index的值就是0了，这样下面这个if语句内的代码就会执行了：1234567891011121314if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) command.run(); ranAction = true; nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125;&#125; 首先，得到我们在构造函数内传入的Runnable实例，如果它不为空就执行它，到这里我们可以解答上面的问题了，到这里t1-t5的方法都没有执行，而runnable的方法率先被执行了，这就解答了为什么runnable方法比其他线程内的方法先执行。runnable方法执行以后，，还有一个比较重要的方法就是nextGeneration();方法1234567private void nextGeneration() &#123; // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation();&#125; 看到这里的trip.signalAll();整个流程基本就通了，这行代码会唤醒所有阻塞在条件队列中的线程，并把它们添加到阻塞队列的队尾。然后它们会在阻塞队列中一一出列并获取锁执行相应的逻辑。我们再回到dowait方法，线程在trip.await();这一步被阻塞，那么当线程被唤醒以后，都会继续往下执行。那么它如何退出这个for循环呢，注意下面这两行代码：12if (g != generation) return index; 在不考虑中断和超时的情况下，线程会在这一步就会退出for循环，那么generation是在什么时候发生变动的呢？往前看nextGeneration方法，在方法内的最后一行generation被重新赋值了。 到这里，所有的线程都从阻塞中被唤醒出来并且退出了for循环，可以继续执行接下来的逻辑了。 中断和超时中断CyclicBarrier的await方法是可以响应中断的，如果某个调用CyclicBarrier实例的线程在执行await方法期间发生了中断，那么它会响应中断，调用breakBarrier方法打断当前的CyclicBarrier实例,然后抛出中断异常。当前的CyclicBarrier实例被打断以后，其他的线程最终都会看到这次打断操作，然后抛出BrokenBarrierException.再来看看breakBarrier方法:12345private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll();&#125; 这个方法非常的简单，它做了三件事1.generation.broken = true; 这个赋值操作会被其他所有的线程感知到，其他的线程感知到这一步赋值以后，会抛出BrokenBarrierException2.count = parties; 将未获取到锁的线程的数量充值未初始值。3.trip.signalAll(); 这个操作比较重要，它会唤醒条件队列中所有的线程，并将它们一一加入到阻塞队列的队尾。然后它们会在阻塞队列中一一出列并获取锁然后往下执行，最终由于generation.broken = true而抛出BrokenBarrierException。 超时CyclicBarrier为使用者提供了超时策略，那么超时策略有什么不同呢？我们知道，在不采用超时策略的时候，调用await方法的线程都会进入阻塞状态，直到最后一条线程执行await方法，然后这些线程才会被唤醒继续执行接下来的逻辑，那么最后一个或者几个线程一直没有执行await方法，那么这些陷入阻塞状态的线程就会一直阻塞,这是我们所不希望看到的。而如果使用了可超时的方法，情况就完全不一样了。说到超时不得不提到一个await方法的重载方法，之前我们提到的await方法是无参的，而带有超时功能的await方法是有两个参数的123456public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout));&#125; 通过代码可知，CyclicBarrier中的两个await方法内部都是调用了dowait方法来实现的，在dowait方法中有一个for循环，这是一个死循环，循环中有这样一段代码1234if (!timed) trip.await();else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); 如果调用的是无参的await方法，那么这里的timed传入的就是false,然后进入第一个if体内进入阻塞状态，在达成条件之前一直阻塞不会。如果调用的是有参的await方法, 那么这里的timed传入的就是true,然后进入第二个if体内进入阻塞状态，但是这种阻塞是有时间限制的，只会在指定的时间范围内处于阻塞状态。如果在指定的时间内没能满足条件(其实就是调用await相关方法的线程数量不足),那么当前线程就会被主动唤醒，执行下面这段代码后当前CyclicBarrier被打断，所有阻塞中的线程被唤醒，然后一一抛出BrokenBarrierException，当前线程抛出TimeoutException。1234if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException();&#125; 总结","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"CountDownLatch源码分析","slug":"源码阅读/java/juc/同步工具/CountDownLatch源码阅读笔记","date":"2018-11-05T16:00:00.000Z","updated":"2018-12-26T07:48:39.319Z","comments":true,"path":"2018/11/06/源码阅读/java/juc/同步工具/CountDownLatch源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/11/06/源码阅读/java/juc/同步工具/CountDownLatch源码阅读笔记/","excerpt":"CountDownLatch的字面意思是倒计时门闩，我们可以把它理解为门闩，这个门闩把门给从内部锁上了，不把它打开外面的人就进不到屋里去。那么如何才能把它打开呢？等到倒计时结束它就自动打开了！ 以下CountDownLatch简称CDL","text":"CountDownLatch的字面意思是倒计时门闩，我们可以把它理解为门闩，这个门闩把门给从内部锁上了，不把它打开外面的人就进不到屋里去。那么如何才能把它打开呢？等到倒计时结束它就自动打开了！ 以下CountDownLatch简称CDL 案例我们先来看个demo1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class CountDownLacthTest &#123; public static void main(String[] args) &#123; CountDownLacthTest countDownLacthTest = new CountDownLacthTest(); countDownLacthTest.doWork(); &#125; public void doWork() &#123; int N = 10; CountDownLatch doneSignal = new CountDownLatch(N); Executor e = Executors.newFixedThreadPool(3); // 创建 10 个任务，提交给线程池来执行 for (int i = 0; i &lt; N; ++i) // create and start threads e.execute(new WorkerRunnable(doneSignal, i)); // 等待所有的任务完成，这个方法才会返回 try &#123; doneSignal.await(); // wait for all to finish System.out.println(\"=finish=\"); &#125; catch (InterruptedException e1) &#123; e1.printStackTrace(); &#125; &#125; class WorkerRunnable implements Runnable &#123; private final CountDownLatch doneSignal; private final int i; WorkerRunnable(CountDownLatch doneSignal, int i) &#123; this.doneSignal = doneSignal; this.i = i; &#125; @Override public void run() &#123; doWork(i); // 这个线程的任务完成了，调用 countDown 方法 doneSignal.countDown(); &#125; void doWork(int val) &#123; System.out.println(val); &#125; &#125;&#125; 在这个demo中，用一个3条线程的线程池去处理10个任务。这10个任务必须全部完成以后才能输出=finish=，否则线程会一直阻塞在await方法处。运行结果:0231547698=finish= 从运行结果可以看出，各个任务执行完成的顺序是不固定的，但是=finish=一定是最后输出。原因是在任务没有全部完成的时候，线程会一直阻塞在await方法处。 本文的重点是对CDL的源码进行分析，所以不会对它的用法做过度深究。 源码分析CDL的整个工作流程可分为三步第一步: 构造实例(获取同步状态)第二步: 阻塞第三部: 释放同步状态-解除阻塞 Sync内部类一个juc中非常常见的Sync内部类，继承了AQS类并实现了tryAcquiredShared方法和tryReleaseShared方法，前者是用来尝试共享式获取同步状态的，后者是用来尝试共享式释放同步状态的。通过这两个方法我们可以确定，CDL的特性是利用了AQS的共享式获取同步状态相关机制来实现的。123456789101112131415161718192021222324252627private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; //尝试共享式获取同步状态,返回值大于0说明同步状态获取成功 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; //尝试共享式释放同步状态,返回true说明同步状态已经全部释放成功 protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; &#125; 构造方法CDL只有一个构造方法1234public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count);&#125; 再来看看Sync的构造方法123Sync(int count) &#123; setState(count);&#125; 这两个构造方法都是比较简单的，这里我们可以看出，创建CDL实例的时候，构造方法中只做了一件事，就是将AQS底层的状态值修改为被传入的参数值，对应着上面demo中的任务数。这里可以把它理解为有count个任务分别获取了一个数量的共享同步状态，等到任务结束会将持有的同步状态释放掉。 阻塞CDL的阻塞通过调用await()方法或await(long,TimeUtil)来实现，这里先以await方法为例阐述阻塞的过程。123456789101112public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;//此方法位于AQS类public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; 通过源码可以看出，CDL的await方法实际上是调用了AQS的acquireSharedInterruptibly(int)方法，这个方法是用来进行可中断的获取共享同步状态的(这里暂时不考虑中断问题)，在第二个条件判断中，调用tryAcquireShared方法进行了一次获取共享同步状态的尝试，这个方法在AQS中是一个抽象类，CDL中的Sync内部类对其进行了实现：123protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; tryAcquireShared方法实现的非常简单，这个方法出现的本意是为了处理获取共享同步状态的逻辑，乍一看这里的实现似乎与获取同步状态没有一关系，仔细想想确实没有关系，但是在这里，这个设计真的是非常的巧妙。其实刚刚看构造函数的时候已经说过了，获取同步状态这一步已经在构造实例的时候完成了，那么这里的实现这个方法的作用其实就是返回是否还有同步状态未被释放.这里会有两个情况:1.在调用await方法的时候所有的同步状态已经全部释放2.在调用await方法的时候所有的同步状态没有全部释放 如果是第一种情况呢，tryAcquireShared方法会返回1，再看看上面的acquireSharedInterruptibly方法，因为条件判断不通过，所以这个方法就执行完了，这样await方法也就顺利的执行完了，中间不会出现阻塞的情况。 那么第二种情况呢，tryAcquireShared方法会返回-1，这样会接着执行doAcquireSharedInterruptibly(arg)方法1234567891011121314151617181920212223242526private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; //封装一个新的节点进入阻塞队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 接下来我们来看一下doAcquireSharedInterruptibly这个方法。首先，封装一个共享模式的节点，进入阻塞队列，这个比较简单了,就是先尝试入列，入列失败就循环入列直到成功为止123456789101112131415161718192021222324252627282930313233private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125;private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize //如果尾节点为空，那么头结点也为空，整个阻塞队列就是一个空队列 //创建一个默认的节点作为头结点 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 然后呢，就是进入一个死循环在循环中获取到刚刚创建的新节点的前置节点，然后判断该前置节点是否为头结点，只有在前置节点为头结点的情况下，当前节点才有可能去竞争同步状态。接着调用tryAcquireShared方法，因为此时任务还没有全部完成，所以同步状态没有被全部释放，所以这里的返回值为-1。因为未能满足这里的的if条件，所以只能继续往下执行。shouldParkAfterFailedAcquire(p, node)方法是用来判断当前节点线程是都应该阻塞的parkAndCheckInterrupt()方法是用来阻塞线程，等到被唤醒以后返回中断状态的。123456789101112131415161718192021222324private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) return true; if (ws &gt; 0) &#123; do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; AQS中的阻塞队列中每一个新节点的waitStatus默认为0，所以每个节点在第一次进入shouldParkAfterFailedAcquire方法时会将新节点的waitStatus置为Node.SIGNAL，然后第二次进入的时候第一个if条件判断出会结束整个方法，返回true,然后调用parkAndCheckInterrupt方法将线程阻塞在这里。 释放同步状态-解除阻塞CDL中的释放同步状态和解除阻塞是通过countDown方法来实现的，countDown方法每一次调用都会释放1个数量的同步状态，等到将全部的同步状态释放完毕，AQS中state为0的时候，就会去唤醒头结点的后继节点，然后将后继节点设置为头结点。并将此行为传播下去，直至所有的节点全部被唤醒。1234567891011public void countDown() &#123; sync.releaseShared(1);&#125;public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 这里的tryReleaseShared方法是有Sync内部类来实现的123456789101112 protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125;&#125; 可以看到，tryReleaseShared每一次调用都会对state进行减1的操作，等到state==0即同步状态全部释放以后才会返回true。再回到刚刚的releaseShared方法，等到全部的同步状态都被释放完毕，开始执行doReleaseShared方法。123456789101112131415161718192021private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases //这里会唤醒后继节点，同时被唤醒的后继节点会继续唤醒它的后继节点，就这样一直将所有的节点全部唤醒 unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; //这里如果刚好有新的节点入列，那么它的waitStatus就会被修改为Node.SIGNAL(-1)，所以这里有可能会执行失败。 !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; //这里如果被唤醒的后继节点没有成为新的头结点，就继续循环，否则就退出循环 if (h == head) // loop if head changed break; &#125;&#125;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"ReentrantLock源码阅读笔记","slug":"源码阅读/java/juc/锁/ReentrantLock源码阅读笔记","date":"2018-10-31T16:00:00.000Z","updated":"2018-12-26T07:48:39.346Z","comments":true,"path":"2018/11/01/源码阅读/java/juc/锁/ReentrantLock源码阅读笔记/","link":"","permalink":"www.hlblogs.com/2018/11/01/源码阅读/java/juc/锁/ReentrantLock源码阅读笔记/","excerpt":"ReentrantLock是juc提供的一种可重入的互斥锁，对于不同线程来说，它是互斥的，同一时间只可能有一个线程获取到锁，其他的企图获取锁的线程都将阻塞起来等待持有锁的线程释放锁。对于同一线程来说，它是可重入的，同一个线程能够多次获取到同一把锁，只是在释放的时候需要将线程获取到的全被重入锁都释放掉才算是释放完成。","text":"ReentrantLock是juc提供的一种可重入的互斥锁，对于不同线程来说，它是互斥的，同一时间只可能有一个线程获取到锁，其他的企图获取锁的线程都将阻塞起来等待持有锁的线程释放锁。对于同一线程来说，它是可重入的，同一个线程能够多次获取到同一把锁，只是在释放的时候需要将线程获取到的全被重入锁都释放掉才算是释放完成。 获取独占锁1.调用Lock方法加锁123456789final void lock() &#123; //CAS尝试抢占独占锁 if (compareAndSetState(0, 1)) //如果抢占成功，将本线程设置为独占锁持有线程 setExclusiveOwnerThread(Thread.currentThread()); else // 2.如果抢占失败，调用AQS的acquire方法 acquire(1);&#125; 2.调用AQS的acquire方法123456789public final void acquire(int arg) &#123; // 2.1调用tryAcquire方法尝试获取锁，此方法AQS未实现，留给子类实现 // ReentrantLock中的FairLock和NonFairLock均对它进行了实现 if (!tryAcquire(arg) &amp;&amp; // 2.2 addWaiter方法将当前线程封装成一个节点加入CLH队列 // 2.3 调用acquireQueue方法循环获取锁，如果线程需要阻塞，就阻塞线程，此方法位于AQS类中 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 2.1 尝试获取锁调用tryAcquire方法尝试获取锁，此方法AQS未实现，留给子类实现，ReentrantLock中的FairLock和NonFairLock均对它进行了实现，这里以NonFairLock中的实现为例1234567891011121314151617181920212223242526272829protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;//nonfairTryAcquire类位于ReentrantLock中的内部类Syncfinal boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); //获取加锁状态 int c = getState(); //加锁状态为0说明此时并没有任何线程持有锁 if (c == 0) &#123; //尝试抢占锁 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; //如果已经有线程持有了锁，检查持有锁的线程是否是当前线程 else if (current == getExclusiveOwnerThread()) &#123; //如果持有锁的线程就是当前线程，锁重入，返回true,获取成功 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; //如果锁已经被持有并且持有锁的线程不是当前线程，返回false，本次获取锁失败 return false; &#125; 2.2 调用addWaiter方法将当前线程封装成一个节点加入CLH队列，此方法位于AQS类中123456789101112131415161718private Node addWaiter(Node mode) &#123; //这里的mode参数为AQS.Node类中的Node.EXCLUSIVE，这是一个Node引用，用来标识当前节点处于独占模式 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure Node pred = tail; if (pred != null) &#123; node.prev = pred; //尝试将本次生成的新节点设置为新的尾节点，如果设置成功，说明新节点入队成功 if (compareAndSetTail(pred, node)) &#123; //新节点入队成功以后，将前置节点的后置节点设置为本次生成的新节点，然后将新节点返回。 pred.next = node; return node; &#125; &#125; // 2.2.1 如果尾节点为空，或者新节点未能成功设置为新的尾节点，调用enq方法循环操作，直至成功为止。 enq(node); return node; &#125; 2.2.1 如果尾节点为空，或者新节点未能成功设置为新的尾节点，调用enq方法循环操作，直至成功为止，此方法位于AQS类中。1234567891011121314151617181920private Node enq(final Node node) &#123; //这是一个死循环，只有将节点成功加入阻塞队列中才有可能退出 for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize //如果尾节点为空，就生成一个新的节点，将它设置为头结点，一般来说，头结点和尾节点要么都为空，要么都不为空 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //如果尾节点不为空， node.prev = t; //尝试将参数中传过来的节点（也就是本次生成的新节点）设置为新的尾节点，如果设置成功，说明新节点入队成功 if (compareAndSetTail(t, node)) &#123; t.next = node; //新节点入队成功以后，将前置节点的后置节点设置为本次生成的新节点，然后将新节点返回。 return t; &#125; &#125; &#125; &#125; 2.3 调用acquireQueue方法循环获取锁，如果线程需要阻塞，就阻塞线程，此方法位于AQS类中这个方法内部是一个死循环，只有获取锁以后才能退出这个循环，所以当该方法执行完毕以后，当前线程一定是成功持有锁的123456789101112131415161718192021222324252627final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取节点的前置节点 final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; //tryAcquire方法参考步骤2.1 //如果该节点的前置节点是头结点，并且该节点成功获取锁，将该节点设置为头结点 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; //2.3.1 调用shouldParkAfterFailedAcquire方法判断节点的线程是否需要阻塞 //此方法最多只会在第一次调用时返回false if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //2.3.2 如果该节点线程需要阻塞，调用parkAndCheckInterrupt方法阻塞线程 parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 这里来说明一下上面代码里关于头结点的判断，也就是if (p == head &amp;&amp; tryAcquire(arg))这里为什么要先判断是否是头结点呢？对于阻塞队列中的任何一个节点来说，只有它的前置节点是头结点，它才有可能获取到锁，这与当前锁是公平锁还是非公平锁无关，只要进了阻塞队列，全都得按顺序来。 2.3.1 调用shouldParkAfterFailedAcquire方法判断节点的线程是否需要阻塞，此方法位于AQS类中1234567891011121314151617181920private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) //如果前置节点的后置节点等待状态已经设置为SIGNAL，即需要被唤醒，那么就可以放心的将当前节点的线程阻塞， //等到前置节点释放锁时会唤醒当前线程 return true; if (ws &gt; 0) &#123; //如果前置节点的后置节点等待状态值大于0，说明节点已经取消获取锁的操作，就将该节点的前置节点设置为前置节点的前置接节点 //直到找到一个未取消的前置节点。 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //如果前置节点的后置节点状态即不等于SIGNAL(-1),也不大于0，就将它设置为signal(-1) //这个waitStatus默认都是0 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125; 2.3.2 如果该节点线程需要阻塞，调用parkAndCheckInterrupt方法阻塞线程，此方法位于AQS类中123456private final boolean parkAndCheckInterrupt() &#123; //阻塞当前线程 LockSupport.park(this); //线程被唤醒后返回中断状态 return Thread.interrupted(); &#125; 加锁过程的总结：在ReentrantLock中，当某个线程请求获取非公平锁的时候，会立即进行一次抢占尝试，如果没能抢到锁，会再次进行一次尝试，但是这第二次尝试有一个前提，那就是锁并没有被任何线程持有。如果已经被某个线程持有了，就不会进行第二次的抢占尝试，而是会去判断当前线程是否就是持有锁的那个线程，如果恰好是当前线程持有锁，那么就进行一次锁重入的操作，本次获取锁成功。如果当前线程并不是持有锁的线程，那么本次获取锁就失败了。本次获取锁失败以后，就把当前线程及锁类型信息（独占式还是共享式，ReentranLock中默认是独占式）封装成一个节点，加入到CLH队列中。新的节点加入到队列以后，检测尾节点存不存在，如果存在，会循环尝试把新节点设置为新的尾节点，设置成功以后开始一个死循环，把新节点的前置节点的waitStatus（相当于该节点的后继节点的等待状态，默认0）设置为signal(-1),设置完以后新节点线程进入阻塞状态，当新节点的前置节点释放锁以后会根据waitStatus来唤醒这个新节点。等到新节点被其前置节点唤醒以后（此时其前置节点就是头结点），新节点会再次开始循环尝试获取锁，直到获取成功为止。 公平锁的获取过程和非公平锁区别不大，非公平锁获取锁的过程会有两次抢占，第一次抢占是非公平锁独有的，公平锁中不存在这次操作。第二次抢占公平锁也同样会有，但是非公平锁的抢占只要当前锁没有被持有就会进行，而公平锁除了要判断当前锁有没有被持有之外，还要判断此时阻塞队列中有没有节点正在排队，如果有节点正在排队，那么就不会进行这一次抢占，乖乖到队列之后去排队。不管是公平锁还是非公平锁，在抢占锁失败以后，都会进入阻塞队列，这以后的操作时一样的。 释放锁释放锁的过程非常简单：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void unlock() &#123; sync.release(1); &#125;//此方法位于AQS类public final boolean release(int arg) &#123; //尝试释放锁 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //唤醒后继节点 unparkSuccessor(h); return true; &#125; return false; &#125;//尝试释放锁，因为锁是可重入的，所以必须得要线程所持有的全部锁都释放以后才会返回true。protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; //当前线程是否为持有锁的线程，如果不是，将会抛出异常 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125;//唤醒后继节点。。。此方法位于AQS类 private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) //如果有后继节点线程存在，将它唤醒 LockSupport.unpark(s.thread); &#125; 解锁过程的总结：不管是公平锁还是非公平锁，解锁的过程几乎都是一样的，先释放锁，释放成功以后唤醒后继节点就完了。 整个独占锁的获取和释放的过程就是这样了，但是使用这种方式获取锁对中断和获取时间是不敏感的，也就是说这种方式不会响应中断，也没会超时，在获取到锁之前线程会一直处于阻塞队列中直到获取成功为止。 响应中断的获取锁调用ReentrantLock中的 lockInterruptibly方法12345678910111213141516171819202122232425262728293031323334353637 public void lockInterruptibly() throws InterruptedException &#123; sync.acquireInterruptibly(1); &#125; //此方法位于AQS类 public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg); &#125;//此方法位于AQS类private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //此方法在线程被唤醒以后会返回中断状态，详情可参考2.3.2 parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; 根据代码可以看出，响应中断的获取锁并没有什么大的不同，与前面获取锁的方式相比，仅仅有两个不同一. 在尝试获取锁之前先判断中断状态，如果该线程已经被中断，则抛出中断异常，停止获取锁。二. 在线程的阻塞过程中，如果该线程被中断了，那么在线程被唤醒以后，将会抛出中断异常，然后取消获取锁。 超时的获取锁超时的获取锁在原本阻塞是获取锁的方式上增加了一个超时时间，就是说它如果没有获取到锁不会一直阻塞在阻塞队列中，而是会在到达超时时间以后就放弃获取锁，本次获取锁失败。与此同时，这种方式也是会响应中断的，如果在获取锁的过程中线程被中断了，那么线程会抛出中断异常，然后取消获取锁。ReentrantLock中提供了tryLock(long,TimeUtil)方法来超时的获取锁。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123; //参数一：时间数值 参数二：时间单位 //将传入的参数统一转换为纳秒来进行处理 return sync.tryAcquireNanos(1, unit.toNanos(timeout));&#125;//此方法位于AQSpublic final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; //响应中断 if (Thread.interrupted()) throw new InterruptedException(); //tryAcquire方法获取锁 ，doAcquireNanos方法超时的获取锁 return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125;//此方法位于AQSprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; //计算出超时时间 final long deadline = System.nanoTime() + nanosTimeout; //生成新的节点并加入到阻塞队列中 final Node node = addWaiter(Node.EXCLUSIVE); //用于判断是否取消获取锁 boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; //计算超时的剩余时间 nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) //指定时间内阻塞 LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) //响应中断，抛出中断异常 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) //取消获取锁 cancelAcquire(node); &#125;&#125; 从上面代码可以看出，超时的获取锁还是比较容易理解的，只是在自旋的时候加入对超时时间的判断，如果已经到达了超时时间，就退出自旋状态，本次获取锁失败。还有一个不同就是关于线程阻塞，这种方式获取锁也可能会阻塞线程，但是不会一直阻塞下去，这里的阻塞计算没有其他线程来唤醒被阻塞的线程，也会在指定的时间内自我唤醒。 取消获取锁前面对ReentrantLock中锁的获取和释放做了一定的说明，下面再来说说取消获取锁这个操作。取消获取锁其实就相当于将原本成功进入阻塞队列的节点取消入队，那么它一般会在什么场景下发生呢？1.程序有Bug,被动抛出异常2.响应中断，主动抛出中断异常仔细观察阻塞获取锁，中断获取锁，超时获取锁这三种获取方式的代码，会发现使用这三种方式获取锁的时候都会涉及到下面这段代码123456try &#123; ...&#125; finally &#123; if (failed) cancelAcquire(node);&#125; cancelAcquire方法就是用来取消获取锁的1234567891011121314151617181920212223242526272829303132333435private void cancelAcquire(Node node) &#123; // Ignore if node doesn't exist if (node == null) return; node.thread = null; // Skip cancelled predecessors Node pred = node.prev; while (pred.waitStatus &gt; 0) node.prev = pred = pred.prev; Node predNext = pred.next; node.waitStatus = Node.CANCELLED; // If we are the tail, remove ourselves. if (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123; compareAndSetNext(pred, predNext, null); &#125; else &#123; // If successor needs signal, try to set pred's next-link // so it will get one. Otherwise wake it up to propagate. int ws; if (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= 0 &amp;&amp;compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != null) &#123; Node next = node.next; if (next != null &amp;&amp; next.waitStatus &lt;= 0) compareAndSetNext(pred, predNext, next); &#125; else &#123; unparkSuccessor(node); &#125; node.next = node; // help GC &#125;&#125;","categories":[{"name":"java源码阅读笔记","slug":"java源码阅读笔记","permalink":"www.hlblogs.com/categories/java源码阅读笔记/"}],"tags":[{"name":"juc","slug":"juc","permalink":"www.hlblogs.com/tags/juc/"}]},{"title":"SpringCloud优化","slug":"springcloud/SpringCloud优化","date":"2010-01-10T16:00:00.000Z","updated":"2019-01-14T01:36:11.614Z","comments":true,"path":"2010/01/11/springcloud/SpringCloud优化/","link":"","permalink":"www.hlblogs.com/2010/01/11/springcloud/SpringCloud优化/","excerpt":"SpringCloud优化记录。","text":"SpringCloud优化记录。 核心服务性能优化接口的响应速度不能太慢，一般200ms以内返回是比较好的，如果某个接口的响应速度过慢，那么它是无法应对高并发的场景的。如果接口响应时间比较慢，那么要想尽一切办法，来提高响应速度: 代码优化: 包括业务和技术两方面 sql语句优化: 尽量避免又臭又长的大sql，最好是只采用简单的单表查询。 数据库优化: 加索引，索引优化 缓存: ehcache、redis等等 超时时长的设置为了避免超时的情况发生，很多人会把SpringCloud中的超时时间设置的比较大，这样的确可以在一定程度上避免超时的情况，但是调高超时时间可能会导致大量的线程被占用，导致后续请求没有线程来处理，使得接口的响应速度急剧下降。超时时长一般设置1s比较合理。如果设置成1s的接口频繁超时，那么就要考虑优化那个接口了。 失败重试的设置将SpringCloud中的超时时长设置成1s好像没什么问题了，但是在网络抖动的情况下，很有可能导致接口的响应时间超过1s，这个时候应该怎么办呢?总不能等待用户刷新产生新的请求吧? 所以该有的重试还是需要设置的。这个重试一般是配合着超时时长来做的,如果某次请求失败了，就进行一次重试，如果重试依然失败，就换一台机器进行再次重试:123456ribbon: ConnectionTimeout: 1000 ReadTimeout: 1000 OkToRetryOnAllOperations: true MaxAutoRetries: 1 MaxAutoRetriesNextServer: 1 接口的幂等性所谓接口的幂等性，就是说这个接口无论被访问多少次，产生的结果都是唯一的，比如一个更新请求在特殊情况下，比如上面的重试，发送了两次，那么接口必须保证只有一次能成功。常见的方案有: 利用数据库唯一索引来保证幂等性 通过在redis中设置唯一id来保证幂等性","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"www.hlblogs.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"www.hlblogs.com/tags/SpringCloud/"}]}]}