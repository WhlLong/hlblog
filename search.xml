<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>关于String的一点思考</title>
      <link href="/hlblog/2019/01/24/java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EString%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/hlblog/2019/01/24/java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8EString%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>对String的一些思考: 包括String的不可变性、String对‘+’的处理、String.valueOf和Integer.toString的区别、几种不同的String创建方式的区别等等。</p><a id="more"></a><h1 id="String的不可变性"><a href="#String的不可变性" class="headerlink" title="String的不可变性"></a>String的不可变性</h1><p>String是不可变、不可继承的，这点是众所周知的，因为它是被final修饰的(这里不对final做过多的解释)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        <span class="comment">//String源码省略。。。。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么为什么要把它涉及成不可变的呢？</p><ol><li><p>出于设计考虑，字符串常量池的需要<br>对于常量来说，重复创建是比较浪费资源且没有必要的，同一个字符串常量，只需要在常量池中创建一个就够了，如果其他地方需要这个字符串常量，那么它只需要引用原来常量池中的那一个就够了。</p></li><li><p>处于效率优化考虑<br>因为String是不可变的，所以String中的hash码也是不变的，这样就不用每一次使用的时候都去计算新的hash值。同时，因为它的hash值是不变的，它才能够在HashSet、HashMap等容器中不出问题。假如它的hash值是可变的，那该多尴尬，你计算了一个Stirng类型的key的hash值，将key和value保存在HashMap中了，然后它被修改了，新的hash值与原来不同了，那么再以这个String作为key去存取数据，结果必然是有问题的。</p></li><li><p>处于安全性考虑<br>String在非常多的类中被用来当做参数，同时它还被用来保存配置信息，如果它是可变的，那么势必会带来一些隐蔽性很高的隐患。</p></li></ol><p>处于上面这几点我们暂且认为这样设计非常好，但是为什么不把所有的类都设计成不可变的呢，毕竟它安全，效率又高？<br>如果将所有的类都设计成不可变的，那么每一次的修改都会创建一个新的实例，这样性能就很低。同时，大量的实例产生背后是大量的实例等待回收，垃圾回收的任务太重，也会降低系统性能。<br>一般来说我们在使用HashSet和HashMap这类容器的时候不太会用String之外的类实例来作为key，所以基本上就不需要确保hash值的唯一性。</p><h1 id="String对‘-’的处理"><a href="#String对‘-’的处理" class="headerlink" title="String对‘+’的处理"></a>String对‘+’的处理</h1><p>由于String类被设计成不可变的，所以String对象的每一次的修改都会创建一个新的String实例。对于‘+’的处理分为两种情况:<br>第一种就是类似于String str1 = “abc”+”def”这种情况，这里设计到java编译器的一个优化手段，那就是”abc”是String常量,”def”也是一个String常量，所以在编译期间它们就会被合成一个字符串”abcdef”，然后放入字符串常量池中。<br>第二种呢就是类似于String str2 = str1 + “def”这种情况，这里的str1是一个String变量，它是不确定的，这里的str1+”def”不会有有上面的编译期优化出现，也不会被主动放进字符串常量池中。</p><h1 id="String-valueOf和Integer-toString的区别"><a href="#String-valueOf和Integer-toString的区别" class="headerlink" title="String.valueOf和Integer.toString的区别"></a>String.valueOf和Integer.toString的区别</h1><p>String.valueOf有很多个重载方法，其中形参为int类型的重载方法内部调用的的就是Integer.toString,代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而Integer.toString方法最终使用的是new String的方式。<br>如果想将一个int类型的变量转化成字符串，那么使用String.valueOf和Integer.toString是没有区别的。但是如果使用int+””这种形式，区别就比较大了，因为这种方式底层使用的是StringBuilder。</p><h1 id="几种不同的String创建方式的区别"><a href="#几种不同的String创建方式的区别" class="headerlink" title="几种不同的String创建方式的区别"></a>几种不同的String创建方式的区别</h1><p>比较常见的String实例创建方式有:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span> + <span class="string">"def"</span>;  <span class="comment">//常量+常量</span></span><br><span class="line">String str2 = str1 + <span class="string">"ghi"</span>;   <span class="comment">//变量+常量  或  变量+变量</span></span><br><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">"abcdefghi"</span>);  <span class="comment">//使用new关键字</span></span><br><span class="line">String str4 = String.valurOf(<span class="number">666</span>);      <span class="comment">//使用valueOf</span></span><br></pre></td></tr></table></figure></p><p>常量+常量 :  这种创建方式，编译器会在编译期将多个常量合成一个，放入字符串常量池中，最后str1引用的是字符串常量池中的那个地址。<br>变量+常量 :  这种创建方式，不会被优化，在运行期它的值才会被确定下来，并且它是不会被放入字符串常量池中的。<br>new关键字 :  字符串参数的处理同上面的两种情况，这里还有一个不同就是new关键字会在堆内存中再创建一个String实例，所以使用new关键字实际上相当于创建了两个实例，一个在堆内存中，一个在字符串常量池中。<br>valueOf  : valueOf的创建形式内部还是使用了new关键字。</p><h1 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h1><p>intern方法的用户只有一个，那就是在运行时将字符串放入字符串常量池中并返回常量池中的那个地址。具体的情况我下面会举例。</p><h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><p>来看几道笔试题吧<br>一:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abc"</span>;</span><br><span class="line">String str2 = <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">System.out.println(str1 == str2);</span><br><span class="line"></span><br><span class="line">String str3 = <span class="string">"ab"</span>;</span><br><span class="line">String str4 = <span class="string">"abc"</span>;</span><br><span class="line">String str5 = str3 + <span class="string">"c"</span>;</span><br><span class="line">System.out.println(str4 == str5);</span><br></pre></td></tr></table></figure></p><p>输出结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>str1被创建时因为”abc”是常量，所以它在编译期就被放入了常量池中，str1引用的是常量池中的地址<br>str2被创建时因为”a”、”b”、”c”都是常量，所以在它们会被优化成一个常量”abc”放入到常量池中，但是因为常量池中已经有一个”abc”了，所以会直接返回这个常量的地址，也就是str1引用的那个地址，所以str1 == str2为.<br>对于str4和str5来说，str4引用的是常量池中的地址，但是由于str3是变量，所以str5应用的地址并不是常量池中的”abc”的地址，所以str4 == str5结果为false.</p><p>二 :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">String str2 = <span class="string">"a"</span>;</span><br><span class="line">String str3 = <span class="keyword">new</span> String(sss+<span class="string">"b"</span>);</span><br><span class="line">System.out.println(str3.intern() == str3);</span><br><span class="line"></span><br><span class="line">String str4 = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>).append(<span class="string">"def"</span>).toString();</span><br><span class="line">System.out.println(str4.intern() == str4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String str5 = <span class="keyword">new</span> StringBuilder(<span class="string">"abc"</span>).append(<span class="string">"def"</span>).toString();</span><br><span class="line">System.out.println(str5.intern() == str5);</span><br></pre></td></tr></table></figure></p><p>输出结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>“abcd”在编译期会被放入到字符串常量池中，所以str1.intern实际返回的是”abcd”在常量池中的地址,而str1是存在于堆内存中的，所以str1.intern()==str1结果为false<br>str3.intern()这个操作会把str3放入到字符串常量池中，然后返回str3的地址，所以str3.intern() == str3结果为true<br>str4.intern()==str4结果为true的原理和上面str3.intern() == str3结果为true的原理是一样的<br>str5.intern()将str5放入字符串常量池，但是因为str4已经被放入常量池中了，所以这里返回的其实是str4的地址，所以str5.intern() == str5结果为false。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于int类型取值范围的一点思考</title>
      <link href="/hlblog/2019/01/03/java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8Eint%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/"/>
      <url>/hlblog/2019/01/03/java%E5%9F%BA%E7%A1%80/%E5%85%B3%E4%BA%8Eint%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>java中int类型占四个字节，32位的，如果是有符号的数，那么四个字节能表示的范围-2147483648（-2^31） ~ 2147483647 （2^31-1），<br>如果是无符号数，那么四个字节能表示的范围是0–4294967295(2^32-1)。<br>java中没有有符号和无符号的说法，都是取有符号的这种情况，所以在java中int类型的取值范围是-2147483648 ~ 2147483647，即-2^31 ~ 2^31-1。但是这个范围的底层原理是什么呢？下面讲一讲我的思考过程。</p><a id="more"></a><p>int类型的最大值是2^31-1比较好理解，在java中，int类型转换为二进制数据的第一个位代表正负，0为正，1为负。所以int类型的最大值的二进制文件应该是 0111 1111 1111 1111 1111 1111 1111 1111。 转换为10进制int类型为 2^0 + 2^1 + 2^2 + 2^3 + … + 2^30 = 2^31 - 1。</p><p>int类型的最小值是-2^31,关于这个最小值，我钻了牛角尖，简单的以后最小值应该是 -(2^31-1),即-2147483647，但是事实上却是-2^31，即-2147483648。后来冥思苦想了很久才从牛角尖中钻出来，觉得十分有必要记录一下。</p><p><strong>错误的思路:</strong><br>我为什么钻了牛角尖，刚刚说到，int类型的最大值转换为二进制为 0111 1111 1111 1111 1111 1111 1111 1111，然后又讲到二进制位的第一个位代表正负，0为正，1为负，所以最小值的表示应该是1111 1111 1111 1111 1111 1111 1111 1111，即 -(2^31-1)，看起来合情合理，所以我钻进了牛角尖。当然这也反映出我的基础还有待加强。</p><p><strong>正确的思路:</strong><br>为什么上面这种思路是错误的呢？因为计算机中的负数根本就不是那么表示的(汗，大学的时候学过的，全都还给老师了。)<br>在计算机中，所有的负数都是用补码去表示的。这里顺带提一下二进制数中的原码，反码和补码。</p><p>原码:<br>int类型直接转换成二进制数就是原码，比如8的二进制为 0000 0000 0000 0000 0000 0000 0000 1000。</p><p>反码:<br>将原码全部取反就得到了反码，比如上面8的二进制反码为 1111 1111 1111 1111 1111 1111 1111 0111</p><p>补码:<br>将反码+1,得到的就是补码,比如8的二进制补码为 1111 1111 1111 1111 1111 1111 1111 1000</p><p>因为正整数的首位必须要是0，所以一个32位的二进制数，能够表示数值的，只能是后面的31位，而负整数的首位是1，这个1呢，它不能完全按照符号位来理解，它也是可以参与数值的表示的。<br>比如int类型的最大值2^31-1，二进制为 0111 1111 1111 1111 1111 1111 1111 1111，<br>所以它的反码为1000 0000 0000 0000 0000 0000 0000 0000，<br>它的补码为1000 0000 0000 0000 0000 0000 0000 0001。</p><p>那么-(2^31-1)即-2147483647的二进制表示应该就是1000 0000 0000 0000 0000 0000 0000 0001，<br>补码再减1，就是1000 0000 0000 0000 0000 0000 0000 0000，即十进制中的-2147483648，也就是-2^31。<br>仔细看看-2^31的补码,首位为1，这个时候的首位，其实同时充当了符号位和数值位，以上面-(2^31-1)的补码为例，首位是1，所以这是一个负数，并且由于首位是1，所以首位代表的数为-2^31，同时，最后一位是1，所以应该再加上1，即-2^31+1。</p><p>所以，二进制中补码的规则，可以看成是-2^(长度-1) + (除首位以外的值的和)，比如-1的二进制表示为 11111111111111111111111111111111，<br>它就可以看成是 -2^31 +（2^31-1） = -1。</p><p>这样一来为什么int类型的最小值为-2^31就彻底搞明白了。</p><p><strong>int类型溢出</strong><br>我们都知道，Integer.MAX_VALUE + 1或者是Integer.MIN_VALUE-1都会产生溢出，Integer.MAX_VALUE+1=Integer.MIN_VALUE,Integer.MIN_VALUE-1=Integer.MAX_VALUE。<br>只要想明白了上面的二进制表示问题，溢出的原因就很好解释了。</p><p>Integer.MAX_VALUE的二进制表示为 01111111111111111111111111111111，再加1的话就会变成1000 0000 0000 0000 0000 0000 0000 0000，这也就是Integer.MIN_VALUE的二进制值。  </p><p>Integer.MIN_VALUE的二进制表示为 1000 0000 0000 0000 0000 0000 0000 0000,再减去1的话就会变成 01111111111111111111111111111111，这也就是Integer.MAX_VALUE的二进制值。</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最大堆与最小堆</title>
      <link href="/hlblog/2018/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%A0%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%A0%86(writing)/"/>
      <url>/hlblog/2018/12/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%9C%80%E5%A4%A7%E5%A0%86%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%A0%86(writing)/</url>
      
        <content type="html"><![CDATA[<p>常用的最大/小堆其实就是一颗完全二叉树。<br>除了完全二叉树所具有的基本特性以外，最大/小堆还有以下特性:<br>1.最大堆父节点一定大于子节点，最小堆父节点一定小于子节点。<br>2.因为是完全二叉树，所以一般用数组来表示，如果某个节点的节点位置在下标n处，那么其左孩子节点为：<font color="red">2 <em> n + 1</em></font> ，其右孩子节点为<font color="red">2  (n + 1)</font>，其父节点为<font color="red">(n – 1) / 2</font> 处。 </p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PriorityBlockingQueue源码阅读笔记</title>
      <link href="/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/PriorityBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/PriorityBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>PriorityBlockingQueue源码阅读笔记<br>PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，因为使用了可重入锁，所以它是线程安全的。<br><a id="more"></a></p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的数组容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层数组的最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用来存储数据的底层数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中数据的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较器，如果队列使用成员数据的自然排序规则，则此比较器为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁，保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件队列，用于队列中无数据时的线程阻塞</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Spinlock for allocation, acquired via CAS.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//自旋锁，通过CAS获取</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br></pre></td></tr></table></figure><h1 id="生产数据"><a href="#生产数据" class="headerlink" title="生产数据"></a>生产数据</h1><p>PriorityBlockingQueue提供了off(E),add(E),put(E)三个方法实现数据的入列。</p><p>offer(E):boolean<br>因为PriorityBlockingQueue是一个无界队列，所以这个方法永远不会返回false，它可以一直添加成功，直到内存爆掉。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        <span class="comment">// 如果当前队列中的元素数量大于等于底层数组的长度，就需要扩容了</span></span><br><span class="line">        <span class="comment">// 根据既定的扩容规则扩容以后，如果依然未能满足需求，那就继续进行扩容操作。</span></span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//数据入列，并且通过自然排序比较来维持二叉堆的结构</span></span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//数据入列，通过指定的比较器来实现维持二叉堆的结构</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>add(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put(E):void<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//因为PriorityBlockingQueue是一个无界队列，所以这里永远不需要阻塞</span></span><br><span class="line">    offer(e); </span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 扩容</span><br><span class="line">PriorityBlockingQueue底层存储数据使用的是数组结构，当数组空间被使用完毕以后，就需要对数组进行扩容操作。</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryGrow</span><span class="params">(Object[] array, <span class="keyword">int</span> oldCap)</span> </span>&#123;</span><br><span class="line">    lock.unlock(); <span class="comment">// must release and then re-acquire main lock</span></span><br><span class="line">    Object[] newArray = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, allocationSpinLockOffset,</span><br><span class="line">                                    <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//计算出一个新的容量</span></span><br><span class="line">            <span class="comment">//如果旧的数组容量小于64 则新的容量 = 旧的容量 + (旧的容量 + 2)</span></span><br><span class="line">            <span class="comment">//如果旧的数组容量大于等于64，则新的容量 = 旧的容量 + (旧的容量 &gt;&gt; 1)</span></span><br><span class="line">            <span class="keyword">int</span> newCap = oldCap + ((oldCap &lt; <span class="number">64</span>) ?</span><br><span class="line">                                    (oldCap + <span class="number">2</span>) : </span><br><span class="line">                                    (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">//通过上面的方式计算出来的容量可能会超出int类型所能表示的上限，</span></span><br><span class="line">            <span class="comment">//如果新的容量已经超出了限制 并且 旧的容量已经达到了上限，抛出异常</span></span><br><span class="line">            <span class="comment">//如果新的容量已经超出了限制 并且 旧的容量未达到上限，则新的容量等于int类型上限</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">                <span class="keyword">int</span> minCap = oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据上面计算出的新的容量，创建一个新的数组实例</span></span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                newArray = <span class="keyword">new</span> Object[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果有其他的线程已经处于扩容阶段，则此线程重新参与竞争锁</span></span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="keyword">null</span>) </span><br><span class="line">        Thread.yield();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="keyword">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        <span class="comment">//将旧数组中的数组复制到新的数组中来</span></span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="维护二叉堆的结构"><a href="#维护二叉堆的结构" class="headerlink" title="维护二叉堆的结构"></a>维护二叉堆的结构</h2><p>添加数据可能会破坏底层的二叉堆结构，所以在数据入列的时候就需要同时去维护这个堆结构<br>生产数据时维护数据结构比较简单，主要就是将新节点与其父节点进行比较，然后在拿父节点和祖父节点进行比较，根据对应的排序规则对两个节点的数据进行交换操作最终找到适当的位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = array[parent];</span><br><span class="line">        <span class="keyword">if</span> (cmp.compare(x, (T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h1><p>每一次出列的元素都是底层数组中下标为0的那个，再把队列中的最后一个元素给挪到下标为0的位置，然后再维护二叉堆的结构，这就是出列的整个过程。<br>dequeue():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        E result = (E) array[<span class="number">0</span>];</span><br><span class="line">        E x = (E) array[n];</span><br><span class="line">        array[n] = <span class="keyword">null</span>;</span><br><span class="line">        Comparator&lt;? <span class="keyword">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="keyword">null</span>)</span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="维护二叉堆的结构-1"><a href="#维护二叉堆的结构-1" class="headerlink" title="维护二叉堆的结构"></a>维护二叉堆的结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用自然排序比较优先级的方式维护底层的堆结构</span></span><br><span class="line"><span class="comment"> * k: 需要填充的位置</span></span><br><span class="line"><span class="comment"> * x: 等待填充的元素，会填充在k位置</span></span><br><span class="line"><span class="comment"> * array: 堆数组</span></span><br><span class="line"><span class="comment"> * n: 堆元素的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; key = (Comparable&lt;? <span class="keyword">super</span> T&gt;)x;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;  </span><br><span class="line">        <span class="comment">// 非叶子节点无限循环，从完全二叉树的结构来看，二叉树的叶子节点一定占到总节点数的一半+1         </span></span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="comment">//假设左子节点的值最小</span></span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp;</span><br><span class="line">                ((Comparable&lt;? <span class="keyword">super</span> T&gt;) c).compareTo((T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果左子节点大于右子节点，就取右子节点的值比较</span></span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (key.compareTo((T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//如果key的值小于它的左子节点或右子节点，就退出循环，结构维护结束</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将两个子节点中比较小的节点的值赋值给父节点</span></span><br><span class="line">            array[k] = c;</span><br><span class="line">            <span class="comment">//记录左右子节点中比较小的节点的下标，用于在下一次循环中获取父节点</span></span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//循环结束后将待填充的元素填充在适当的位置</span></span><br><span class="line">        array[k] = key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用指定的比较器来比较优先级的方式维护底层的堆结构</span></span><br><span class="line"><span class="comment"> * k: 需要填充的位置</span></span><br><span class="line"><span class="comment"> * x: 等待填充的元素，会填充在k位置</span></span><br><span class="line"><span class="comment"> * array: 堆数组</span></span><br><span class="line"><span class="comment"> * n: 堆元素的数量</span></span><br><span class="line"><span class="comment"> * cmp: 指定的比较器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, T x, Object[] array,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">int</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                Comparator&lt;? <span class="keyword">super</span> T&gt; cmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> half = n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">            <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            Object c = array[child];</span><br><span class="line">            <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; <span class="number">0</span>)</span><br><span class="line">                c = array[child = right];</span><br><span class="line">            <span class="keyword">if</span> (cmp.compare(x, (T) c) &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            array[k] = c;</span><br><span class="line">            k = child;</span><br><span class="line">        &#125;</span><br><span class="line">        array[k] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h1><p>比较器主要用于实现优先级的比较，开发人员可以根实际情况来选择要不要做具体实现。<br>实现一个定制的比较器需要实现Comparator<t>接口.这个接口中的方法比较多，就不一一解释了，这里只对最重要的一个方法做一下解释。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Comparator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值代表了o1和O2的比较结果</span></span><br><span class="line"><span class="comment">     * 返回值小于0 : o1 &lt; o2</span></span><br><span class="line"><span class="comment">     * 返回值等于0 : o1==o2</span></span><br><span class="line"><span class="comment">     * 返回值大于0 : o1 &gt; o2</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(T o1, T o2)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...此处省略接口中其他的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p><p>开发人员实现了比较器以后，优先级队列中再做优先级比较，就会使用开发人员自己实现的比较器，而不是自然排序.</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>PriorityBlockingQueue是一个无界队列，底层使用了ReentrentLock、Condition和二叉堆技术，并且每一次数据入列和出列都会相应的调整堆结构.<br>因为使用了可重入锁，所以它是线程安全的。但是，由于数据入列和出列使用同一把锁，所以在PriorityBlockingQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jconcole连接java进程报错问题解决</title>
      <link href="/hlblog/2018/12/13/jvm/jconsole%E8%BF%9E%E6%8E%A5java%E8%BF%9B%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
      <url>/hlblog/2018/12/13/jvm/jconsole%E8%BF%9E%E6%8E%A5java%E8%BF%9B%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>jconcole连接java进程报错问题解决</p><a id="more"></a><p>问题:使用JConsole连接java进程的时候报错。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"VMPanel.connect"</span> java.lang.InternalError: Remote thread failed <span class="keyword">for</span> unknown reason</span><br><span class="line">    at sun.tools.attach.WindowsVirtualMachine.enqueue(Native Method)</span><br><span class="line">    at sun.tools.attach.WindowsVirtualMachine.&lt;init&gt;(WindowsVirtualMachine.java:<span class="number">62</span>)</span><br><span class="line">    at sun.tools.attach.WindowsAttachProvider.attachVirtualMachine(WindowsAttachProvider.java:<span class="number">69</span>)</span><br><span class="line">    at com.sun.tools.attach.VirtualMachine.attach(VirtualMachine.java:<span class="number">208</span>)</span><br><span class="line">    at sun.tools.jconsole.LocalVirtualMachine.loadManagementAgent(LocalVirtualMachine.java:<span class="number">232</span>)</span><br><span class="line">    at sun.tools.jconsole.LocalVirtualMachine.startManagementAgent(LocalVirtualMachine.java:<span class="number">98</span>)</span><br><span class="line">    at sun.tools.jconsole.ProxyClient.tryConnect(ProxyClient.java:<span class="number">333</span>)</span><br><span class="line">    at sun.tools.jconsole.ProxyClient.connect(ProxyClient.java:<span class="number">313</span>)</span><br><span class="line">    at sun.tools.jconsole.VMPanel$<span class="number">2</span>.run(VMPanel.java:<span class="number">294</span>)</span><br></pre></td></tr></table></figure></p><p>解决:<br>项目启动的时候加上启动参数-Dcom.sun.management.jmxremote</p>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CMS垃圾收集器</title>
      <link href="/hlblog/2018/12/13/jvm/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
      <url>/hlblog/2018/12/13/jvm/CMS%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>CMS垃圾收集器<br><a id="more"></a></p><h1 id="CMS出现的初衷和目的"><a href="#CMS出现的初衷和目的" class="headerlink" title="CMS出现的初衷和目的"></a>CMS出现的初衷和目的</h1><p>GC的出现是为了解决Throught收集器和Serial收集器在Full GC周期中的长时间停顿。</p><h1 id="CMS的工作区域和适用场景"><a href="#CMS的工作区域和适用场景" class="headerlink" title="CMS的工作区域和适用场景"></a>CMS的工作区域和适用场景</h1><p>CMS的主要工作区域是老年代，它在老年代中尽可能的并发执行，每个GC周期只有2次短停顿<br>如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的CPU资源也比较丰富，就适合适用CMS收集器。</p><h1 id="CMS的工作流程"><a href="#CMS的工作流程" class="headerlink" title="CMS的工作流程"></a>CMS的工作流程</h1><h2 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h2><p>初始标记主要是标记GC Roots可达的老年代对象以及新生代引用的老年代对象。这个过程在jdk1.7时是单线程执行，在1.8以后是多线程并发执行(可以通过参数CMSParallelInitialMarkEnabled调整)。初始标记会暂停工作线程(Stop The World)。</p><h2 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h2><p>并发标记主要是根据初始标记节点锁标记处的对象向下追踪，将所有可追踪到的对象标记出来，但是这个阶段是GC线程与工作线程并发工作，所以在进行并发标记的时候<br>可能会有些已经在初始标记阶段标记出来的对象发生了改变，或者有一些对象从年轻代晋升到了老年代，或者是有些大对象被直接分配到了老年代，这些对象在并发标记阶段会被标记为dirty,在重新标记阶段对这些dirty对象进行重新标记。</p><h2 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h2><p>重新标记阶段与初始标记阶段一样会暂停工作线程(STW),这个阶段需要重新扫描并标记堆中的对象，包括新生代，GCRoots和被标记为dirty的对象。</p><h2 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h2><p>并发清除阶段，用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达，然后清除。</p><h2 id="预清理阶段"><a href="#预清理阶段" class="headerlink" title="预清理阶段"></a>预清理阶段</h2><p>CMS一般常说的工作流程就上面四个，即初始标记-&gt;并发标记-&gt;重新标记-&gt;并发清除。<br>在重新标记阶段会扫描新生代，GCRoots以及并发标记阶段标记为dirty的对象，这个过程是比较耗时的，在重新标记阶段会产生较长时间的STW。<br>在并发标记阶段和重新标记阶段之间，其实还有一个预清理阶段，这个阶段也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：（1）老年代中card为dirty的对象；（2）幸存区(from和to)中引用的老年代对象。因此，这个阶段也需要扫描新生代+老年代。</p><h2 id="并发重置"><a href="#并发重置" class="headerlink" title="并发重置"></a>并发重置</h2><p>CMS内部重置回收器状态，准备进入下一个并发回收周期。</p><h1 id="CMS的异常情况"><a href="#CMS的异常情况" class="headerlink" title="CMS的异常情况"></a>CMS的异常情况</h1><p>CMS收集器也并不是每一次都能成功完成整个垃圾收集流程，当出现异常情况时，CMS可能会退出工作流程。</p><h2 id="永久代耗尽异常"><a href="#永久代耗尽异常" class="headerlink" title="永久代耗尽异常"></a>永久代耗尽异常</h2><p>默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就会触发Full GC，这种情况下CMS就会退出当前工作流程转为触发一次Full GC。</p><h2 id="并发模式失败"><a href="#并发模式失败" class="headerlink" title="并发模式失败"></a>并发模式失败</h2><p>在CMS工作流程中的并发标记和并发清理阶段，GC线程和工作线程是同时工作的，如果在此期间有大对象直接分配到老年代，但是老年代没有足够的可用内存，就会产生异常(concurrent mode failure),CMS收集器工作停止，转为一次Full GC.</p><h2 id="晋升失败异常"><a href="#晋升失败异常" class="headerlink" title="晋升失败异常"></a>晋升失败异常</h2><p>新生代做minor gc的时候，需要CMS的担保机制确认老年代是否有足够的空间容纳要晋升的对象。如果担保机制发现老年代的可用内存不够，或者如果担保机制判断老年代可用内存是够的，但是实际上由于碎片问题或者确实内存不够导致无法分配，就会产生异常，这个时候minor gc失败，cms的工作流程退出，全部转化为一次Full GC。</p><h1 id="CMS调优"><a href="#CMS调优" class="headerlink" title="CMS调优"></a>CMS调优</h1>]]></content>
      
      
      <categories>
          
          <category> jvm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DelayQueue源码阅读笔记</title>
      <link href="/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/DelayQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/DelayQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>DelayQueue源码阅读笔记<br>DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。</p><a id="more"></a><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可重入锁保证线程安全</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">//优先级队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityQueue&lt;E&gt; q = <span class="keyword">new</span> PriorityQueue&lt;E&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Thread designated to wait for the element at the head of</span></span><br><span class="line"><span class="comment">    * the queue.  This variant of the Leader-Follower pattern</span></span><br><span class="line"><span class="comment">    * (http://www.cs.wustl.edu/~schmidt/POSA/POSA2/) serves to</span></span><br><span class="line"><span class="comment">    * minimize unnecessary timed waiting.  When a thread becomes</span></span><br><span class="line"><span class="comment">    * the leader, it waits only for the next delay to elapse, but</span></span><br><span class="line"><span class="comment">    * other threads await indefinitely.  The leader thread must</span></span><br><span class="line"><span class="comment">    * signal some other thread before returning from take() or</span></span><br><span class="line"><span class="comment">    * poll(...), unless some other thread becomes leader in the</span></span><br><span class="line"><span class="comment">    * interim.  Whenever the head of the queue is replaced with</span></span><br><span class="line"><span class="comment">    * an element with an earlier expiration time, the leader</span></span><br><span class="line"><span class="comment">    * field is invalidated by being reset to null, and some</span></span><br><span class="line"><span class="comment">    * waiting thread, but not necessarily the current leader, is</span></span><br><span class="line"><span class="comment">    * signalled.  So waiting threads must be prepared to acquire</span></span><br><span class="line"><span class="comment">    * and lose leadership while waiting.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">//当leader不为空时，只有leader能等待第一个元素返回，其他的元素必须无限期等待，等待leader从poll方法或take方法返回后将它们唤醒</span></span><br><span class="line"><span class="keyword">private</span> Thread leader = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件等待队列，与ReentrentLocK搭配</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition available = lock.newCondition();</span><br></pre></td></tr></table></figure><h1 id="Delayed接口"><a href="#Delayed接口" class="headerlink" title="Delayed接口"></a>Delayed接口</h1><p>DelayQueue队列中所有的元素都必须实现Delayed接口，Delayed接口中有一个getDelay方法用来返回剩余的延迟时间。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Delayed接口继承了Comparable接口，所以实现此接口的同时，还需要实现Comparable接口中的compareTo方法。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回剩余的延迟时间，0和负数代表已经过了延迟的时间</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h1><p>DelayQueue中的大部分功能都沿用了PriorityQueue中的实现，非常的简单。它的特殊点主要集中在出列的时候。</p><p>poll():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        E first = q.peek();</span><br><span class="line">        <span class="comment">//如果队列中没有元素或者第一个元素指定的延迟时间还没有到达，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="keyword">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll(long,TimeUnit):E<br>此方法会响应中断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * timeout: 等待时间数值</span></span><br><span class="line"><span class="comment"> * unit: 等待时间单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将等待时间转换为纳秒形式</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果等待时间小于等于0并且队列中无数据，直接返回null</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//如果等待时间大于0并且队列中无数据，将线程阻塞直到等待时间过期</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果队列不是空队列，取第一个元素的剩余延迟时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果第一个元素的剩余时间小于等于0了，就将第一个元素出列并返回。</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果第一个元素的剩余延迟时间还未过，但是等待时间已经过期了，就返回null.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果等待时间小于第一个元素的剩余延迟时间，将线程阻塞直到等待时间过期。</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//如果等待时间大于等于第一个元素的剩余延迟时间，将线程阻塞直到第一个元素的延迟时间过期</span></span><br><span class="line">                        <span class="keyword">long</span> timeLeft = available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">//重新计算等待时间</span></span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            <span class="comment">//将leader置空</span></span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//如果leader为空并且队列不为空，唤醒正在等待中的线程。</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>take():E<br>此方法会响应中断<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            E first = q.peek();</span><br><span class="line">            <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//如果队列是空队列，将线程阻塞起来进入条件等待队列</span></span><br><span class="line">                available.await();</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果队列不是空队列，取第一个元素的剩余延迟时间</span></span><br><span class="line">                <span class="keyword">long</span> delay = first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">//如果第一个元素的剩余时间小于等于0了，就将第一个元素出列并返回。</span></span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                first = <span class="keyword">null</span>; <span class="comment">// don't retain ref while waiting</span></span><br><span class="line">                <span class="keyword">if</span> (leader != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">//如果 队列非空&amp;&amp;剩余延迟时间&gt;0&amp;&amp;leader!=null  </span></span><br><span class="line">                    <span class="comment">//此时只有leader能得带第一个元素的延迟时间到期，其余的所有线程都将被阻塞</span></span><br><span class="line">                    <span class="comment">//等待leader线程将它们唤醒，转移到CLH队列中竞争锁</span></span><br><span class="line">                    available.await();</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread thisThread = Thread.currentThread();</span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//如果 队列非空&amp;&amp;剩余延迟时间&gt;0&amp;&amp;leader=null  </span></span><br><span class="line">                        <span class="comment">//将当前线程设置为leader,使其他的线程全部阻塞，当前线程等待第一个元素的延迟时间过期</span></span><br><span class="line">                        available.awaitNanos(delay);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="keyword">null</span> &amp;&amp; q.peek() != <span class="keyword">null</span>)</span><br><span class="line">             <span class="comment">//如果leader为空并且队列不为空，唤醒正在等待中的线程。</span></span><br><span class="line">             <span class="comment">//之所以需要判断leader是否为null的情况，是因为此时可能leader被其他线程持有并且没有释放，在这种情况下任何非leader线程都只能等待leader被释放</span></span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>DelayQueue是一个无界等待队列,底层使用的是ReentrantLock+Condition+PriorityQueue，DelayQueue中关于入列和出列的操作都是通过底层的PriorityQueue来实现的，虽然PriorityQueue本身是线程不安全的，但是在DelayQueue中使用了ReentrentLock解决了线程安全问题，可以放心的在多线程环境下使用。但是，由于数据入列和出列使用同一把锁，所以在DelayQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>idea快捷键记录</title>
      <link href="/hlblog/2018/12/13/idea/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/hlblog/2018/12/13/idea/idea%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>ctrl+shift+F8 : 打开breakpoint</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedBlockingDeque源码阅读笔记</title>
      <link href="/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/LinkedBlockingDeque%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(waitting)/"/>
      <url>/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/LinkedBlockingDeque%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(waitting)/</url>
      
        <content type="html"><![CDATA[<p>LinkedBlockingDeque源码阅读笔记<br>LinkedBlockingDeque是一个有界阻塞队列，其底层技术为AtomicInteger+ReentrentLock+Condition+双端链表。<br><a id="more"></a></p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双端链表的头结点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双端链表的尾节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = lock.newCondition();</span><br></pre></td></tr></table></figure><h1 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h1><p>linkFirst(Node):boolean<br>将指定节点设置为头结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkFirst</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    node.next = f;</span><br><span class="line">    first = node;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        last = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = node;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">//从消费者等待队列中唤醒一个消费者</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>linkLast(Node):boolean<br>将指定节点设置为尾结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">linkLast</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt;= capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    node.prev = l;</span><br><span class="line">    last = node;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>)</span><br><span class="line">        first = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        l.next = node;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="comment">//从消费者等待队列中唤醒一个消费者</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>unlinkFirst():E<br>返回并删除头结点，如果头结点为null，则返回null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; n = f.next;</span><br><span class="line">    E item = f.item;</span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    f.next = f; <span class="comment">// help GC</span></span><br><span class="line">    first = n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="keyword">null</span>)</span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        n.prev = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">//从生产者等待队列中唤醒一个生产者</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>unlinkLast():E<br>返回并删除尾结点，如果尾结点为null，则返回null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.isHeldByCurrentThread();</span></span><br><span class="line">    Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    Node&lt;E&gt; p = l.prev;</span><br><span class="line">    E item = l.item;</span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    l.prev = l; <span class="comment">// help GC</span></span><br><span class="line">    last = p;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p.next = <span class="keyword">null</span>;</span><br><span class="line">    --count;</span><br><span class="line">    <span class="comment">//从生产者等待队列中唤醒一个生产者</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>idea使用问题记录</title>
      <link href="/hlblog/2018/12/13/idea/idea%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/hlblog/2018/12/13/idea/idea%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>idea使用问题记录</p><a id="more"></a><h1 id="idea插件下载失败"><a href="#idea插件下载失败" class="headerlink" title="idea插件下载失败"></a>idea插件下载失败</h1><p>检查了网络没有问题，试过梯子，插件始终无法下载下来。经过google找到了解决方案<br>Setting -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Updates -&gt; use secure connection(默认勾选，将它取消)</p><h1 id="Method-breakpoints-may-dramatically-slow-down-debugging"><a href="#Method-breakpoints-may-dramatically-slow-down-debugging" class="headerlink" title="Method breakpoints may dramatically slow down debugging"></a>Method breakpoints may dramatically slow down debugging</h1><p>断点打在了方法上面，导致项目启动变慢，IDEA调试越来越慢。<br>Ctrl+shift+F8 打开 Breakpoints 面板，找到对应的断点取消即可</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LinkedBlockingQueue源码阅读笔记</title>
      <link href="/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/LinkedBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/LinkedBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>LinkedBlockingQueue源码阅读笔记<br>LinkedBlockingQueue是一个基于双端链表的有界阻塞队列。它底层使用了AtomicInteger+ReentrantLock+Condition+单链表 来实现。<br>不同于ArrayBlockingQueue和PriorityBlockingQueue，LinkedBlockingQueue中有两个ReentrantLock实例，一个读锁，一个作为写锁，这样在数据入列和出列的时候互不干扰，不会相互阻塞。<br><a id="more"></a></p><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 队列容量范围,如果未设置，则默认为Integer.MAX_VALUE</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层链表的头节点</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层链表的尾节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者等待队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="生产数据-入列"><a href="#生产数据-入列" class="headerlink" title="生产数据(入列)"></a>生产数据(入列)</h1><p>offer(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="comment">//如果当前队列中的元素数量已经达到了执行的容量的上限，则入列失败</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            <span class="comment">//数据入列</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            <span class="comment">//获取元素数量并使元素数量+1，返回的是未+1的数量</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                <span class="comment">//队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。</span></span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) </span><br><span class="line">        <span class="comment">//如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>put(E):void<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列容量已经达到上限，阻塞当前线程，加入到生产者条件队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据入列</span></span><br><span class="line">        enqueue(node);</span><br><span class="line">        <span class="comment">//获取元素数量并使元素数量+1，返回的是未+1的数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            <span class="comment">//队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer(E e, long timeout, TimeUnit unit):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果队列容量已经达到上限，将当前线程阻塞一段时间，加入到生产者条件队列中</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="comment">//如果指定的阻塞时间小于0，本次入列失败</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数据入列</span></span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        <span class="comment">//获取元素数量并使元素数量+1，返回的是未+1的数量</span></span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">             <span class="comment">//队列中的元素容量未满，发送一个信号，从生产者等待队列唤醒一个数据生产者。</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">         <span class="comment">//如果添加元素之前队列是空队列，从消费者等待队列唤醒一个消费者</span></span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer(E):boolean、offer(E, long, TimeUnit):boolean和put(E):void的不同<br>offer: 如果队列容量已满，本次入列失败<br>offer(E, long, TimeUnit):boolean：如果对列容量已满，将当前线程阻塞一段时间，将当前线程加入到生产者等待队列中。<br>put: 如果对列容量已满，阻塞当前线程，将当前线程加入到生产者等待队列中。</p><h1 id="消费数据-出列"><a href="#消费数据-出列" class="headerlink" title="消费数据(出列)"></a>消费数据(出列)</h1><p>poll():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果当前队列是空队列，直接返回null</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//元素出列</span></span><br><span class="line">            x = dequeue();</span><br><span class="line">            <span class="comment">//获取队列中的元素数量并使元素数量-1，返回的是未-1的数量</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="comment">//如果当前元素出列以后队列依然有元素存在，从消费者等待队列唤醒一个消费者。</span></span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">//如果当前元素出列之前队列是满的，那么在出列之后需要从生产者等待队列唤醒一个生产者。</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>take():E<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前队列是空队列，就将当前线程阻塞起来，加入到消费者等待队列中。</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="移除数据-出列"><a href="#移除数据-出列" class="headerlink" title="移除数据(出列)"></a>移除数据(出列)</h1><p>remove(Object):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//获取读锁和写锁，将读写全部阻塞住</span></span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//表头开始，找到指定的元素并断开该元素和链表的关联(删除该元素)</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">                p != <span class="keyword">null</span>;</span><br><span class="line">                trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//将读锁和写锁全部释放</span></span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ArrayBlockingQueue源码阅读笔记</title>
      <link href="/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/ArrayBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%98%9F%E5%88%97/ArrayBlockingQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>ArrayBlockingQueue是一个有界阻塞队列，它的可容纳的最大的数据量取决于队列初始化时的设置，它的内部通过Object[],ReentrentLock和两个Condition实现了一个非常经典的生产者消费者场景，</p><a id="more"></a><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>底层技术: Object[] + ReentrentLock + Condition(两个Condition,生产者消费者场景)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列中的保存数据的容器</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一次从队列中获取数据的位置偏移量</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下一次添加数据到队列中的位置偏移量</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中的数据量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可重入锁</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者条件队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure></p><h2 id="生产数据"><a href="#生产数据" class="headerlink" title="生产数据"></a>生产数据</h2><h3 id="数据入列"><a href="#数据入列" class="headerlink" title="数据入列"></a>数据入列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//添加数据到队列中</span></span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="comment">//修改下一次添加数据到队列的数据偏移量，如果已经到达了数组的终点边界，</span></span><br><span class="line">    <span class="comment">//就将偏移量置为0，循环使用数组</span></span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">//唤醒消费者队列中的第一个节点去消费数据</span></span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="offer-E"><a href="#offer-E" class="headerlink" title="offer(E)"></a>offer(E)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值代表是否成功生产数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//使用可重入锁，保证生产数据的安全</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add-E"><a href="#add-E" class="headerlink" title="add(E):"></a>add(E):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值代表是否成功生产数据。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-E"><a href="#put-E" class="headerlink" title="put(E)"></a>put(E)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//使用可重入锁保证生产数据时的安全问题</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            <span class="comment">//如果当前队列中的数据已经达到了可以容纳的上限，就将当先线程阻塞进入生产者队列,</span></span><br><span class="line">            <span class="comment">//等待消费者将数据消费了以后，会将生产者队列中的第一个节点唤醒</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        <span class="comment">//数据入列</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ArrayBlockingQueue中提供了三个方法用来生产数据，offer(E),add(E)以及put(E)，这其中add(E)和put(E)内部也是通过调用offer(E)来实现的。put(E)在队列中数据已达上限的时候会将线程阻塞，直至有消费者将队列中的数据消费掉。offer(E)和add(E)在队列中数据已达上限的时候不会阻塞，而是会添加失败。</p><h2 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h2><h3 id="数据出列"><a href="#数据出列" class="headerlink" title="数据出列"></a>数据出列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="comment">//取出队列中的第一个可消费数据</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//将被消费的数据所占用的空间释放</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        <span class="comment">//如果可消费数据的偏移量已经到了队列的终点，就回到0的位置循环消费</span></span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//每次有数据出列都会调用，用来处理迭代器的相关逻辑，此处就不再细说了</span></span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    <span class="comment">//消费数据以后将生产者队列中的第一个节点唤醒来继续生产数据</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>peek():E<br>返回队列中的第一条数据，但是不会从队列中将之移除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> E <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) items[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll():E<br>返回队列中的第一条数据,并且从队列中将之移除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>take():E<br>返回队列中的第一条数据,如果队列为空，就将线程阻塞等待生产者生产数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//队列为空，就将线程阻塞等待生产者生产数据。</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ArrayBlockingQueue中提供了三个方法用来消费数据，peek():E,pool():E以及take():E,这三个方法内部都是通过调用dequeue():E来实现的。peek():E方法返回队列中的第一条数据，但是不会从队列中将之移除，pool():E方法返回队列中的第一条数据,并且从队列中将之移除。take():E方法返回队列中的第一条数据,如果队列为空，就将线程阻塞等待生产者生产数据。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ArrayBlockingQueue使用了一个Object数组作为底层数据存储的容器，用putIndex和takeIndex两个字段来表示数据入列和出列的位置。生产数据的时候从putIndex开始将数据按照数组的下标插入，消费数据的时候从takeIndex将数据一一删除。通过这种形式可以将底层数组循环使用。<br>当putIndex和takeIndex重合的时候，表明当前队列中没有数据，那么所有的消费者都将被阻塞，等待生产者生产数据。<br>当size等于当前数组的容量的时候，表面当前队列已满，那么所有的生产者都将被阻塞，等待消费者消费数据。</p><p>另外，由于数据入列和出列使用同一把锁，所以在ArrayBlockingQueue中任何入列和出列操作都是串行执行的，必须等到前一个操作将锁释放。</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PriorityQueue源码阅读笔记</title>
      <link href="/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/PriorityQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/PriorityQueue%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>PriorityQueue是一个无界队列,使用了二叉堆作为底层的数据结构，并且用一个Object[]来表示这个堆。<br>PriorityQueue本身未做任何线程安全方面的处理，所以它本身是线程不安全的，在多线程环境下可能会出现线程安全问题。</p><a id="more"></a><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//底层存储数据的结构，Priority底层使用的是二叉堆来实现，使用数组来表示二叉堆</span></span><br><span class="line"><span class="keyword">transient</span> Object[] queue; </span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较器，如果想要使用它的话，需要开发人员自己实现，当它为空的时候会使用默认的自然排序进行比较</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列中元素的数量发生改变的次数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="生产数据"><a href="#生产数据" class="headerlink" title="生产数据"></a>生产数据</h1><p>add(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>offer(E):boolean<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">int</span> i = size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//添加数据并维护堆结构</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = queue.length;</span><br><span class="line">    <span class="comment">// 计算新的容量</span></span><br><span class="line">    <span class="comment">// 原容量小于64，扩容后翻倍，准确来说是oldCapacity + oldCapacity + 2</span></span><br><span class="line">    <span class="comment">// 原容量大于等于64，扩容后增加百分之50，oldCapacity+(oldCapacity &gt;&gt; 1)</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + ((oldCapacity &lt; <span class="number">64</span>) ?</span><br><span class="line">                                        (oldCapacity + <span class="number">2</span>) :</span><br><span class="line">                                        (oldCapacity &gt;&gt; <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果计算出的新的容量大于队列允许的最大值，需要重新计算</span></span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//扩容，创建一个新的数组，将原数组中的数据复制过去，然后将新的数组赋值给变量queue</span></span><br><span class="line">    queue = Arrays.copyOf(queue, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果此时底层数组的长度已经达到了终极上限(Integer.MAX_VALUE)，那么再加一的话就会溢出</span></span><br><span class="line">    <span class="comment">//这里如果小于0，说明已经溢出了，抛出OutOfMemoryError</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="comment">// 重新计算新的容量</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加数据、维护堆结构"><a href="#添加数据、维护堆结构" class="headerlink" title="添加数据、维护堆结构"></a>添加数据、维护堆结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUp</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//如果开发人员自己实现了一个比较器，就使用自己实现的那个比较器</span></span><br><span class="line">        <span class="comment">//方法逻辑比较简单，可以参考堆结构的添加数据过程</span></span><br><span class="line">        siftUpUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果开发人员并未实现一个定制的构造器，就使用默认的自然排序来当做比较器进行使用。</span></span><br><span class="line">        <span class="comment">//方法逻辑比较简单，可以参考堆结构的添加数据过程</span></span><br><span class="line">        siftUpComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftUpUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> parent = (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Object e = queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="消费数据"><a href="#消费数据" class="headerlink" title="消费数据"></a>消费数据</h1><p>peek():E<br>获取队列中的第一个元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (size == <span class="number">0</span>) ? <span class="keyword">null</span> : (E) queue[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>poll():E<br>获取队列中的第一个元素，并使它出列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> s = --size;</span><br><span class="line">    modCount++;</span><br><span class="line">    E result = (E) queue[<span class="number">0</span>];</span><br><span class="line">    E x = (E) queue[s];</span><br><span class="line">    queue[s] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="消费数据、维护结构"><a href="#消费数据、维护结构" class="headerlink" title="消费数据、维护结构"></a>消费数据、维护结构</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDown</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        siftDownUsingComparator(k, x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        siftDownComparable(k, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownComparable</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    Comparable&lt;? <span class="keyword">super</span> E&gt; key = (Comparable&lt;? <span class="keyword">super</span> E&gt;)x;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;        <span class="comment">// loop while a non-leaf</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>; <span class="comment">// assume left child is least</span></span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            ((Comparable&lt;? <span class="keyword">super</span> E&gt;) c).compareTo((E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">siftDownUsingComparator</span><span class="params">(<span class="keyword">int</span> k, E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> half = size &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="keyword">int</span> child = (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        Object c = queue[child];</span><br><span class="line">        <span class="keyword">int</span> right = child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>idea中好用的插件</title>
      <link href="/hlblog/2018/12/13/idea/idea%E6%8F%92%E4%BB%B6/"/>
      <url>/hlblog/2018/12/13/idea/idea%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>网上搜集来的idea中好用的插件</p><a id="more"></a><p>Lombok<br>编译时自动生成set方法和get方法</p><p>google-java-format<br>保存时自动格式化</p><p>CodeGlance<br>代码地图</p><p>GsonFormat<br>一键根据json文本生成java类，非常方便</p><p>Background image Plus<br>设置idea背景图片</p><p>active-power-mode<br>这是一款让你在编码的时候，整个屏幕都为之颤抖的插件。 </p><p>Nyan progress bar<br>这是一个将你idea中的所有的进度条都变成萌新动画的小插件。 </p><p>Rainbow Brackets<br>彩虹颜色的括号 看着很舒服 敲代码效率变高</p><p>stackoverflow<br>这一看似平淡的右键stackoverflow，却把其中的闷骚体现的淋漓尽致：我就这么叼，我就不去浏览器里查，只有右键才和我的右手匹配。</p><p>FindBugs-IDEA<br>可以对多种级别的内容进行finbugs,分析完之后会有一个视图进行提示，详细的说明是哪种问题。</p><p>CheckStyle-IDEA<br>通过检查对代码编码格式，命名约定，Javadoc，类设计等方面进行代码规范和风格的检查，从而有效约束开发人员更好地遵循代码编写规范。 软件安装成功之后，首先要设置规则。可以通过<br>Preferences—&gt;Other Settings —&gt;CheckStyles<br>进行设置，可以直接将文件添加进来，然后就可以对具体的文件进行检查了。</p><p>MetricsReloaded<br>代码复杂度检查</p><p>VisualVM Launcher<br>运行 java 程序的时候启动 visualvm，方便查看 jvm 的情况 比如堆内存大小的分配，某个对象占用了多大的内存，jvm 调优必备工具。</p><p>MyBatisCodeHelperPro<br>mybatis 代码自动生成插件，大部分单表操作的代码可自动生成，减少重复劳动 大幅提升效率。</p><p>Translation<br>最好用的翻译插件，功能很强大，界面很漂亮。</p>]]></content>
      
      
      <categories>
          
          <category> 开发工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AtomicInteger源码阅读笔记</title>
      <link href="/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/AtomicInteger%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/12/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/AtomicInteger%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>AtomicInteger源码阅读笔记</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, -<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAndGet</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndUpdate</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">updateAndGet</span><span class="params">(IntUnaryOperator updateFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = updateFunction.applyAsInt(prev);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAccumulate</span><span class="params">(<span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically updates the current value with the results of</span></span><br><span class="line"><span class="comment"> * applying the given function to the current and given values,</span></span><br><span class="line"><span class="comment"> * returning the updated value. The function should be</span></span><br><span class="line"><span class="comment"> * side-effect-free, since it may be re-applied when attempted</span></span><br><span class="line"><span class="comment"> * updates fail due to contention among threads.  The function</span></span><br><span class="line"><span class="comment"> * is applied with the current value as its first argument,</span></span><br><span class="line"><span class="comment"> * and the given update as the second argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> x the update value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> accumulatorFunction a side-effect-free function of two arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the updated value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">accumulateAndGet</span><span class="params">(<span class="keyword">int</span> x,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  IntBinaryOperator accumulatorFunction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> prev, next;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">        next = accumulatorFunction.applyAsInt(prev, x);</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, next));</span><br><span class="line">    <span class="keyword">return</span> next;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>1.A+B Problem</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/1.A+B%20Problem/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/1.A+B%20Problem/</url>
      
        <content type="html"><![CDATA[<p>1.A+B Problem<br><strong>Level : Easy</strong><br><a id="more"></a></p><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Clarification</strong><br>Are a and b both 32-bit integers?<br>Yes.</p><p>Can I use bit operation?<br>Sure you can.</p><p><strong>Example</strong><br>Given a=1 and b=2 return 3.</p><p><strong>Challenge</strong><br>Of course you can just return a + b to get accepted. But Can you challenge not do it like that?(You should not use + or any arithmetic operators.)</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>这道题的意思是给定两个32位的整数a和b,要求返回a和b的和，当然，这道题的的意义肯定不会是直接让你返回a+b，题目中的Challenge说的很明白了。那么它的考点在哪呢？题目也给了暗示了，那就是bit operation，也就是位运算！</p><p>这道题可以用异或运算配合与运算来处理，<br>异或运算的特点是当两个数一样时异或运算的结果为0，两个数不一样时异或运算的结果为1。简单来说就是同为0，异为1。<br>单纯的异或运算得到的结果会有一个问题，那就是没有办法处理进位，所以异或运算得到的值只是没有进位的值。<br>那么如何处理进位问题呢?<br>可以使用与运算来处理这个问题，与运算的特点是，同1为1，否则为0。<br>即当两个数都是1的时候与运算的结果才是1，其他的情况都是0.<br>而当两个数都是1的时候，也正是需要进位的时候，所以与运算后为1的位置，就是需要进1的位置。<br>与运算的结果左移一位，得到的就是需要被进一位的位置。</p><p>处理思路有了，按照上面的思路，可以得到a+b的结果，但是还是会有问题，如果两个数都很大，得到的结果溢出了该怎么办呢？<br>LintCode中的原题中给出的代码模板将返回值限定死了，我们没办法改变，但是自己私下里处理一下还是可以的。如果想要处理溢出的问题，可以使用字符串来做大整数的加法运算，这里就不细说了，代码会给出来。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        problem1_2(<span class="number">3</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理溢出问题</span></span><br><span class="line">        problem1_2(<span class="number">2111111111</span>,<span class="number">2111111111</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 位运算</span></span><br><span class="line"><span class="comment">     * 异或运算: 无法处理溢出，除非将int类型转换为long类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> b</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">problem1_1</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">int</span> aa = a^b;</span><br><span class="line">           <span class="keyword">int</span> bb = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           a = aa;</span><br><span class="line">           b = bb;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        return a;</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理边界溢出问题</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">problem1_2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        String strA = a+<span class="string">""</span>;</span><br><span class="line">        String strB = b+<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不存在溢出的可能</span></span><br><span class="line">        <span class="keyword">if</span>(strA.length() &lt;= <span class="number">9</span> || strB.length() &lt;= <span class="number">9</span>)&#123;</span><br><span class="line">             problem1_1(a,b);</span><br><span class="line">             <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果存在溢出的可能</span></span><br><span class="line">        <span class="comment">//两个数相加，只有其中一个数的长度是10，才有可能出现溢出</span></span><br><span class="line">        <span class="comment">//如果存在溢出，就使用数组来处理</span></span><br><span class="line">        <span class="keyword">if</span>((strA.length() == <span class="number">10</span> &amp;&amp; strB.length() &gt;= <span class="number">9</span>) || (strA.length() &gt;= <span class="number">9</span> &amp;&amp; strB.length() == <span class="number">10</span>))&#123;</span><br><span class="line">            <span class="keyword">int</span>[] arrA = <span class="keyword">new</span> <span class="keyword">int</span>[strA.length()];</span><br><span class="line">            <span class="keyword">int</span>[] arrB = <span class="keyword">new</span> <span class="keyword">int</span>[strB.length()];</span><br><span class="line">            <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strA.length();i++)&#123;</span><br><span class="line">                arrA[i] = Integer.parseInt(strA.charAt(strA.length()-<span class="number">1</span>-i)+<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;strB.length();i++)&#123;</span><br><span class="line">                arrB[i] = Integer.parseInt(strA.charAt(strB.length()-<span class="number">1</span>-i)+<span class="string">""</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.length;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">9</span>)&#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> r = arrA[i] + arrB[i];</span><br><span class="line">                    <span class="keyword">if</span>(r &lt; <span class="number">10</span>)&#123;</span><br><span class="line">                        result[i] = r;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result[i] = result[i]+(r-<span class="number">10</span>);</span><br><span class="line">                        result[i+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(arrA.length == <span class="number">10</span>)&#123;</span><br><span class="line">                        result[i] = result[i]+arrA[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(arrB.length == <span class="number">10</span>)&#123;</span><br><span class="line">                        result[i] = result[i]+arrB[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;result.length;i++)&#123;</span><br><span class="line">                System.out.print(result[result.length-<span class="number">1</span>-i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>9.Fizz Buzz</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/9.Fizz%20Buzz/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/9.Fizz%20Buzz/</url>
      
        <content type="html"><![CDATA[<p>9.Fizz Buzz<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Given number n. Print number from 1 to n. But:</p><p>when number is divided by 3, print “fizz”.<br>when number is divided by 5, print “buzz”.<br>when number is divided by both 3 and 5, print “fizz buzz”.<br>when number can’t be divided by either 3 or 5, print the number itself.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">If n = 15, you should return:</span><br><span class="line">[</span><br><span class="line">  &quot;1&quot;, &quot;2&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;4&quot;, &quot;buzz&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;7&quot;, &quot;8&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;buzz&quot;, &quot;11&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;13&quot;, &quot;14&quot;, &quot;fizz buzz&quot;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">If n = 10, you should return:</span><br><span class="line">[</span><br><span class="line">  &quot;1&quot;, &quot;2&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;4&quot;, &quot;buzz&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;7&quot;, &quot;8&quot;, &quot;fizz&quot;,</span><br><span class="line">  &quot;buzz&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>Can you do it with only one if statement?</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">fizzBuzz</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n) &#123;</span><br><span class="line">        list.add(i % <span class="number">15</span> == <span class="number">0</span> ? <span class="string">"fizz buzz"</span> : i % <span class="number">3</span> == <span class="number">0</span> ? <span class="string">"fizz"</span> : i % <span class="number">5</span> == <span class="number">0</span> ? <span class="string">"buzz"</span> : i + <span class="string">""</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.Merge Two Sorted Arrays</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/6.Merge%20Two%20Sorted%20Arrays/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/6.Merge%20Two%20Sorted%20Arrays/</url>
      
        <content type="html"><![CDATA[<p>6.Merge Two Sorted Arrays<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Merge two given sorted integer array A and B into a new sorted integer array.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:  A=[1], B=[1]</span><br><span class="line">Output: [1,1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">return array merged.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:  A=[1,2,3,4], B=[2,4,5,6]</span><br><span class="line">Output: [1,2,2,3,4,4,5,6]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">return array merged.</span><br></pre></td></tr></table></figure></p><!-- **Challenge**How can you optimize your algorithm if one array is very large and the other is very small? --><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>合并两个有序数组，只需要创建一个新的数组，将两个数组一一对比然后按照排序规则加入到新数组中，等其中一个数组中的数据全部放入到新数组以后，再将另一个数组中剩下的数据全部放心新数组即可。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] a,<span class="keyword">int</span>[] b)&#123;</span><br><span class="line">    <span class="keyword">long</span> start = Calendar.getInstance().getTime().getTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;    <span class="comment">//新数组下标</span></span><br><span class="line">    <span class="keyword">int</span> aIndex = <span class="number">0</span>;  <span class="comment">//a数组下标</span></span><br><span class="line">    <span class="keyword">int</span> bIndex = <span class="number">0</span>;  <span class="comment">//b数组下标</span></span><br><span class="line">    <span class="keyword">int</span>[] newArray = <span class="keyword">new</span> <span class="keyword">int</span>[a.length+b.length];</span><br><span class="line">    <span class="keyword">while</span>(aIndex &lt; a.length &amp;&amp; bIndex &lt; b.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[aIndex] &lt;= b[bIndex])&#123;</span><br><span class="line">            newArray[index++] = a[aIndex++];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            newArray[index++] = b[bIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(aIndex &lt; a.length)&#123;</span><br><span class="line">        newArray[index++] = a[aIndex++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(bIndex &lt; b.length)&#123;</span><br><span class="line">        newArray[index++] = b[bIndex++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> end = Calendar.getInstance().getTime().getTime();</span><br><span class="line">    System.out.println(end - start);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>35. Recover Rotate Sorted Array</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/38.Recover%20Rotated%20Sorted%20Array/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/38.Recover%20Rotated%20Sorted%20Array/</url>
      
        <content type="html"><![CDATA[<ol start="35"><li>Recover Rotate Sorted Array<br><strong>Level : Easy</strong></li></ol><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Given a rotated sorted array, recover it to sorted array in-place.</p><p><strong>Clarification</strong><br>What is rotated array?<br>    For example, the orginal array is [1,2,3,4], The rotated array of it can be [1,2,3,4], [2,3,4,1], [3,4,1,2], [4,1,2,3]<br>Example<br>[4, 5, 1, 2, 3] -&gt; [1, 2, 3, 4, 5]</p><p>Challenge<br>In-place, O(1) extra space and O(n) time.</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>思路类似于Problem8 Rotate String<br>可先将左边部分翻转，再将右边部分翻转，然后再全部翻转</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recoverRotatedSortedArray</span><span class="params">(List&lt;Integer&gt; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;nums.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.get(i) &gt; nums.get(i+<span class="number">1</span>))&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//翻转左边</span></span><br><span class="line">           rotate(nums,<span class="number">0</span>,i);</span><br><span class="line">           <span class="comment">//翻转右边</span></span><br><span class="line">           rotate(nums,i+<span class="number">1</span>,nums.size()-<span class="number">1</span>);</span><br><span class="line">           <span class="comment">//全部翻转</span></span><br><span class="line">           rotate(nums,<span class="number">0</span>,nums.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    System.out.println(nums);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List&lt;Integer&gt; nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = end;</span><br><span class="line">    <span class="keyword">for</span>(;i&lt;j;i++,j--)&#123;</span><br><span class="line">        Integer temp = nums.get(i);</span><br><span class="line">        nums.set(i,nums.get(j));</span><br><span class="line">        nums.set(j,temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2.Trailing Zeros</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/2.Trailing%20Zeros/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/2.Trailing%20Zeros/</url>
      
        <content type="html"><![CDATA[<p>2.Trailing Zeros<br><strong>Level : Easy</strong><br><a id="more"></a></p><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Write an algorithm which computes the number of trailing zeros in n factorial.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:  11</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">11! = 39916800, so the output should be 2</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:  5</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">5! = 120, so the output should be 1.</span><br></pre></td></tr></table></figure></p><!-- **Challenge**O(log N) time --><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>这道题的意思是给定一个数字，求出这个数字的阶乘结果尾部的0的个数。最好是代码的时间复杂度是O(log N)。<br>比如11的阶乘是39916800，末尾有2个0，所以结果是2。</p><p>我看到这道题的时候第一想法就是先求出这个数的阶乘，然后再计算末尾的0的个数。这样是最简单的，也最好实现，但是这种算法的时间复杂度是O(N)，这里就不对这种方法做过多的解释了。</p><p>接下来说一种复杂度更低，性能更高的方法:<br>两数相乘，要想末尾出现0，那么这两个数需要达成以下两个条件的其中一个:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.其中一个数末尾是0</span><br><span class="line">2.其中一个数末尾是5，另一个数是偶数</span><br></pre></td></tr></table></figure></p><p>通过这两个条件，我们可以想到，只要是阶乘中能整除5的数，就一定能使得阶乘结果的末尾多一个0，比如15，它和任何偶数相乘都能使结果的末尾是0。<br>那么如果给定一个整数n，它的阶乘结果末尾的0就是n/5。但是是这样吗？并不是！<br>我们再来想想，当n的阶乘中有一个数是25的时候，他能带来几个0呢？很明显，是两个!  25<em>4=100,25</em>8=200….<br>当阶乘中有一个数是50呢？  50<em>4=200,50</em>6=300。到这里，我们可以想到，如果是5的平方的倍数，那它能带来两个0。<br>那么如果是5的三次方的倍数呢？ 125<em>8 = 1000,125</em>16 = 2000…很明显，阶乘中的每一个5的三次方的倍数都能带来三个0。<br>….</p><p>根据上面的思路，可以看出:<br>n的阶乘末尾的0的个数 = n/5 + n/5^2 + n/5^3 +…</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">trailingZeros</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        sum += n / <span class="number">5</span>;</span><br><span class="line">        n /= <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>8.Rotate String</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/8.Rotate%20String/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/8.Rotate%20String/</url>
      
        <content type="html"><![CDATA[<p>8.Rotate String<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Given a string and an offset, rotate string by offset. (rotate from left to right)</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset = 3</span><br><span class="line">Output:&quot;efgabcd&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset = 0</span><br><span class="line">Output: &quot;abcdefg&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset = 1</span><br><span class="line">Output: &quot;gabcdef&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br><span class="line"></span><br><span class="line">Example 4</span><br><span class="line">Input: str=&quot;abcdefg&quot;, offset =2</span><br><span class="line">Output:&quot;fgabcde&quot;</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">  Given a string and an offset, rotate string by offset. (rotate from left to right)</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>Rotate in-place with O(1) extra memory.</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>字符串翻转<br>1.先全部翻转，再将左边翻转，最后将右边翻转<br>2.先将左边翻转，再将右边翻转，最后全部翻转</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RotateString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"cppjavapy"</span>;</span><br><span class="line">        rotate(str.toCharArray(),<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">char</span>[] str,<span class="keyword">int</span> offset)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        offset %= str.length;</span><br><span class="line"></span><br><span class="line">        rotate(str,<span class="number">0</span>,str.length-<span class="number">1</span>);</span><br><span class="line">        rotate(str,<span class="number">0</span>,offset-<span class="number">1</span>);</span><br><span class="line">        rotate(str,offset,str.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : str)&#123;</span><br><span class="line">            System.out.print(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">char</span>[] strs,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start,j=end;i&lt;j;i++,j--)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = strs[i];</span><br><span class="line">            strs[i] = strs[j];</span><br><span class="line">            strs[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>13.Implement strStr</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/13.Implement%20strStr/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/13.Implement%20strStr/</url>
      
        <content type="html"><![CDATA[<p>13.Implement strStr<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>For a given source string and a target string, you should output the first index(from 0) of target string in source string.</p><p>If target does not exist in source, just return -1.</p><p><strong>Clarification</strong><br>Do I need to implement KMP Algorithm in a real interview?</p><p>Not necessary. When you meet this problem in a real interview, the interviewer may just want to test your basic implementation ability. But make sure you confirm with the interviewer first.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: source = &quot;source&quot; ，target = &quot;target&quot;</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">If the source does not contain the target content, return - 1.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:source = &quot;abcdabcdefg&quot; ，target = &quot;bcd&quot;</span><br><span class="line">Output: 1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">If the source contains the target content, return the location where the target first appeared in the source.</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>O(n2) is acceptable. Can you implement an O(n) algorithm? (hint: KMP)</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>查询模式串在主串中首次出现的位置<br>BF算法<br>RK算法<br>KMP算法<br>。。。<br>根据题目,这里使用KMP算法</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">strStr</span><span class="params">(String source, String target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(source==<span class="keyword">null</span> || target == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">""</span>.equals(source) &amp;&amp; <span class="string">""</span>.equals(target))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">""</span>.equals(source) &amp;&amp; !<span class="string">""</span>.equals(target))&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="string">""</span>.equals(source) &amp;&amp; <span class="string">""</span>.equals(target))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[target.length()];</span><br><span class="line">    next(target, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt; source.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || source.charAt(i) == target.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(j == target.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">(String target, <span class="keyword">int</span>[] next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//前缀位置</span></span><br><span class="line">    <span class="keyword">int</span> j = -<span class="number">1</span>;  <span class="comment">//后缀位置</span></span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; next.length-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j == -<span class="number">1</span> || target.charAt(i) == target.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>14.First Position of Target</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/14.%20First%20Position%20of%20Target/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/14.%20First%20Position%20of%20Target/</url>
      
        <content type="html"><![CDATA[<p>14.First Position of Target<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>For a given sorted array (ascending order) and a target number, find the first index of this number in O(log n) time complexity.</p><p>If the target number does not exist in the array, return -1.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:  [1,4,4,5,7,7,8,9,9,10]，1</span><br><span class="line">Output: 0</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">the first index of  1 is 0.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input: [1, 2, 3, 3, 4, 5, 10]，3</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">the first index of 3 is 2.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: [1, 2, 3, 3, 4, 5, 10]，6</span><br><span class="line">Output: -1</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">Not exist 6 in array.</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>If the count of numbers is bigger than 2^32, can your code work properly?</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>给定一个有序数组和一个目标数，找出该目标数在有序数组中第一次出现的位置<br>因为给定的是有序数组，所以采用二分法比较合适。<br>需要考虑的问题:<br>1.数组中的数可能会有重复的<br>    一旦找到和目标数相等的数，不能停下来，要继续往前推进，直至找到第一次出现的位置<br>2.如果数组长度大于2^32该怎么处理<br>    目前能想到的思路就是拆分数组然后再处理</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end= nums.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">while</span>((mid = --mid) &gt;= <span class="number">0</span> &amp;&amp; nums[mid] == target)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ++mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; target)&#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target)&#123;</span><br><span class="line">            start = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>6.Flatten List</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/22.Flatten%20List/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/22.Flatten%20List/</url>
      
        <content type="html"><![CDATA[<p>6.Flatten List<br><strong>Level : Easy</strong></p><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Given a list, each element in the list can be a list or integer. flatten it into a simply list with integers.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:  [[1,1],2,[1,1]]</span><br><span class="line">Output: [1,1,2,1,1]</span><br><span class="line"></span><br><span class="line">Explanation:</span><br><span class="line">flatten it into a simply list with integers.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:  [1,2,[1,2]]</span><br><span class="line">Output:[1,2,1,2]</span><br><span class="line"></span><br><span class="line">Explanation:  </span><br><span class="line">flatten it into a simply list with integers.</span><br><span class="line"></span><br><span class="line">Example 3:</span><br><span class="line">Input: [4,[3,[2,[1]]]]</span><br><span class="line">Output:[4,3,2,1]</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">flatten it into a simply list with integers.</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>Do it in non-recursive.</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>比较简单，看代码。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @param nestedList a list of NestedInteger</span></span><br><span class="line">    <span class="comment">// @return a list of integer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">flatten</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> hasList = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(hasList)&#123;</span><br><span class="line">            List&lt;NestedInteger&gt; nestedIntegerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            hasList = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(NestedInteger nestedInteger : nestedList)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nestedInteger.isInteger())&#123;</span><br><span class="line">                    nestedIntegerList.add(nestedInteger);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    nestedIntegerList.addAll(nestedInteger.getList());</span><br><span class="line">                    hasList = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            nestedList = nestedIntegerList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span>(NestedInteger nestedInteger : nestedList)&#123;</span><br><span class="line">             list.add(nestedInteger.getInteger());</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法用时3109 ms</p><hr><p>优化:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * public interface NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer,</span></span><br><span class="line"><span class="comment"> *     // rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     public boolean isInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds,</span></span><br><span class="line"><span class="comment"> *     // if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     public Integer getInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds,</span></span><br><span class="line"><span class="comment"> *     // if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// @param nestedList a list of NestedInteger</span></span><br><span class="line">    <span class="comment">// @return a list of integer</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">flatten</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nestedList.size() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> hasList = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(hasList)&#123;</span><br><span class="line">            hasList = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nestedList.size();i++)&#123;</span><br><span class="line">                <span class="comment">// NestedInteger nestedInteger = nestedList.get(i);</span></span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!nestedList.get(i).isInteger())&#123;</span><br><span class="line">                </span><br><span class="line">                    nestedList.addAll(i+<span class="number">1</span>,nestedList.get(i).getList());</span><br><span class="line">                    nestedList.remove(i);</span><br><span class="line">                    hasList = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// nestedList = nestedIntegerList;</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">         List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">         <span class="keyword">for</span>(NestedInteger nestedInteger : nestedList)&#123;</span><br><span class="line">             list.add(nestedInteger.getInteger());</span><br><span class="line">         &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>优化后用时2823ms</p>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>28. Search a 2D Matrix</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/28.%20Search%20a%202D%20Matrix/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/28.%20Search%20a%202D%20Matrix/</url>
      
        <content type="html"><![CDATA[<ol start="28"><li>Search a 2D Matrix<br><strong>Level : Easy</strong></li></ol><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Write an efficient algorithm that searches for a value in an m x n matrix.</p><p>This matrix has the following properties:</p><p>Integers in each row are sorted from left to right.<br>The first integer of each row is greater than the last integer of the previous row.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:  [[5]],2</span><br><span class="line">Output: false</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">false if not included.</span><br><span class="line"></span><br><span class="line">Example 2:</span><br><span class="line">Input:  [</span><br><span class="line">    [1, 3, 5, 7],</span><br><span class="line">    [10, 11, 16, 20],</span><br><span class="line">    [23, 30, 34, 50]</span><br><span class="line">],3</span><br><span class="line">Output: true</span><br><span class="line"></span><br><span class="line">Explanation: </span><br><span class="line">return true if included.</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>O(log(n) + log(m)) time</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>思路1:<br>将二维数组转换为一维数组，然后做二分查找，时间复杂度O(n^2)</p><p>思路2:<br>对每一个子数组做二分查找，时间复杂度O(mlogn)</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>思路1:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchA2DMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>,<span class="number">7</span>&#125;, &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>&#125;, &#123;<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">50</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        SearchA2DMatrix searchA2DMatrix = <span class="keyword">new</span> SearchA2DMatrix();</span><br><span class="line">        <span class="keyword">boolean</span> result = searchA2DMatrix.searchMatrix(matrix, target);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = matrix.length * matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                arr[arrIndex] = matrix[i][j];</span><br><span class="line">                arrIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pos = binarySearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>,target);</span><br><span class="line">        <span class="keyword">if</span> (pos != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>思路2:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchA2DMatrix2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>,<span class="number">7</span>&#125;, &#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">16</span>,<span class="number">20</span>&#125;, &#123;<span class="number">23</span>,<span class="number">30</span>,<span class="number">34</span>,<span class="number">50</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">        SearchA2DMatrix2 searchA2DMatrix = <span class="keyword">new</span> SearchA2DMatrix2();</span><br><span class="line">        <span class="keyword">boolean</span> result = searchA2DMatrix.searchMatrix(matrix, target);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][<span class="number">0</span>] &lt;= target &amp;&amp; matrix[i][matrix[i].length-<span class="number">1</span>] &gt;= target) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = binarySearch(matrix[i], <span class="number">0</span>, matrix[i].length - <span class="number">1</span>, target);</span><br><span class="line">                <span class="keyword">if</span> (pos != -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = end;</span><br><span class="line">        <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid] &gt; target) &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>35. Reverse Linked List</title>
      <link href="/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/35.Reverse%20Linked%20List/"/>
      <url>/hlblog/2018/12/13/%E5%88%B7%E9%A2%98/LintCode/35.Reverse%20Linked%20List/</url>
      
        <content type="html"><![CDATA[<ol start="35"><li>Reverse Linked List<br><strong>Level : Easy</strong></li></ol><a id="more"></a><h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p><strong>Description</strong><br>Reverse a linked list.</p><p><strong>Example</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example1:</span><br><span class="line">For linked list 1-&gt;2-&gt;3, the reversed linked list is 3-&gt;2-&gt;1</span><br><span class="line">Example2:</span><br><span class="line">For linked list 1-&gt;2-&gt;3-&gt;4, the reversed linked list is 4-&gt;3-&gt;2-&gt;1</span><br></pre></td></tr></table></figure></p><p><strong>Challenge</strong><br>Reverse it in-place and in one-pass</p><h1 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h1><p>单链表翻转，要求原地一次翻转完成。</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>非递归方式翻转:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode next;</span><br><span class="line"></span><br><span class="line">    ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">        val = x;</span><br><span class="line">        next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReverseLinkedList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ListNode node1 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode node2 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">        node1.next = node2;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ReverseLinkedList reverseLinkedList = <span class="keyword">new</span> ReverseLinkedList();</span><br><span class="line">        ListNode newHead = reverseLinkedList.reverse(node1);</span><br><span class="line">        System.out.println(newHead.val+<span class="string">" "</span>+newHead.next.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = next;</span><br><span class="line">            next = next.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> LintCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LintCode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>担保支付1.0业务理解</title>
      <link href="/hlblog/2018/12/10/%E4%B8%9A%E5%8A%A1/%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3/"/>
      <url>/hlblog/2018/12/10/%E4%B8%9A%E5%8A%A1/%E6%94%AF%E4%BB%98%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>线上直付、担保支付、委受托支付、穿透支付、归集支付</p><a id="more"></a><h1 id="支付"><a href="#支付" class="headerlink" title="支付"></a>支付</h1><h2 id="线上直付"><a href="#线上直付" class="headerlink" title="线上直付"></a>线上直付</h2><p>A(付款方) to B(收款方)<br>A可用 to B可用<br>A：<br>add flow<br><strong>update wallet,reduce money available</strong><br>add payment<br>send message<br>update Order/Contract Group<br>B：<br>add flow<br><strong>update wallet,add money available</strong><br>add payment<br>send message<br>update Order/Contract Group</p><hr><h2 id="担保支付"><a href="#担保支付" class="headerlink" title="担保支付"></a>担保支付</h2><p>担保支付即买方将货款付给买卖双方之外的第三方，第三方收到款项后通知已收到买方货款，并同时通知卖方发货，卖方即可将货物发运给买方，买方通知第三方收到满意的卖方货物，第三方便将货款付给卖方。目前在电子商务领域应用广泛。</p><p>A(付款方) to B(收款方)<br>A可用 to A冻结  (解冻？？)<br>add flow<br><strong>update wallet,A available to A freeze</strong><br>add payment<br>send message<br>update Order/Contract Group</p><h2 id="委受托支付"><a href="#委受托支付" class="headerlink" title="委受托支付"></a>委受托支付</h2><p>委受托支付 是专款专用的，冻结资金只能在订单内进行支付,例如A、B、C1、 C2签订了买卖合同，B只能用A付给B的钱去支付给C。<br>A B C之间的关系可参考  如皋-康迪-供应商</p><h3 id="委托支付"><a href="#委托支付" class="headerlink" title="委托支付"></a>委托支付</h3><p>A(付款方) to B(收款方)<br>A可用 to B冻结<br>A：<br>add flow<br><strong>update wallet,reduce A available money</strong><br>add payment<br>send message<br>update Order/Contract Group</p><p>B：<br>add flow<br><strong>update wallet,add B freeze money</strong><br>add payment<br>send message<br>update Order/Contract Group</p><h3 id="受托支付"><a href="#受托支付" class="headerlink" title="受托支付"></a>受托支付</h3><p>B(付款方) to C(收款方)<br>依赖于委托支付，受托支付中B给C付款只能使用委托支付中A付给B的款<br>两个金额: A付给B的金额   B已使用的金额<br>B冻结 to C冻结<br>B：<br>add flow<br><strong>update wallet,reduce B freeze money</strong><br>add payment<br>send message<br>update Order/Contract Group</p><p>C：<br>add flow<br><strong>update wallet,add C freeze money</strong><br>add payment<br>send message<br>update Order/Contract Group</p><h2 id="穿透支付"><a href="#穿透支付" class="headerlink" title="穿透支付"></a>穿透支付</h2><p>A(付款方) to B(收款方)  -&gt;  B(付款方，资金来源于A) to C(收款方)<br>A和B需要合同  B和C也许要有合同  形成一个合同组<br>A可用 to B冻结  (类似于2.0里面的担保支付)<br>B冻结 to C冻结<br>A to B -&gt; A：<br>add flow<br><strong>update wallet,reduce A available money</strong><br>add payment<br>send message<br>update Order/Contract Group</p><p>A to B -&gt; B：<br>add flow<br><strong>update wallet,add B freeze money</strong><br>add payment<br>send message<br>update Order/Contract Group </p><p>B to C -&gt; B：<br>add flow<br><strong>update wallet,add reduce freeze money</strong><br>add payment<br>send message<br>update Order/Contract Group </p><p>B to C -&gt; C：<br>add flow<br><strong>update wallet,add add freeze money</strong><br>add payment<br>send message<br>update Order/Contract Group </p><h2 id="归集支付"><a href="#归集支付" class="headerlink" title="归集支付"></a>归集支付</h2><h3 id="资金归集"><a href="#资金归集" class="headerlink" title="资金归集"></a>资金归集</h3><p>资金归集是指将集团公司中所有下属公司指定账户上的资金归集到总公司指定的账户的服务，也称资金清扫。2013年1月初，某股份制商业银行推出一项新业务——可以给老公的银行卡设个存款上限，比如1000元，从此老公卡上的资金只要超过1000元，超过的部分就一分不留地自动划到老婆的银行卡上，不仅不需要每月转账，而且免费转。</p><h1 id="解冻"><a href="#解冻" class="headerlink" title="解冻"></a>解冻</h1><h2 id="申请解冻"><a href="#申请解冻" class="headerlink" title="申请解冻"></a>申请解冻</h2><p><strong>线上直付</strong> : 可用到可用，<font size="3" color="blue">不需要解冻</font></p><p><strong>担保支付</strong> : 付款时A可用到A冻结 ，解冻时A冻结到B可用</p><p><strong>委托支付</strong> : 付款时A可用到B冻结 ，解冻时B冻结到B可用</p><p><strong>受托支付</strong> : 付款时B冻结到C冻结 ，解冻时C冻结到C可用</p><p><strong>穿透支付</strong> : A付款时A可用到B冻结，然后B付款时B冻结到C冻结，解冻时C冻结到C可用</p><!-- **穿透支付** : 付款时A可用到B冻结 ，解冻时B冻结到B可用 --><h2 id="确认解冻"><a href="#确认解冻" class="headerlink" title="确认解冻"></a>确认解冻</h2><p><strong>担保支付</strong> : A冻结到B可用</p><p><strong>委托支付</strong> : B冻结到B可用</p><p><strong>受托支付</strong> : C冻结到C可用</p><p><strong>穿透支付</strong> : B冻结到B可用，C冻结到C可用</p>]]></content>
      
      
      <categories>
          
          <category> 业务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 业务 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>索引入门</title>
      <link href="/hlblog/2018/12/08/mysql/%E7%B4%A2%E5%BC%95/"/>
      <url>/hlblog/2018/12/08/mysql/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在数据本身以外，mysql还维护着一个满足特定查找算法的数据结构，这种数据结构中的数据以某种方式指向数据库中的用户数据，这样就可以在这种数据结构的基础上实现高效的查找算法，这种数据结构就是索引。<br>索引就是一种可以帮助mysql高效查询数据的数据结构，可以简单理解为已经排好序的快速查找数据结构。</p><p>由于内存中的数据重启计算机以后就会丢失，并且在很多情况下索引的大小甚至要比数据本身还要大，不大可能全部保存在内存中，因此索引一般以索引文件的形式保存在磁盘上。</p><h2 id="优势和劣势"><a href="#优势和劣势" class="headerlink" title="优势和劣势"></a>优势和劣势</h2><p><strong>优势</strong><br>1.IO成本: 索引能够提高查询效率，降低了数据库的IO成本<br>2.CPU成本: 通过索引对数据进行排序，能够降低数据排序的成本，降低了CPU的消耗。</p><p><strong>劣势</strong><br>1.空间成本: 索引本身也会占据一定的空间，甚至它所占的空间可能比数据本身还要大<br>2.维护成本: 索引并不是一次创建永久有效的，对相关数据的每一次修改都要同时修改对应的索引，如果是频繁修改的数据，那么索引的维护成本也会非常之高。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><p><strong>按功能</strong><br>单值索引<br>复合索引<br>唯一索引<br>聚簇索引<br>覆盖索引</p><p><strong>按结构</strong><br>BTREE索引<br>RTREE索引<br>hash索引<br>full-text全文索引</p><h2 id="适用场合与非适用场合"><a href="#适用场合与非适用场合" class="headerlink" title="适用场合与非适用场合"></a>适用场合与非适用场合</h2><p><strong>适用场合</strong><br>1.数据库会自动为每张表的主键建立唯一索引<br>2.如果是频繁作为查询条件的字段，应该建立索引<br>3.查询中与其他表关连的字段应该建立索引<br>4.查询中排序的字段应该建立索引，可以大大增加排序速度<br>5.查询中统计或者分组字段</p><p><strong>非适用场合</strong><br>1.频繁更新的字段不适合建立索引<br>2.频繁增删改的表不适合建立索引<br>3.查询中用不到的字段不适合建立索引<br>4.表记录太少的情况下没必要建立索引</p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><!-- 主键索引的叶子节点存的是整行数据。非主键索引的叶子节点内容是主键的值。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是8个字节。<font color=red size=3>主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</font>覆盖索引:在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称之为覆盖索引 --><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><ol><li><p>最佳左前缀法则: 如果索引了多列,要遵守最佳左前缀法则,指的是查询从索引的最左前列开始并且不跳过索引中的列.查询时所用字段尽量与索引中的字段进行全值匹配</p></li><li><p>不在索引列上做任何操作,如计算,函数,类型转换(自动/手动),会导致索引失效而转向全表扫描</p></li><li><p>存储引擎不能使用范围条件右边的列,范围以后索引全失效</p></li><li><p>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select*的使用</p></li><li><p>mysql在使用不等于 != / &lt;&gt; 的时候无法使用索引会导致全表扫描</p></li><li><p>is null , is not null也无法使用索引</p></li><li><p>like以通配符开头会导致索引失效导致全表扫描</p></li><li><p>varchar类型(字符串类型)不加单引号会导致索引失效</p></li><li><p>使用or连接时会导致索引失效</p></li></ol><hr><p>优化器会在索引存在的情况下，通过符合 RANGE 范围的条数和总数的比例来选择是使用索引还是进行全表遍历<br>当需要读取的数据超过一个临界值时，优化器会放弃从索引中读取而改为进行全表扫描</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>一些简单的sql优化手段</title>
      <link href="/hlblog/2018/12/08/mysql/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84sql%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/"/>
      <url>/hlblog/2018/12/08/mysql/%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84sql%E4%BC%98%E5%8C%96%E6%89%8B%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用Explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的，分析你的查询语句或者是表结构的性能瓶颈。    </p><p>通过执行计划可以得出以下信息:</p><ol><li>表的读取顺序</li><li>数据读取操作的操作类型</li><li>哪些索引可以使用</li><li>哪些索引被实际使用</li><li>表之间的引用</li><li>每张表有多少行被优化器查询</li></ol><p>使用方式:<br>explain+sql语句</p><p>explain所包含的信息主要有id、select_type、table、type、possible_keys、key、key_len、ref、rows、Extra等等。</p><h2 id="详情"><a href="#详情" class="headerlink" title="详情"></a>详情</h2><p><strong>id</strong><br>id是selec查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序。<br>id一般有三种情况:<br>id相同: 执行顺序由上至下<br>id不同: 如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行<br>id相同和不同同时存在: id相同的可以认为是一组，一组之中按顺序从上往下执行，在所有的组中，id越大的优先级越高，越先被执行。</p><p><strong>select_type</strong><br>查询的类型，主要用于区别普通查询、联合查询、子查询等复杂查询。</p><ol><li>SIMPLE              简单的select查询，不包含子查询或者union</li><li>PRIMARY             查询中如果包含任意的子查询部分，则最外层被标记为PRIMARY</li><li>SUBQUERY            在select或者WHERE列表中包含了子查询</li><li>DERIVED             在from列表中中包含的子查询会被标记为DERIVED，mysql会递归的执行这些子查询，把结果放在临时表里。</li><li>UNION               如果第二个select出现在union之后，则会被标记为union,如果union包含在from子句的子查询中，外层被标记为DERIVED。</li><li>UNION RESULT        从union表获取结果的select</li></ol><p><strong>table</strong><br>显示这一行数据是关于哪张表的</p><p><strong>type</strong><br>访问类型排列，可以反映查询语句的性能<br>从最好到最差的完整指标:<br>system &gt; const &gt; eq_ref &gt; ref &gt; fulltest &gt; ref_or_null &gt; index_merge &gt; unique_query &gt; index_subquery &gt; range &gt; index &gt; all    </p><p>比较常见的:<br>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all<br>一般来说，查询语句最好能保持在range以上。</p><p><strong>possible_keys</strong><br>表示可能应用在这张表中的一个或多个索引，查询设计到的字段如果存在索引，则此索引将被列出，但是不一定会被实际使用</p><p><strong>key</strong><br>实际使用的索引，如果该字段为NULL,则没有使用索引，查询中如果使用了覆盖索引，则该索引和查询的select字段重叠。</p><p><strong>key_len</strong><br>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。<br>key_len显示的值是索引字段最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的。</p><p><strong>ref</strong><br>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p><strong>rows</strong><br>根据表的统计信息及索引的选用情况，大致估算出找到所需的记录所需要读取的行数。</p><p><strong>Extra</strong><br>包含不适合在其他列中显示但十分重要的额外信息</p><p> Using filesort<br> 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，MYSQL中无法使用索引完成的排序成为”文件排序”。</p><p>Using temporary<br>使用了临时表保存中间结果，mysql在对查询结果排序时使用了临时表，常见于排序order by和分组group by.</p><p>Using index<br>表示相应的select语句中使用了覆盖索引，避免了访问的表的数据行，效率不错。<br>如果同时出现using where,表明索引被用来执行索引键值的查找,虽然用到了索引，但是没有索引覆盖，产生了回表。<br>如果没有同时出现using where，表明索引用来执行读取数据而非执行查找动作。</p><p>Using where<br>表明使用了where过滤。<br>有一种情况，就是说使用了覆盖索引，但是还有额外的where条件，最后虽然使用了索引，但是extra却不显示using  index</p><p>using index condition<br><!-- ICP用于range，ref，eq_ref，和ref_or_null访问方法时，需要访问完整的表行 --><br>ICP的目的是减少全行读取的次数，从而减少IO操作<br>查询的列不全在索引中，还需要进行额外的字段过滤</p><p>NULL<br>意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引，Extra中为NULL</p><p>using where;using index &amp;&amp; using index condition &amp;&amp; NULL<br>NULL : 索引用到了，但是部分字段没有被索引覆盖，同时，where条件中没有额外的需要回表的条件(比如范围判断)<br>using where;using index : 索引用到了，字段被索引覆盖了，where条件有需要回表的条件(比如范围判断)<br>using index condition : 索引用到了，但是部分字段没有被索引覆盖，同时，where条件中有会产生回表的条件(比如范围判断)，或者是有没有建立索引的字段</p><p>Using join buffer<br>使用了连接缓存</p><p>impossible where<br>where子句的值总是false，不能用来查询任何元素。</p><p>select tables optimized away<br>在没有group by的情况下，基于索引优化MIN/MAX操作或者对于MYISAM引擎优化count(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p><p>distinct<br>优化distinct操作，在找到匹配的第一行元素以后停止继续寻找同样值的动作。 </p><hr><h1 id="order-by和group-by优化"><a href="#order-by和group-by优化" class="headerlink" title="order by和group by优化"></a>order by和group by优化</h1><p><strong>order by优化</strong><br>Mysql支持两种排序方式,Index和FileSort.</p><p>Index方式 :<br>Index方式效率比较高,它是指MySql扫描索引本身完成排序<br>以下两种情况会使用Index排序方式:<br>1.OrderBy子句使用索引最佳左前列<br>2.使用Where子句与OrderBy子句条件列组合满足索引最左前列</p><p>FileSort方式:<br>如果不在索引列上排序,就会使用FiIeSort方式<br>FileSort方式有两种排序算法,双路排序和单路排序<br>1.双路排序: 从磁盘读取排序字段,在buffer中排序,再根据排序结果从磁盘中读取其他字段.取一批字段要对磁盘进行两次扫描.<br>2.单路排序: IO是很耗时的,所以Mysql4.1以后出现了另一种算法,单路排序算法,这种算法回一次将所有的列都读出来,在buffer中对它们进行排序,这样避免了二次IO,并且把随机IO变成了顺序IO,所以它的效率更快.但是它更加的浪费空间,因为它把所有的数据都放在了buffer中.<br>单路排序的弊端 : 用来排序的buffer是有限的,如果需要取出的数据量大于buffer,就会导致每次只能查出buffer大小的数据量,这样就可能造成多次IO,得不偿失<br>解决思路:<br>1.增大sort_buffer_size参数<br>2.增大max_length_for_sort_data参数</p><p><strong>group by优化</strong><br>GroupBy子句的实质是先排序后分组,遵循索引键的最佳左前缀<br>增大sort_buffer_size参数和max_length_for_sort_data参数<br>Where高于Having,能写在Where限定的条件,就不要去having限定了</p><hr><h1 id="in和exists"><a href="#in和exists" class="headerlink" title="in和exists"></a>in和exists</h1><p>多表联查时,永远是小表驱动大表,即小的数据集驱动大的数据集</p><p>Select * from A where id in (select id from B)<br>当B的数据集必须小于A的数据集时,使用in优于exists</p><p>Select * from A where exists (select 1 from B where B.id = A.id)<br>此处注意:A表与B表相关联的字段应该建立索引</p><p>Exists(subquery)<br>select * from table Where Exists(subquery)<br>该语法可以理解为: 将主查询到数据放到子查询中去做条件验证,根据验证结果(true/false)来决定主查询得到的数据结果是否得以保留</p><p>提示:<br>Exists(subquery)只返回true/false,因此    子查询 中可以是select* 也可以使select 1 或者select ‘X’,官方的说法是实际执行时会忽略select清单,因此没有区别</p><h1 id="慢查询日志和SHOW-PROFILE"><a href="#慢查询日志和SHOW-PROFILE" class="headerlink" title="慢查询日志和SHOW PROFILE"></a>慢查询日志和SHOW PROFILE</h1><p>什么是慢查询日志</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Condition源码理解</title>
      <link href="/hlblog/2018/12/07/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/Condition%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/"/>
      <url>/hlblog/2018/12/07/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/Condition%E6%BA%90%E7%A0%81%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在AQS简介这一章里讲到过AQS中有两个队列，一个是CLH队列，一个是Condition条件等待队列。CLH队列已经在前面做过分析，今天通过这篇文章来分析一下条件等待队列及其与CLH队列的关系。</p><a id="more"></a><h1 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使当前线程进入等待状态直到它被唤醒或者被中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使当前线程进入等待状态直到它被唤醒，不响应中断</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////使当前线程进入等待状态，指定时间后自动退出等待状态</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使当前线程进入等待状态，指定时间后自动退出等待状态，返回值为是否已经超过等待时间</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使当前线程进入等待状态直到某个时间点，返回值为是否已经吵过指定的时间点</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒一个线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒等待中的全部线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h1><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//将当前线程封装为新的节点，加入到等待队列以后返回这个节点。</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//将当前节点持有的同步状态全部释放</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//这里会阻塞线程，当它被通知唤醒或者当前线程被中断以后，</span></span><br><span class="line">        <span class="comment">//阻塞的线程就会恢复继续往下执行</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//checkInterruptWhileWaiting方法: 检查线程中断状态，用来响应中断</span></span><br><span class="line">        <span class="comment">//如果在取消等待之前已经被中断了，就抛出异常，如果在取消等待以后被中断了，就从新设置中断状态</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点独占式获取同步状态，获取成功才会退出此方法</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) </span><br><span class="line">        <span class="comment">//清除条件等待队列中的已取消等待(状态不为Condition)的节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//被唤醒以后处理中断状态</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将线程封装成新节点加入到条件等待队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果等待队列中的最后一个节点已经取消了，就将它清除出去</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将当前线程封装成一个新的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="comment">//*********个人认为这个if else里的操作应该是线程不安全的，暂时没明白这里是怎么规避这个问题的</span></span><br><span class="line">    <span class="comment">//明白了: Condition一般都是配合独占锁进行使用，创建Condition实例只能使用AQS实现类所实现的newCondition方法来创建</span></span><br><span class="line">    <span class="comment">//在整个jdk1.8中，Condition几乎都是配合ReentrentLock一起使用的。</span></span><br><span class="line">    <span class="comment">//在执行这个方法的时候一定是已经持有了独占锁的，所以这里就不存在线程安全问题了。</span></span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//注意这里设置的是nextWaiter，而不是CLH队列中才会用到的next</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>判断节点是否在CLH队列中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CLH队列中的节点，waitStatus绝不可能是Node.CONDITION，</span></span><br><span class="line">    <span class="comment">//如果node.prev == null,这个节点肯定不会在CLH队列中，因为这个时候它没有获取同步状态，所以就不可能是头结点</span></span><br><span class="line">    <span class="comment">//在CLH队列中，如果不是头结点，那么node.prev不可能为null</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从CLH队列的尾节点开始，倒叙遍历整个CLH队列，寻找当前节点。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">findNodeFromTail</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == node)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        t = t.prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个interruptMode，这个interruptMode有三种情况</span></span><br><span class="line"><span class="comment">//THROW_IE : 线程被中断了并且是在signal之前被中断的</span></span><br><span class="line"><span class="comment">//REINTERRUPT : 线程被中断并且是在signal之后被中断的</span></span><br><span class="line"><span class="comment">//0: 未中断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果节点在是在signal之前被中断的，返回true</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果此时当前节点的等待状态还是Node.Condition，说明当前节点是signal之前被中断的</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面的CAS失败了才会到这里，到这里就说明当前的节点是在signal之后被中断的。</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除条件等待队列中状态不为Condition的节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>处理中断状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportInterruptAfterWait</span><span class="params">(<span class="keyword">int</span> interruptMode)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (interruptMode == THROW_IE)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (interruptMode == REINTERRUPT)</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断当前线程是否持有独占锁，只有持有独占锁的线程才能执行通知操作。</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从头往后遍历找到第一个需要转移到CLH队列的节点，将它转移到CLH队列的尾端</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">                (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果CAS失败了，说明该节点已经取消了等待</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自旋进入阻塞队列的队尾</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//ws &gt; 0,说明该节点已经被取消了</span></span><br><span class="line">    <span class="comment">//CAS失败说明ws在此期间被修改了</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>AQS中的ConditionObject对这个接口进行了实现，为AQS提供了条件等待队列。</p><p>await方法：<br>1.生成新节点并添加到条件队列中<br>2.释放线程所持有的全部锁，包括重入锁<br>3.自旋等待进入阻塞队列，检测自己在不在阻塞队列中，如果不在，就阻塞等待被唤醒后进入阻塞队列<br>4.被唤醒后进入阻塞队列<br>5.获取独占锁<br>6.清除条件等待队列中状态不为Condition的节点<br>7.处理中断状态</p><p>signal方法：<br>1.判断当前线程是否持有锁，没有的话抛出异常<br>2.从头往后遍历找到第一个需要转移到CLH队列的节点，将它转移到CLH队列的尾端</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>事务的隔离级别</title>
      <link href="/hlblog/2018/12/07/mysql/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/hlblog/2018/12/07/mysql/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>SQL标准的隔离级别总共有四个: 读未提交，读已提交，可重复读，串行化读。如果隔离级别使用不当，在多个事务并发执行的时候就可能会遇到脏读、幻读、不可重复读等问题。</p><a id="more"></a><h1 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h1><p>脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个未提交的数据。</p><h1 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h1><p>第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</p><h1 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h1><p>是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</p><h1 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h1><p>读未提交级别下，事务还未提交，它做的更新就能被别的事务看到。<br>读未提交可能会产生脏读、幻读、不可重复读问题。</p><h1 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h1><p>读已提交级别下，事务提交之后，它做的更新才能被别的事务看到。<br>读已提交解决了脏读的问题，但是还是有可能出现幻读和不可重复读的问题。</p><h1 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h1><p>可重复读级别下，一个事务执行过程中看到的数据，始终与事务开始时看到的数据一致，即使有其他事务对这条数据做了修改也没有影响。同时，事务在可重复读级别下做的更新也必须等到提交以后才能被其他事务看到，这点和读已提交是一样的。<br>可重复读解决了不可重复读的问题，但是还是有可能出现幻读。</p><h1 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h1><p>对于同一条记录，写操作会加‘写锁’，读操作会加‘读锁’，当遇到读写冲突的时候，后面的事务必须等到前面的事务完成以后才能继续进行。<br>串行化解决幻读问题，这是目前最高的隔离级别，彻底解决了脏读、幻读、不可重复读的问题，但是它的吞吐量也是最低的。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LockSupport</title>
      <link href="/hlblog/2018/12/07/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%94%81/LockSupport/"/>
      <url>/hlblog/2018/12/07/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%94%81/LockSupport/</url>
      
        <content type="html"><![CDATA[<!-- mores -->]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>秒杀系统设计专题</title>
      <link href="/hlblog/2018/12/07/%E4%B8%93%E9%A2%98/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/"/>
      <url>/hlblog/2018/12/07/%E4%B8%93%E9%A2%98/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>秒杀系统设计专题</p><a id="more"></a><h1 id="五大原则"><a href="#五大原则" class="headerlink" title="五大原则"></a>五大原则</h1><p>四要一不要:<br>1.数据要尽量少<br>2.请求要尽量少<br>3.路径要尽量短<br>4.依赖要尽量少<br>5.不要有单点</p><h1 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h1><h1 id="热点数据"><a href="#热点数据" class="headerlink" title="热点数据"></a>热点数据</h1><h1 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h1><h1 id="性能提升"><a href="#性能提升" class="headerlink" title="性能提升"></a>性能提升</h1><h1 id="库存扣减"><a href="#库存扣减" class="headerlink" title="库存扣减"></a>库存扣减</h1><h1 id="兜底方案"><a href="#兜底方案" class="headerlink" title="兜底方案"></a>兜底方案</h1>]]></content>
      
      
      <categories>
          
          <category> 专题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 专题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>redolog和binlog</title>
      <link href="/hlblog/2018/12/04/mysql/redolog%E5%92%8Cbinlog/"/>
      <url>/hlblog/2018/12/04/mysql/redolog%E5%92%8Cbinlog/</url>
      
        <content type="html"><![CDATA[<p>参考资料<br><a href="https://zh.wikipedia.org/wiki/%E9%A2%84%E5%86%99%E5%BC%8F%E6%97%A5%E5%BF%97" target="_blank" rel="noopener">维基百科</a><br><a href="https://dev.mysql.com/doc/refman/5.5/en/innodb-redo-log.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/innodb-redo-log.html</a><br><a href="https://dev.mysql.com/doc/refman/5.5/en/innodb-undo-logs.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.5/en/innodb-undo-logs.html</a></p><a id="more"></a><p>其中redolog是InnoDB特有的日志，只有InnoDB引擎可以使用，而binlog是mysql的server层提供的日志，它是可以被所有的引擎使用的。</p><h1 id="WAL"><a href="#WAL" class="headerlink" title="WAL"></a>WAL</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WAL(预写式日志)全称Write-ahead logging,是关系数据库系统中用于提供原子性和持久性（ACID属性中的两个）的一系列技术。在使用WAL的系统中，所有的修改在提交之前都要先写入log文件中。log文件中通常包括redo和undo信息。这样做的目的可以通过一个例子来说明。假设一个程序在执行某些操作的过程中机器断电了。在重新启动时，程序可能需要知道当时执行的操作是成功了还是部分成功或者是失败了。如果使用了WAL，程序就可以检查log文件，并对突然掉电时计划执行的操作内容跟实际上执行的操作内容进行比较。在这个比较的基础上，程序就可以决定是撤销已做的操作还是继续完成已做的操作，或者是保持原样。<br>                                    —–摘自维基百科</p><p>通过维基百科中对WAL的描述，我们已经能够对WAL有个基本的认识,WAL能够通过两种日志文件来保证意外发生时数据库中数据的准确性。</p><h2 id="undolog和redolog"><a href="#undolog和redolog" class="headerlink" title="undolog和redolog"></a>undolog和redolog</h2><p>undolog保存的修改之前的数据，redolog保存的是修改之后的数据。这两个日志可以看做是相反的，比如说如果redolog中记录了一条delete日志，那么undoLog就会对应的记录一条insert日志。</p><h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><p>redolog(重做日志)是一种基于磁盘的数据结构，作用是用来在崩溃恢复期间纠正由未完成的事务写入的数据。在正常操作期间，redolog会记录由sql或者是低级api调用产生的表数据的更改，如果由于断电或者其他意外情况导致mysql崩溃，那么mysql在重启之后，可以借助redolog在初始化期间，客户端与mysql服务器建立连接之前,对崩溃之前未能更新到数据文件的修改进行更新。</p><p>默认情况下,redolog有两个文件ib_logfile0和ib_logfile1，文件个数可以通过参数innodb_log_files_in_group来调整。redolog的文件是循环写入的，从0号文件开始写，写到最后一个文件的末尾处，会再次回到0号文件的开头开始写。<br>这里要顺带提出两个概念: checkpoint和writeposition。checkpoint代表的是上一次将数据持久化到磁盘的位置，持久化以后会把这部分日志给清除，writeposition代表的是当前日志文件写到的位置。所以checkpoint后面以及writeposition前面的部分，都是可用的。如果writeposition一直往前写，最后到达了checkpoint的位置，mysql会停下来先将数据全部持久化到磁盘中，然后将日志清除，等到这两步操作完成，才会继续处理业务。</p><p>redolog的落盘并不是事务提交以后才开始的，而是在事务的执行过程中就逐步落盘了。<br>重做日志有一个缓存区Innodb_log_buffer，Innodb_log_buffer的默认大小为8M(这里设置的16M),Innodb存储引擎先将重做日志写入innodb_log_buffer中。<br>然后会通过以下三种方式将innodb日志缓冲区的日志刷新到磁盘<br>　　1，Master Thread 每秒一次执行刷新Innodb_log_buffer到重做日志文件。<br>　　2，每个事务提交时会将重做日志刷新到重做日志文件。<br>　　3，当重做日志缓存可用空间 少于一半时，重做日志缓存被刷新到重做日志文件</p><p>对应的数据落盘以后，redolog的作用就结束了，这个时候它就可以覆盖了。</p><p>　　默认情况下，对应的物理文件位于数据库的data目录下的ib_logfile1&amp;ib_logfile2<br>　　innodb_log_group_home_dir 指定日志文件组所在的路径，默认./ ，表示在数据库的数据目录下。<br>　　innodb_log_files_in_group 指定重做日志文件组中文件的数量，默认2<br>　　关于文件的大小和数量，由一下两个参数配置<br>　　innodb_log_file_size 重做日志文件的大小。<br>　　innodb_mirrored_log_groups 指定了日志镜像文件组的数量，默认1</p><p>innodb_flush_log_at_trx_commit这个参数设置为1的时候表示每次事务的redolog都持久化到磁盘中，可以保证崩溃以后数据不丢失。</p><h3 id="undolog"><a href="#undolog" class="headerlink" title="undolog"></a>undolog</h3><p>undolog保存了事务发生之前的数据的一个版本，可以用于回滚，同时可以提供多版本并发控制下的读（MVCC）。<br>undolog是在事务发生之前生成的<br>事务提交以后undolog并不会马上被删除，而是会被放入待清理的链表中，由purge线程判断是否由其他事务在使用undo段中表的上一个事务之前的版本信息，决定是否可以清理undo log的日志空间。</p><h1 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h1><p>1，用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。<br>2，用户备份欢颜,用于数据库的基于时间点的还原。</p><p>binlog是在事务提交的时候一次性写入binlog文件中的。<br>binlog的默认是保持时间由参数expire_logs_days配置，也就是说对于非活动的日志文件，在生成时间超过expire_logs_days配置的天数之后，会被自动删除。</p><p>sync_binlog这个参数设置为1的时候表示每次事务的binlog都持久化到磁盘中，可以保证崩溃重启以后binlog不丢失,用来备份恢复的时候数据不丢失。</p><h1 id="两阶段写日志"><a href="#两阶段写日志" class="headerlink" title="两阶段写日志"></a>两阶段写日志</h1><p>redolog(prepare) -&gt; binlog -&gt; redolog(commit)</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sql执行流程</title>
      <link href="/hlblog/2018/12/04/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
      <url>/hlblog/2018/12/04/mysql/sql%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>sql的执行流程</p><a id="more"></a><h1 id="mysql结构简介"><a href="#mysql结构简介" class="headerlink" title="mysql结构简介"></a>mysql结构简介</h1><p>mysql大致可分为Server层和存储引擎层两部分。<br>server层大概包括连接器,查询缓存,分析器,优化器,执行器等，涵盖MYSQL大多数的核心功能以及所有的内置函数，所有的跨存储引擎功能都在这一层实现，如存储过程，触发器，视图等等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB,MyISAM等多个存储引擎。默认的存储引擎是InnoDB。</p><h1 id="查询sql的执行流程"><a href="#查询sql的执行流程" class="headerlink" title="查询sql的执行流程"></a>查询sql的执行流程</h1><p>一条查询sql的执行流程大概需要经过mysql的以下几个流程:<br> 连接器 -&gt; 查询缓存 -&gt; 分析器 -&gt; 优化器 -&gt; 执行器(调用存储引擎接口)</p><h2 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h2><p>主要功能: 建立连接、获取权限、维持连接、管理连接。<br>流程: 请求建立连接(TCP握手) -&gt; 输入密码 -&gt; 认证 -&gt; 获取权限 -&gt;<br><strong>建立连接:</strong><br>建立连接的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h$ip -P$port -u$user -p</span><br></pre></td></tr></table></figure></p><p><strong>获取权限:</strong><br>如果用户名和密码认证通过，连接器会到权限表中读出当前用户的权限，在此连接内的权限判断都依赖此时读出的结果。</p><p><strong>维持/管理连接:</strong><br>连接建立，经过使用以后如果没有后续操作这个连接会进入空闲状态，使用show processlist可以查出空闲状态的连接列表，如果超过了指定的时间还是没有任何操作，连接器就会断开这个连接,这里的时间由wait_timeout指定,默认8小时。</p><p><strong>长连接和短连接:</strong><br>在数据库中，长连接是指连接成功后，如果客户端持续有请求，则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个,但是建立连接是非常复杂的，所以不建议使用短连接。<br>长连接过度使用会占用大量的内存,因为在mysql执行过程中使用的临时内存时在连接中管理的这部分内存在断开连接以后才会释放，如果连接不释放，这部分内存就会一直被占据。<br>解决方案:<br>1.隔一段时间或执行完一个比较复杂的操作以后就断开一次连接，将占用的内存释放掉，之后要使用的时候再重新建立连接。<br>2.mysql5.7以上版本可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个操作会将连接恢复到刚刚建立的状态。</p><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><p>查询缓存功能在mysql8.0以后被彻底删除了，因为使用这个功能是弊大于利的。查询缓存的失效非常的频繁，只要有一个对表的更新操作，这个表上的所有缓存都会被删除。<br>查询缓存如果启用了的话，它会将执行过的语句及其结果以Key-Value的形式保存在内存中。</p><h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><p>1.词法分析<br>2.语法分析</p><h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>优化器在表有多个索引的时候决定使用哪个索引，或者一个语句有多表关联的时候决定join的顺序。</p><h2 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h2><p>MySQL 通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，开始执行语句。<br>开始执行的时候，要先判断一下你对这个表 T 有没有执行查询的权限，如果没有，就会返回没有权限的错误。<br>无索引: 全表扫描 第一行-&gt;下一行<br>有索引: 非全表扫描   满足条件的第一行-&gt;满足条件的下一行</p><h1 id="更新sql的执行流程"><a href="#更新sql的执行流程" class="headerlink" title="更新sql的执行流程"></a>更新sql的执行流程</h1><p>一条查询sql的执行流程大概需要经过mysql的以下几个流程:<br> 连接器 -&gt; 查询缓存 -&gt; 分析器 -&gt; 优化器 -&gt; 执行器(调用存储引擎接口)</p><p> 同样的，一条更新的sql语句也会经过这些步骤，不同的是在查询sql执行时，如果在缓存中能找到缓存的数据，就可以直接返回了。而在更新的sql中，会将被更新表的缓存全部清除掉。同时，更新sql涉及到两个比较重要的日志的更新，即redo log和binlog。关于这两个日志，打算重开一篇来记录。</p><p>1.首先客户端通过tcp/ip发送一条sql语句到server层的SQL interface<br>2.SQL interface接到该请求后，先对该条语句进行解析，验证权限是否匹配<br>3.验证通过以后，分析器会对该语句分析,是否语法有错误等<br>4.接下来是优化器器生成相应的执行计划，选择最优的执行计划<br>5.之后会是执行器根据执行计划执行这条语句。在这一步会去open table,如果该table上有MDL，则等<br>待。<br>如果没有，则加在该表上加短暂的MDL(S)<br>(如果opend_table太大,表明open_table_cache太小。需要不停的去打开frm文件)<br>6.进入到引擎层，首先会去innodb_buffer_pool里的data dictionary(元数据信息)得到表信息<br>7.通过元数据信息,去lock info里查出是否会有相关的锁信息，并把这条update语句需要的<br>锁信息写入到lock info里(锁这里还有待补充)<br>8.然后涉及到的老数据通过快照的方式存储到innodb_buffer_pool里的undo page里,并且记录undo<br>log修改的redo<br>(如果data page里有就直接载入到undo page里，如果没有，则需要去磁盘里取出相应page的数据，载<br>入到undo page里)<br>9.在innodb_buffer_pool的data page做update操作。并把操作的物理数据页修改记录到redo log<br>buffer里<br>由于update这个事务会涉及到多个页面的修改，所以redo log buffer里会记录多条页面的修改信息。<br>因为group commit的原因，这次事务所产生的redo log buffer可能会跟随其它事务一同flush并且sync<br>到磁盘上<br>10.同时修改的信息，会按照event的格式,记录到binlog_cache中。(这里注意binlog_cache_size是<br>transaction级别的,不是session级别的参数,<br>一旦commit之后，dump线程会从binlog_cache里把event主动发送给slave的I/O线程)<br>11.之后把这条sql,需要在二级索引上做的修改，写入到change buffer page，等到下次有其他sql需要读<br>取该二级索引时，再去与二级索引做merge<br>(随机I/O变为顺序I/O,但是由于现在的磁盘都是SSD,所以对于寻址来说,随机I/O和顺序I/O差距不大)<br>12.此时update语句已经完成，需要commit或者rollback。这里讨论commit的情况，并且双1<br>13.commit操作，由于存储引擎层与server层之间采用的是内部XA(保证两个事务的一致性,这里主要保证<br>redo log和binlog的原子性),<br>所以提交分为prepare阶段与commit阶段<br>14.prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗<br>时)<br>15.commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记<br>commit<br>16.当binlog和redo log都已经落盘以后，如果触发了刷新脏页的操作，先把该脏页复制到doublewrite<br>buffer里，把doublewrite buffer里的刷新到共享表空间，然后才是通过page cleaner线程把脏页写入<br>到磁盘中<br>老师，你看我的步骤中有什么问题嘛？我感觉第6步那里有点问题,因为第5步已经去open table了，第6<br>步还有没有必要去buffer里查找元数据呢?这元数据是表示的系统的元数据嘛,还是所有表的？谢谢老师指<br>正</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadLocal源码阅读笔记</title>
      <link href="/hlblog/2018/11/27/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/ThreadLocal%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/11/27/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/ThreadLocal%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>参考资料<br><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">https://www.jianshu.com/p/ee8c9dccc953</a><br><a href="https://www.jianshu.com/p/ee8c9dccc953" target="_blank" rel="noopener">https://www.jianshu.com/p/ee8c9dccc953</a></p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ThreadPoolExecutor源码阅读笔记</title>
      <link href="/hlblog/2018/11/27/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/11/27/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0/ThreadPoolExecutor%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>ThreadPoolExecutor源码阅读笔记</p><a id="more"></a><h1 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主池的控制状态，这个状态包含了两个概念</span></span><br><span class="line"><span class="comment"> * 1.workerCount: 表示线程池中的有效线程数</span></span><br><span class="line"><span class="comment"> * 2.runState: 表示当前线程池的状态，是否打开 关闭等等</span></span><br><span class="line"><span class="comment"> * ctl的高3位表示”线程池状态”，低29位表示”线程池中的任务数量”。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下是五个状态</span></span><br><span class="line"><span class="comment">// RUNNING: 接收新任务并且处理排队任务</span></span><br><span class="line"><span class="comment">// SHUTDOWN: 不再接收新任务，但是会继续处理未完成的排队任务</span></span><br><span class="line"><span class="comment">// STOP: 不再接收新任务，也不再处理未完成的排队任务，同时中断进行中的任务</span></span><br><span class="line"><span class="comment">// TIDYING: 所有的任务都被终止了，workerCount等于0，转换到TIDYING状态的线程将会调用terminated()方法</span></span><br><span class="line"><span class="comment">// TERMINATED: terminated()方法执行完成。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态转换</span></span><br><span class="line"><span class="comment">// RUNNING -&gt; SHUTDOWN   发生在调用shutdown()方法时，可能隐藏在finalize()方法中。</span></span><br><span class="line"><span class="comment">// (RUNNING or SHUTDOWN) -&gt; STOP  发生在调用shutdownNow()时</span></span><br><span class="line"><span class="comment">// SHUTDOWN -&gt; TIDYING  发生在当队列和线程池中正在执行的任务都为空的时候</span></span><br><span class="line"><span class="comment">// STOP -&gt; TIDYING 发生在当线程池为空的时候</span></span><br><span class="line"><span class="comment">// TIDYING -&gt; TERMINATED 发生在terminated()方法执行完成的时候</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;  <span class="comment">//对应的高3位的值为111.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;  <span class="comment">//对应的高3位的值为000 .</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;  <span class="comment">//对应的高3位的值为001.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;  <span class="comment">//对应的高3位的值为010.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;  <span class="comment">//对应的高3位的值为011.</span></span><br></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">        maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">        keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor有四个构造方法，上面贴出来的这个是参数最全的，一共七个参数,每个参数的具体含义如下:<br><strong>corePoolSize</strong><br>线程池中核心线程的数量。每当提交一个任务时，线程池会新建一个线程来执行任务，直到当前线程数等于corePoolSize。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</p><p><strong>maximumPoolSize</strong><br>线程池中允许的最大线程数。当线程池中的线程都处于工作状态时，如果依然有新任务提交上来，这些任务会被加入到阻塞队列中。阻塞队列满了之后，如果还有任务提交，如果当前的线程数小于maximumPoolSize，则会新建线程来执行任务。注意，如果使用的是无界队列，该参数也就没有什么效果了。</p><p><strong>keepAliveTime</strong><br>线程的可空闲时间，这个参数只有在当前线程池中的线程数量大于corePoolSize时才有用。</p><p><strong>unit</strong><br>keepAliveTime的时间单位。</p><p><strong>workQueue</strong><br>用来保存等待执行的任务的阻塞队列，它是BlockingQueue<runnable>类型，java中有四个实现了BlockingQueue接口的阻塞队列可供选择使用。<br>ArrayBlockingQueue: 基于数组的有界阻塞队列，FIFO。<br>LinkedBlockingQueue:基于链表的有界阻塞队列，FIFO。<br>PriorityBlockingQueue: 基于二叉堆的优先级队列，它是一个无界队列。<br>SynchronousQueue: 不存储元素的阻塞队列，它的每一个入列操作都必须等待一个出列操作完成。入列出列交替进行。</runnable></p><p><strong>threadFactory</strong><br>用于创建线程的工厂。</p><p><strong>handler</strong><br>线程池的拒绝策略。当向线程池中提交任务时，如果此时线程池中的线程已经饱和了，而且阻塞队列也已经满了，则线程池会选择一种拒绝策略来处理该任务。<br>线程池提供了四种拒绝策略:<br>AbortPolicy:直接抛出异常，默认策略；<br>CallerRunsPolicy:用调用者所在的线程来执行任务；<br>DiscardOldestPolicy:丢弃阻塞队列中靠最前的任务，并执行当前任务；<br>DiscardPolicy:直接丢弃任务；</p><h1 id="线程工厂"><a href="#线程工厂" class="headerlink" title="线程工厂"></a>线程工厂</h1><p>ThreadFactory是用来创建线程的工厂，根据其他的构造方法可以看到默认的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                            TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                            RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">            Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ThreadPoolExecutor中默认的构造方法实现为Executors.defaultThreadFactory(),返回的是DefaultThreadFactory的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadFactory <span class="title">defaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultThreadFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">                                Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = <span class="string">"pool-"</span> +</span><br><span class="line">                        poolNumber.getAndIncrement() +</span><br><span class="line">                        <span class="string">"-thread-"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                                namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                                <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">            t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultThreadFactory实例通过newThread()方法创建线程，创建出来的线程都是非守护线程，线程的优先级都是NORM_PRIORITY。同时，使用newThread方法创建需要提供一个Runnable实例，这个在任务队列中也有体现，任务队列的类型为BlockingQueue<runnable>，说明所有的任务都必须实现了Runnable接口。</runnable></p><h1 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h1><p>当向线程池中提交任务时，如果此时线程池中的线程已经饱和了，而且阻塞队列也已经满了，则线程池会选择一种拒绝策略来处理该任务。<br>线程池提供了四种拒绝策略:</p><p>AbortPolicy:直接抛出异常，默认策略；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                                <span class="string">" rejected from "</span> +</span><br><span class="line">                                                e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>CallerRunsPolicy:直接使用调用execute()方法的线程来执行这个任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DiscardOldestPolicy:丢弃阻塞队列中靠最前的任务，并执行当前任务；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            <span class="comment">//任务队列出列</span></span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>DiscardPolicy:什么也不做，直接丢弃任务;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h1><h2 id="新增任务、新增工作线程"><a href="#新增任务、新增工作线程" class="headerlink" title="新增任务、新增工作线程"></a>新增任务、新增工作线程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">//如果当前线程中的线程数量小于corePoolSize，就调用addWorker方法创建一个新的工作线程去处理这个任务。</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前线程池处于RUNNING状态，就尝试将该任务加入到阻塞队列中(***新增任务***)。</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//加入阻塞队列成功</span></span><br><span class="line">        <span class="comment">//进行一次二次检测</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">             <span class="comment">//如果当前线程池不是RUNNING状态，就将刚刚添加的任务移除,然后拒绝掉</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//如果当前线程池是RUNNING状态，并且线程池中的线程数为0，创建新的线程</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">//如果当前线程不是RUNNING状态，或者新任务加入到阻塞队列失败，创建新线程处理这个任务，直到线程数量达到maxPoolSize</span></span><br><span class="line">        <span class="comment">//如果创建新线程失败，就将这个任务拒绝掉。</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行任务的流程如下:</p><ol><li>如果线程池当前线程数小于corePoolSize，则调用addWorker创建新线程执行任务，成功返回true，失败执行步骤2。</li><li>如果线程池处于RUNNING状态，则尝试加入阻塞队列，如果加入阻塞队列成功，则尝试进行Double Check，如果加入失败，则执行步骤3。</li><li>如果线程池不是RUNNING状态或者加入阻塞队列失败，则尝试创建新线程直到maxPoolSize，如果失败，则调用reject()方法运行相应的拒绝策略。</li></ol><h2 id="新增工作线程"><a href="#新增工作线程" class="headerlink" title="新增工作线程"></a>新增工作线程</h2><p>当线程池中的当前线程数小于corePoolSize，或者阻塞队列已满并且当前线程数小于maxPoolSize时，调用addWorker()创建新线程执行任务，当前线程数则是根据ctl变量来获取的，调用workerCountOf(ctl)获取低29位即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * rs &gt;= SHUTDOWN : 线程池的状态是SHUTDOWN / STOP / TIDYING / TERMINATED</span></span><br><span class="line"><span class="comment">         * rs == SHUTDOWN &amp;&amp; firstTask != null : 线程池为SHUTDOWN时不接受新任务</span></span><br><span class="line"><span class="comment">         * rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue is empty :</span></span><br><span class="line"><span class="comment">         * 当rs == SHUTDOWN &amp;&amp; firstTask == null时可以看做是增加一个没有任务的线程，</span></span><br><span class="line"><span class="comment">         * 然后这个线程从队列中获取任务并执行，但是当workQueue是空队列时，增加这个线程就没有意义。  </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="comment">//如果当前的线程池的数量已经达到了可创建线程数量的最大值，</span></span><br><span class="line">                <span class="comment">//就不能再继续创建线程了，直接返回false.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">//CAS使workerCount加1，如果成功，退出内外两层循环。</span></span><br><span class="line">                <span class="comment">//如果workerCount的值发生了改变导致本次CAS失败，内层循环直到成功</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="comment">//如果线程池的状态发生了改变，退出内层循环，在外层循环中重新对线程池的状态进行判断。</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 1.创建新的工作线程</span></span><br><span class="line"><span class="comment">    * 2.加入到线程池中</span></span><br><span class="line"><span class="comment">    * 3.启动线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="comment">//如果线程已经启动，抛出异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    <span class="comment">//将刚刚创建的工作线程加入到线程池中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        <span class="comment">//修改线程池的最大池大小</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">//如果线程已经添加到了线程池中，启动这个线程。</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            <span class="comment">//如果线程启动失败，走添加失败的处理逻辑</span></span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行任务-1"><a href="#执行任务-1" class="headerlink" title="执行任务"></a>执行任务</h2><p>上面讲到，创建新的工作线程添加到线程池以后，紧接着会启动这个线程。大家都知道，线程执行的时候实际上是执行了run()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> Runnable target;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">        target.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在没有实现run方法覆盖的情况下，最终执行的是Thread内部的Runnable实例的run方法，线程池中的Thread肯定是没有覆盖run方法的，所以执行的一定是传进去的Runnable实例的run方法。<br>再来看看Worker的创建:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">          <span class="comment">//.....此处省略</span></span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">               addWorkerFailed(w);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>在创建工作线程的时候，我们将第一个任务作为参数传递过去，再来看看Worker类的构造方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构建Worker实例的时候，接收了第一个任务，并且创建新的线程的时候将Worker实例作为参数传递。再来看看创建线程的逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(group, r,</span><br><span class="line">                            namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                            <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.isDaemon())</span><br><span class="line">        t.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">        t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里直接new了一个Thread实例，并且将Worker实例作为Runnable实例进行传参。由于Worker实例实现了Runnable接口，并且实现了run方法，所以最终这个线程在执行的时候，执行的是Worker实例的run方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>runWorker方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果Worker实例中的第一个任务为空，就从任务队列中获取一个任务。</span></span><br><span class="line">        <span class="comment">//注意这里维护了一个循环，当前Worker执行完任务以后不会被回收，</span></span><br><span class="line">        <span class="comment">//而是会不停的从队列中获取任务并处理，直到队列中的任务被处理完毕。</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//执行完毕  回收线程</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从任务队列中获取一个任务:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果线程池已经停止不在处理任务或者当前线程池已经处于SHUTDOWN装填并且任务队列已经空了</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;  </span><br><span class="line">            <span class="comment">//调整工作线程的数量</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果允许核心线程超时或者是当前工作线程数量大于核心线程数，这个值为true.</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//调整工作线程的数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里的操作能够体现keepAliveTime的作用，如果当前任务队列中的任务已经处理完毕，</span></span><br><span class="line"><span class="comment">             * 并且 (设置了允许核心线程超时或者设置了不允许核心线程超时但当前工作线程的数量大于核心线程的数量)</span></span><br><span class="line"><span class="comment">             * 那么就超时的获取任务，超时以后将该线程回收掉</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 如果设置了不允许核心线程超时并且当前的工作线程数量不大于设置的核心线程数量</span></span><br><span class="line"><span class="comment">             * 那么当前线程会一直阻塞，知道有新的任务进来。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                <span class="comment">//超时的获取一个任务，超时以后返回null</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="线程回收"><a href="#线程回收" class="headerlink" title="线程回收"></a>线程回收</h2><p>processWorkerExit:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * completedAbruptly : 代表当前worker是否是执行完任务以后正常退出的，false代表正常退出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">        <span class="comment">//如果不是正常完成的，调整workerCount</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="comment">//获取最小线程数，如果允许核心线程超时，则需要留存的最小线程数为0，默认就是核心线程数</span></span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                <span class="comment">//如果允许核心线程超时吧并且当前任务队列中还有任务没有执行，</span></span><br><span class="line">                <span class="comment">//那么最少需要留下一个线程来执行任务</span></span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//如果当前线程数大于或等于需要留存的最小线程数，那么不需要创建新的线程，直接返回即可，</span></span><br><span class="line">            <span class="comment">//否则就需要创建一个新的线程加入到线程池中去。</span></span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//增加一个新的没有首任务的工作线程</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>线程的回收主要分为两种情况:</p><ol><li>当前工作队列中的任务可能还没有执行完毕，执行某个任务的途中发生了异常:<br>异常以后当前线程会释放所有的资源，这个时候需要调整工作线程的数量，然后再增加一个新的没有首任务的工作线程。</li><li>当前工作队列中已经没有任务可供当前Worker执行，执行途中没有发生异常。<br>这种情况下需要修改已完成的任务数量，然后将当前Worker从线程池中移除。然后根据设置的allowCoreThreadTimeOut参数及当前线程池中的线程数来判断线程池中是否需要创建新的线程。</li></ol><h1 id="线程池的运行状态转换"><a href="#线程池的运行状态转换" class="headerlink" title="线程池的运行状态转换"></a>线程池的运行状态转换</h1><p>开头讲到，线程池有五种状态，分别是RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED.</p><h2 id="线程池的五种状态及其特点"><a href="#线程池的五种状态及其特点" class="headerlink" title="线程池的五种状态及其特点"></a>线程池的五种状态及其特点</h2><p><strong>RUNNING:</strong> 接收新任务并且处理排队任务<br><strong>SHUTDOWN:</strong> 不再接收新任务，但是会继续处理未完成的排队任务<br><strong>STOP:</strong> 不再接收新任务，也不再处理未完成的排队任务，同时中断进行中的任务<br><strong>TIDYING:</strong> 所有的任务都被终止了，workerCount等于0，转换到TIDYING状态的线程将会调用terminated()方法<br><strong>TERMINATED:</strong> terminated()方法执行完成。</p><h2 id="线程池状态的转换"><a href="#线程池状态的转换" class="headerlink" title="线程池状态的转换"></a>线程池状态的转换</h2><p>线程池中的状态是不可逆的，只能按照RUNNING -&gt; SHUTDOWN -&gt; STOP -&gt; TIDYING -&gt; TERMINATED这种顺序一一转换.<br>RUNNING -&gt; SHUTDOWN   发生在调用shutdown()方法时，可能隐藏在finalize()方法中。<br>(RUNNING or SHUTDOWN) -&gt; STOP  发生在调用shutdownNow()时<br>SHUTDOWN -&gt; TIDYING  发生在当队列和线程池中正在执行的任务都为空的时候<br>STOP -&gt; TIDYING 发生在当线程池为空的时候<br>TIDYING -&gt; TERMINATED 发生在terminated()方法执行完成的时候</p><p>下面来对这五种转换座一下讲解:</p><h3 id="RUNNING-gt-SHUTDOWN"><a href="#RUNNING-gt-SHUTDOWN" class="headerlink" title="RUNNING -&gt; SHUTDOWN"></a>RUNNING -&gt; SHUTDOWN</h3><p>发生在调用shutdown()方法时，可能隐藏在finalize()方法中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//修改线程池的运行状态为SHUTDOWN</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RUNNING-or-SHUTDOWN-gt-STOP"><a href="#RUNNING-or-SHUTDOWN-gt-STOP" class="headerlink" title="(RUNNING or SHUTDOWN) -&gt; STOP"></a>(RUNNING or SHUTDOWN) -&gt; STOP</h3><p>发生在调用shutdownNow()时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//修改线程池的运行状态为STOP</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        interruptWorkers();</span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="SHUTDOWN-gt-TIDYING"><a href="#SHUTDOWN-gt-TIDYING" class="headerlink" title="SHUTDOWN -&gt; TIDYING"></a>SHUTDOWN -&gt; TIDYING</h3><p>发生在当队列和线程池中正在执行的任务都为空的时候<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||</span><br><span class="line">            runStateAtLeast(c, TIDYING) ||</span><br><span class="line">            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="STOP-gt-TIDYING"><a href="#STOP-gt-TIDYING" class="headerlink" title="STOP -&gt; TIDYING"></a>STOP -&gt; TIDYING</h3><p>发生在当线程池为空的时候</p><h3 id="TIDYING-gt-TERMINATED"><a href="#TIDYING-gt-TERMINATED" class="headerlink" title="TIDYING -&gt; TERMINATED"></a>TIDYING -&gt; TERMINATED</h3><p>发生在terminated()方法执行完成的时候</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS之线程的阻塞与唤醒</title>
      <link href="/hlblog/2018/11/27/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/"/>
      <url>/hlblog/2018/11/27/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E4%B9%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92/</url>
      
        <content type="html"><![CDATA[<p>竞争同步状态失败的线程会被封装成节点进入CLH队列，然后可能如果CLH队列不是空的队列，那么它可能会被阻塞住，等待它的前置节点释放同步状态以后将它唤醒。这节要讲的就是AQS中线程的阻塞与唤醒。</p><a id="more"></a><h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><h2 id="普通阻塞"><a href="#普通阻塞" class="headerlink" title="普通阻塞"></a>普通阻塞</h2><p>获取同步状态失败的节点会被封装成节点进入CLH队列中，在这里它一般会进入阻塞状态等待它的前置节点将它唤醒。<br>回顾一下独占式获取同步状态和共享式获取同步状态的代码:<br>独占式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>共享式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>观察代码可以发现无论是独占式获取同步状态还是共享式获取同步状态，代码中都有这么一段:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    interrupted = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p><p>这段代码的作用是: 判断当前节点是否需要被阻塞，如果当前节点需要被阻塞,就将它阻塞起来并且在节点被唤醒以后返回节点所代表线程的中断状态。shouldParkAfterFailedAcquire方法用来判断当前节点是否需要阻塞，parkAndCheckInterrupt方法用来阻塞当前线程然后返回中断状态。<br>shouldParkAfterFailedAcquire方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果当前节点的前置节点的等待状态已经被设置为Node.SIGNAL，那么当前节点就可以被安全的阻塞。</span></span><br><span class="line">        <span class="comment">//注: 持有同步状态的头结点在释放同步状态以后,如果其等待状态为Node.SIGNAL就会唤醒后继节点。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//waitStatus &gt; 0说明该节点已经取消了获取同步状态</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//代码执行到这里，前置节点的waitStatus的状态只能是默认的0或者是Node.PROPAGATE,</span></span><br><span class="line">        <span class="comment">//不管是默认的0还是Node.PROPAGATE都需要将它修改为Node.SIGNAL,目的是在前置节点释放同步状态以后能将后置节点唤醒。</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>parkAndCheckInterrupt方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//阻塞当前线程</span></span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//被唤醒后返回线程的中断状态</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="定时阻塞"><a href="#定时阻塞" class="headerlink" title="定时阻塞"></a>定时阻塞</h2><p>AQS中还有一种定时阻塞的情况存在,即节点只在固定的时间内阻塞，过了这个时间以后就会自我唤醒，而不用等待其他的节点来唤醒。这个情况只在超时获取同步状态的时候存在。如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">    <span class="comment">//阻塞时长nanosTimeout，然后自动醒来。</span></span><br><span class="line">    LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br></pre></td></tr></table></figure></p><h1 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h1><p>当持有同步状态的头结点释放同步状态以后,如果它有后继节点(waitStatus==Node.SIGNAL),那么它会将它的后继节点从阻塞中唤醒。AQS中的unparkSuccessor方法就是用来实现这一功能的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//如果当前头结点的waitStatus&lt;0,将之设置为默认的0.</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">//s==null: 头结点的next可能null</span></span><br><span class="line">    <span class="comment">//s.waitStatus&gt;0  该节点可能由于中断或者超时已经取消了获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//从尾节点开始向前遍历，找到第一个可以唤醒的节点</span></span><br><span class="line">        <span class="comment">//这么做的原因是当前持有同步状态的头结点的next可能为null或者它的后继节点已经取消了获取同步状态。</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//唤醒后继节点</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS中的阻塞与唤醒都是通过LockSupport这个工具类来实现的，LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，这个类总体来说还是比较简单容易理解的，这里就不细说了。</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018年12月1日</title>
      <link href="/hlblog/2018/11/27/%E4%BB%96%E5%92%8C%E4%BB%96%E7%9A%84%E7%8C%AB/%E7%8C%AB%E5%92%AA%E7%9A%84%E6%97%A5%E5%B8%B8/2018-12-01/"/>
      <url>/hlblog/2018/11/27/%E4%BB%96%E5%92%8C%E4%BB%96%E7%9A%84%E7%8C%AB/%E7%8C%AB%E5%92%AA%E7%9A%84%E6%97%A5%E5%B8%B8/2018-12-01/</url>
      
        <content type="html"><![CDATA[<!-- 插入视频代码：<iframe height=498 width=510 src="movie/2018-12-01-01.mp4"> 插入视频代码：<iframe height=498 width=510 autoplay=false src="http://www.hlblogs.com/images/cat/2018-12-01-01.mp4"> --><!--  插入gif代码：<iframe height=500 width=500 src="http://ww4.sinaimg.cn/mw690/e75a115bgw1f3rrbzv1m8g209v0diqv7.gif"> --><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> 猫咪的日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 猫咪的日常 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>红黑树</title>
      <link href="/hlblog/2018/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91(writing)/"/>
      <url>/hlblog/2018/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91(writing)/</url>
      
        <content type="html"><![CDATA[<p>参考资料:<br><a href="https://tech.meituan.com/redblack_tree.html" target="_blank" rel="noopener">美团技术团队-红黑树深入剖析及Java实现</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">维基百科-红黑树</a></p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>红黑树是一种平衡二叉查找树</p><h1 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h1><p>除了二叉查找树本身的性质之外，红黑树还具有以下性质:</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色（叶子是NIL节点）。</li><li>每个红色节点必须有两个黑色的子节点。（从每个叶子到根的所有路径上不能有两个连续的红色节点。）</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><p>可能影响红黑树各性质的原因:</p><ol><li>性质1和性质3总是保持着。</li><li>性质4只在增加红色节点、重绘黑色节点为红色，或做旋转时受到威胁。</li><li>性质5只在增加黑色节点、重绘红色节点为黑色，或做旋转时受到威胁。</li></ol><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入修复操作可能的情况:<br>情况1: 新插入节点的父节点和叔父节点都是红色节点。<br>情况2: 新插入节点的父节点为红色节点，叔父节点为黑色节点或空节点，并且新节点，父节点，祖父节点在同一条斜线上。<br>情况3: 新插入节点的父节点为红色节点，叔父节点为黑色节点或空节点，并且新节点，父节点，祖父节点不在同一条斜线上。</p><p>情况1:<br>如果新插入节点的父节点和叔父节点都是红色节点,那么祖父节点一定是黑色节点，只需要将父节点和叔父节点的颜色与祖父节点对调，即将父节点和叔父节点的颜色置为黑色，将祖父节点的颜色置为红色。然后将祖父节点视为新插入节点,如果违反了红黑树的规则，继续进行插入修复工作。<br><img src="images/rbt-insert-case1.png" alt="情况1"></p><p>情况2:<br>如果新插入节点的父节点为红色节点,并且叔父节点为黑色节点或空节点,那么祖父节点一定是黑色节点.<br>如果新插入节点是父节点的左子树并且父节点是祖父节点的左子树,只需对父节点进行一次右旋，然后将父节点和祖父节点的颜色对调即可，图例如下:<br><img src="images/rbt-insert-case2_1.png" alt="情况2"><br>如果新插入节点是父节点的右子数并且父节点是祖父节点的右子树,只需对父节点进行一次左旋，然后将父节点和阻塞节点的颜色对调即可，图例如下:<br><img src="images/rbt-insert-case2_2.png" alt="情况2"></p><p>情况3:<br>新插入节点的父节点为红色节点，叔父节点为黑色节点或空节点，并且新节点，父节点，祖父节点不在同一条斜线上。只需要对新节点进行一次旋转，让新节点，父节点和祖父节点位于一条斜线上，就可以将情况3转换为情况2，再按情况2的处理流程来处理即可，图例如下:<br><img src="images/rbt-insert-case3_1.png" alt="情况3"><br>或者<br><img src="images/rbt-insert-case3_2.png" alt="情况3"></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除修复操作分为四种情况(删除黑节点后):<br>情况1: 待删除的节点的兄弟节点是红色的节点。<br>情况2: 待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。<br>情况3: 待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。<br>情况4: 待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>散列表</title>
      <link href="/hlblog/2018/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E9%9A%8F%E8%AE%B0(writing)/"/>
      <url>/hlblog/2018/11/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E9%9A%8F%E8%AE%B0(writing)/</url>
      
        <content type="html"><![CDATA[<p>散列表</p><a id="more"></a><h1 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h1><p>解决办法:<br>1.开放寻址法<br>    适合在数据量小，加载因子较小的场景下使用      java中的ThreadLocalMap<br>2.链表法<br>    适合在数据量较大，存储大对象，加载因子较大的场景下使用    java中的HashMap,LinkedHashMap</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/hlblog/2018/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86(done)/"/>
      <url>/hlblog/2018/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86(done)/</url>
      
        <content type="html"><![CDATA[<p>分别使用递归和非递归的方式实现二叉树的前中后序遍历以及广度优先遍历和深度优先遍历。</p><a id="more"></a><p>二叉树的节点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String key,String val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String key;</span><br><span class="line">    <span class="keyword">public</span> String value;</span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建一颗二叉树:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> Node root = <span class="keyword">new</span> Node(<span class="string">"A"</span>,<span class="string">"A-VAL"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinaryTree</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Node B = <span class="keyword">new</span> Node(<span class="string">"B"</span>,<span class="string">"B-VAL"</span>);</span><br><span class="line">    Node C = <span class="keyword">new</span> Node(<span class="string">"C"</span>,<span class="string">"C-VAL"</span>);</span><br><span class="line">    Node D = <span class="keyword">new</span> Node(<span class="string">"D"</span>,<span class="string">"D-VAL"</span>);</span><br><span class="line">    Node E = <span class="keyword">new</span> Node(<span class="string">"E"</span>,<span class="string">"E-VAL"</span>);</span><br><span class="line">    Node F = <span class="keyword">new</span> Node(<span class="string">"F"</span>,<span class="string">"F-VAL"</span>);</span><br><span class="line">    Node G = <span class="keyword">new</span> Node(<span class="string">"G"</span>,<span class="string">"G-VAL"</span>);</span><br><span class="line">    Node H = <span class="keyword">new</span> Node(<span class="string">"H"</span>,<span class="string">"H-VAL"</span>);</span><br><span class="line">    Node I = <span class="keyword">new</span> Node(<span class="string">"I"</span>,<span class="string">"I-VAL"</span>);</span><br><span class="line"></span><br><span class="line">    root.left = B;</span><br><span class="line">    root.right = C;</span><br><span class="line"></span><br><span class="line">    B.left = D;</span><br><span class="line">    B.right = E;</span><br><span class="line"></span><br><span class="line">    C.left = F;</span><br><span class="line"></span><br><span class="line">    D.left = G;</span><br><span class="line"></span><br><span class="line">    E.right = H;</span><br><span class="line"></span><br><span class="line">    F.right = I;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *                 A</span></span><br><span class="line"><span class="comment">     *           B           C</span></span><br><span class="line"><span class="comment">     *         D   E       F</span></span><br><span class="line"><span class="comment">     *        G      H        I</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用递归的方式实现二叉树的前序遍历:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preErgodic</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(root.key+<span class="string">" "</span>);</span><br><span class="line">    preErgodic(root.left);</span><br><span class="line">    preErgodic(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用非递归的方式实现二叉树的前序遍历:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preErgodic2</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        System.out.print(node.key+<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用递归的方式实现二叉树的中序遍历:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cenErgodic</span><span class="params">(Node  root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    cenErgodic(root.left);</span><br><span class="line">    System.out.print(root.key+<span class="string">" "</span>);</span><br><span class="line">    cenErgodic(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用非递归的方式实现二叉树的后续遍历:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cenErgodic2</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(root!=<span class="keyword">null</span> || !stack.empty())&#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            Node node = stack.pop();</span><br><span class="line">            System.out.print(node.key+<span class="string">" "</span>);</span><br><span class="line">            root = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用递归的方式实现二叉树的后序遍历:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postErgodic</span><span class="params">(Node  root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    postErgodic(root.left);</span><br><span class="line">    postErgodic(root.right);</span><br><span class="line">    System.out.print(root.key+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用非递归的方式实现二叉树的后序遍历:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postErgodic2</span><span class="params">(Node  root)</span></span>&#123;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;Node&gt;();</span><br><span class="line">    Node node = root;</span><br><span class="line">    Node lastVisit = root;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(node);</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//查看当前栈顶元素</span></span><br><span class="line">        node = stack.peek();</span><br><span class="line">        <span class="comment">//如果其右子树也为空，或者右子树已经访问</span></span><br><span class="line">        <span class="comment">//则可以直接输出当前节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (node.right == <span class="keyword">null</span> || node.right == lastVisit) &#123;</span><br><span class="line">            System.out.print(node.key + <span class="string">" "</span>);</span><br><span class="line">            stack.pop();</span><br><span class="line">            lastVisit = node;</span><br><span class="line">            node = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则，继续遍历右子树</span></span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二叉树的广度优先遍历(BFS):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">breadthFirstErgodic</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        Node node = stack.remove();</span><br><span class="line">        System.out.print(node.key+<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二叉树的深度优先遍历(DFS):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depthFirstErgodic</span><span class="params">(Node root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.add(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        Node node = stack.pop();</span><br><span class="line">        System.out.print(node.key+<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS之状态的获取与释放</title>
      <link href="/hlblog/2018/11/18/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E4%B9%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE/"/>
      <url>/hlblog/2018/11/18/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E4%B9%8B%E7%8A%B6%E6%80%81%E7%9A%84%E8%8E%B7%E5%8F%96%E4%B8%8E%E9%87%8A%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<p>上一篇博客<a href=""><font color="blue">AQS之CLH队列</font></a>大致分析了一下AQS中的CLH队列的情况，本节来分析一下AQS中状态的获取与释放</p><a id="more"></a><h1 id="同步状态的获取"><a href="#同步状态的获取" class="headerlink" title="同步状态的获取"></a>同步状态的获取</h1><p>同步状态的获取分为独占式获取和共享式获取，这两种获取方式根据是否响应中断和超时，又有不同的获取特点。</p><h2 id="独占式获取同步状态"><a href="#独占式获取同步状态" class="headerlink" title="独占式获取同步状态"></a>独占式获取同步状态</h2><p>独占式的获取同步状态的特点是同步状态只能被一个线程所获取，其他所有的线程都会获取失败并且进入CLH队列等待持有同步状态的线程释放状态。</p><h3 id="不响应中断和超时的获取"><a href="#不响应中断和超时的获取" class="headerlink" title="不响应中断和超时的获取"></a>不响应中断和超时的获取</h3><p>不响应中断和超时的获取方式无视任何线程对当前线程中断状态的标记，并且在没有其他不可控异常的情况下会一直等待直到获取同步状态，AQS中提供了acquire(int arg):void方法用来获取同步状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法在获取状态之前是不会退出的，所以它执行完毕以后一定是成功获取状态的。这个方法的代码比较简单，如果tryAcquire(arg)这个方法返回false,就执行addWaiter方法，然后执行acquireQueued方法，等到acquireQueued方法执行完毕执行selfInterrupt方法。上节我们讲到addWaiter方法是用来将获取同步状态失败的线程封装成节点并加入到CLH队列的，那么我们可以根据这一方法的功能和其他方法的名称来猜想一下，tryAcquire方法是用来尝试获取同步状态的，而acquireQueued方法是用来使队列中的节点获取同步状态的，那么究竟是不是这样呢？我们接下来一点点的看。<br>首先来看tryAcquire方法的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>what?这个方法什么也没做直接抛出了异常，这还怎么玩。。。我们来看看这个方法的注释是怎么说的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Attempts to acquire in exclusive mode. This method should query</span></span><br><span class="line"><span class="comment">    * if the state of the object permits it to be acquired in the</span></span><br><span class="line"><span class="comment">    * exclusive mode, and if so to acquire it.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;This method is always invoked by the thread performing</span></span><br><span class="line"><span class="comment">    * acquire.  If this method reports failure, the acquire method</span></span><br><span class="line"><span class="comment">    * may queue the thread, if it is not already queued, until it is</span></span><br><span class="line"><span class="comment">    * signalled by a release from some other thread. This can be used</span></span><br><span class="line"><span class="comment">    * to implement method &#123;<span class="doctag">@link</span> Lock#tryLock()&#125;.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;The default</span></span><br><span class="line"><span class="comment">    * implementation throws &#123;<span class="doctag">@link</span> UnsupportedOperationException&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure></p><p>这段注释详细的解释了这个方法的作用:<br>这个方法尝试以独占模式来获取状态，它需要查询当前的同步状态是否允许它以独占模式获取同步状态，如果允许的话，它就能获取同步状态。<br>这个方法永远只会在线程获取同步状态的时候被调用，如果这个方法返回了失败的信息并且这个线程不在CLH队列中，acquire方法将会使当前线程入列排队(调用addWaiter方法)，直到它被释放了同步状态的线程唤醒,这可以被用来实现Lock接口中的tryLock方法(此处请先忽略)。</p><font color="blue">默认的实现将抛出UnsupportedOperationException异常</font>  <p>注意上面这一句，默认的实现将会直接抛出异常，既然默认的实现不能使用，那就说明还有其他的实现并且这个实现可能在不同的地方根据不同的使用场景有不同的具体实现。根据方法追溯我们可以发现，这个方法在ReentrantLock，ReentrantReadWriteLock和ThreadPoolExecutor三个类中被重写了。具体是如何实现的我们日后讲到这三个类的时候再说，这里我们只需要明白两个问题，<font color="blue">一是这个方法需要被子类做具体实现才能使用，二是这个方法的作用是返回是否成功获取同步状态。</font></p><p>接下来我们再来看看acquireQueued探一探方法的虚实:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取该节点的前置节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">//如果该节点的前置节点是头节点，就执行tryAcquire方法</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断当前节点是否需要阻塞，如果需要阻塞，就阻塞起来</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过具体代码可以看出acquireQueued方法内部主要就是一个死循环，在没有异常的情况下想退出这个循环就只有一条路，那就是满足for循环内的第一个if条件并执行内部的代码。if内的条件我已经注释出来了，如果当前节点的前置节点是头节点，就尝试获取同步状态，在当前节点获取到同步状态以后。获取同步状态以后，将当前节点设置为头节点，并断开前置节点与当前节点的联系。<br>这里解释一下为什么获取同步状态要先判断当前节点的前置节点是否是头节点，我们知道，获取同步状态失败的线程，将会被封装成节点进入CLH队列，CLH队列是一个FIFO队列，为了满足其FIFO的特性，就需要按照队列内的顺序来一次获取同步状态，而头节点一定是当前持有同步状态的节点，按照FIFO的规则，下一个能获取到同步状态的节点一定得是阻塞队列的第一个节点，也就是头节点的后置节点。所以这里必须要先判断当前节点的前置节点是否是头节点。</p><p>到这里整个不响应中断和超时的独占式获取同步状态的过程就结束了，我们来总结一下目前锁了解到的整个过程: <font color="blue">首先尝试独占式获取同步状态，如果获取失败，就把当前节点封装成节点进入CLH队列，进入队列以后节点将会在队列内无限循环直到成功获取了同步状态以后才能退出，退出也就意味着当前线程获取同步状态一定成功了，但是这里不是所有的节点都在进行无限的for循环，事实上几乎所有进入队列的节点都会阻塞起来，只有每个节点的前置节点是头节点，并且前置节点释放了同步状态以后将后置节点唤醒以后，才能继续进行循环的操作。</font></p><!-- 我画了一张图来描述一下这个过程:<font size=7>此处需要一张图</font> --><hr><h3 id="响应中断的获取"><a href="#响应中断的获取" class="headerlink" title="响应中断的获取"></a>响应中断的获取</h3><p>响应中断的获取方式和上面的获取方式的过程几乎是一样的，唯一的不同是加入了对中断状态的响应。AQS中的acquireInterruptibly方法提供了中断获取同步状态的功能。它的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//响应中断,如果此时发现线程被中断了，就抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先我们可以看到，进入方法以后首先对中断状态进行判断，这一步是acquire方法所没有的。<br>tryAcquire方法我们上面已经讲过了，它是用来尝试获取同步状态的，如果能够获取成功，方法就执行结束了，如果获取失败，执行doAcquireInterruptibly方法，接下来我们看一下这个方法的内部是什么样的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//将当前线程封装成节点加入到CLH队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//如果线程被唤醒以后发现被中断了，直接抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>doAcquireInterruptibly方法的内部实现与acquireQueued是非常相似的，最大的不同在于下面这段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">    parkAndCheckInterrupt())</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br></pre></td></tr></table></figure></p><p>这里我们来简单的说一下shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法的作用，至于具体实现，下一篇博客中会做具体分析。<br>shouldParkAfterFailedAcquire方法的作用是判断当前节点需不需要阻塞，需要则返回true,不需要返回false.<br>parkAndCheckInterrupt方法的作用是阻塞当前节点，并且在被唤醒以后返回当前线程的中断状态。<br>那么这端代码的意思就很明显了，如果当前节点需要被阻塞，那么它就会进入阻塞状态。在节点被唤醒以后，会返回节点的中断状态。如果发现在阻塞的过程中节点已经被中断了，就会抛出InterruptedException。</p><h3 id="响应超时的获取"><a href="#响应超时的获取" class="headerlink" title="响应超时的获取"></a>响应超时的获取</h3><p>响应超时的获取方式会同时响应中断和超时两种情况，在响应中断的基础上加上了对超时时间的控制，如果达到了超时时间还没能获取到同步状态，就直接退出。<br>AQS中的tryAcquireNanos方法提供了这个功能:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要说一下nanosTimeout这个long类型参数，它的单位是纳秒，它的意义是多长时间以后超时。<br>整个方法还是比较简单的，相比大家都能看明白，这里还有一点需要注意，这个方法是有返回值的，而且是boolean类型，前面讲的acquire方法和acquireInterruptibly方法都时没有返回值的，方法顺利执行完毕就默认是一定获取到同步状态的，而这里是需要判断返回值来确定是否已经成功获取同步状态的。<br>接下来我们看一下doAcquireNanos这个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//计算超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算剩余超时时间还有多少时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//如果当前已经超时了，返回false，本次获取同步状态失败。</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//如果节点需要阻塞并且当前剩余的超时时间大于1000纳秒(spinForTimeoutThreshold==1000L),</span></span><br><span class="line">            <span class="comment">//那么就将当前节点阻塞一段时间(时间长度等于剩余超时时间)</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>doAcquireNanos方法的整理逻辑还是比较简单的，重点的地方都加了注释了。关于中断的处理就不再赘述了，这里稍微整理一下超时的逻辑:首先计算出超时的时间点，然后每一次循环都去计算一次剩余的超时时间，当超时时间小于等于0，说明已经达到了超时的时间点或者已经超时了，那么本次获取就结束了。如果当前节点需要被阻塞，并且剩余超时时间大于1000纳秒，就让当前线程阻塞一段时间(剩余超时时间)，这个阻塞是不需要其他线程来唤醒的，到了时间线程会自动苏醒。<br>有一个地方我觉比较需要单独说一下，就是说我们在tryAcquireNanos中传入的超时参数nanosTimeout并不一定就是准确的超时返回时间，它只是提供一个大致的时间点，实际上这个时间可能是会浮动的，而且一般上往上浮动。比如你设置2000纳秒以后超时，但是实际上可能2200纳秒以后才会超时返回。</p><h2 id="共享式获取同步状态"><a href="#共享式获取同步状态" class="headerlink" title="共享式获取同步状态"></a>共享式获取同步状态</h2><p>共享式获取同步状态和独占式获取同步状态的不同之处在于独占式获取共享状态任何时刻只有一个线程能获取成功，其他的线程必须进入CLH队列中等待持有同步状态的线程释放同步状态以后才能继续尝试获取，而共享式获取同步状态并不需要获取同步状态的线程释放就能获取成功，在同一时刻可以有多个线程持有同步状态。</p><h3 id="不响应中断和超时的获取-1"><a href="#不响应中断和超时的获取-1" class="headerlink" title="不响应中断和超时的获取"></a>不响应中断和超时的获取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享式获取tong不状态的流程和独占式获取非常相似。首先我们来看tryAcquireShared方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>是不是觉得似曾相识？对，这个方法和tryAcquire方法几乎是一模一样，都需要子类去做具体实现。不同的是这个方法的返回值是int类型。<br>tryAcquireShared方法的返回值有三种形式，大于0，等于0，小于0，具体点就是-1,0和1<br>返回值为-1: 获取同步状态失败<br>返回值为0:  获取同步状态成功，但是后续将不会有线程能获取成功。<br>返回值为1:  获取同步状态成功，并且后续的线程也能获取成功。</p><p>再来看看doAcquireShared(int arg)方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将线程封装成节点进入CLH队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//如果前置节点为头结点，尝试获取同步状态。</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">//tryAcquireShared方法的返回值大于等于0的时候说明当前节点获取同步状态成功。</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//如果当前节点获取同步状态成功，将当前节点设置为头结点并传播。</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>doAcquireShared方法的逻辑还是比较容易理解的，这里有一个比较重要的方法setHeadAndPropagate方法需要了解一下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">    <span class="comment">//将当前节点设置为头结点</span></span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>setHeadAndPropagate的作用有两个，一是将获取到同步状态的节点设置为头结点，二是调用doReleaseShared实现释放同步状态以后的逻辑。但是我们得要明白，这里头结点并没有释放同步状态，只是要做释放同步状态以后需要做的事，即唤醒后继节点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//唤醒后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        <span class="comment">//进入CLH队尾的节点默认ws都是0，但是如果在执行这一句之前有一个新的节点进入队列成为新的尾节点，</span></span><br><span class="line">                        <span class="comment">//原尾节点的ws就会被修改为Node.SIGNAL，这里的CAS语句就会执行失败。</span></span><br><span class="line">                        <span class="comment">//如果执行成功，说明当前节点是CLH队列的尾节点，没有后继节点需要唤醒。</span></span><br><span class="line">                        !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我刚开始看这里的代码的时候一直卡着没想明白为什么第一个CAS语句会存在执行失败的问题,想了很久才恍然大悟。相信也有人跟我一样会钻进死胡同，下面就来说一下原因: 我们知道新的节点进入CLH队列以后会将前置节点的waitStatus设置为Node.SIGNAL,在执行第一个CAS的时候必定是已经将当前节点的waitStatus设置成了Node.SIGNAL(外层if条件判断),这样的话执行成功好像是顺理成章的，但是不然。我们假设现在有个节点a,它是头结点，它的后继节点是b,b的后继节点是c,a和b的waitStatus都是Node.SIGNAL。假设当前节点a第一次执行CAS语句的时候执行成功了,然后唤醒了后继节点b,b被唤醒了以后迅速抢占了头结点，成为新的头结点。那么a节点继续往下执行的时候因为头结点已经变了，就没法退出当前循环，只能再一次进入for循环。这个时候可能节点b也进入了for循环，并且a和b同时执行第一个CAS语句，二者竞争必定有一个会失败。</p><h3 id="响应中断的获取-1"><a href="#响应中断的获取-1" class="headerlink" title="响应中断的获取"></a>响应中断的获取</h3><p>理解了上面的获取流程，响应中断的获取就非常好理解了，只是加上了对中断状态的响应:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">//响应中断，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">//响应中断，抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="响应超时的获取-1"><a href="#响应超时的获取-1" class="headerlink" title="响应超时的获取"></a>响应超时的获取</h3><p>关于超时获取的流程，可以参考独占式获取同步状态的超时处理，两种获取方式对于超时获取的处理是相同的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="comment">//响应中断，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquireShared(arg) &gt;= <span class="number">0</span> ||</span><br><span class="line">        doAcquireSharedNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireSharedNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//计算超时时间点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算剩余超时时间还有多少</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">//如果当前已经超时了，返回false，本次获取同步状态失败。</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//如果节点需要阻塞并且当前剩余的超时时间大于1000纳秒(spinForTimeoutThreshold==1000L),</span></span><br><span class="line">            <span class="comment">//那么就将当前节点阻塞一段时间(时间长度等于剩余超时时间)</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="同步状态的释放"><a href="#同步状态的释放" class="headerlink" title="同步状态的释放"></a>同步状态的释放</h1><h2 id="独占模式"><a href="#独占模式" class="headerlink" title="独占模式"></a>独占模式</h2><p>独占模式的同步状态释放有两种形式，一种是指定数量的释放，另一种是全部释放</p><h3 id="指定数量释放"><a href="#指定数量释放" class="headerlink" title="指定数量释放"></a>指定数量释放</h3><p>指定数量的释放方式每一次会释放指定的数量的同步状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//释放同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到指定数量释放同步状态其实做了两件事，第一件事是释放同步状态，第二件事是在同步状态全部释放以后唤醒后继节点。tryRelease方法也是需要子类来做具体实现具体逻辑的，这个方法的作用是释放同步状态并返回是否已经将同步状态全部释放，只有在持有同步状态的线程将同步状态全部释放此方法才会返回true.</p><h3 id="全部释放"><a href="#全部释放" class="headerlink" title="全部释放"></a>全部释放</h3><p>全部数量的方式方式会一次将持有同步状态的线程所持有的同步状态全部释放，它是调用release方法来实现的。。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> savedState;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="共享模式"><a href="#共享模式" class="headerlink" title="共享模式"></a>共享模式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享模式的释放主要就是两个方法，释放状态的tryReleaseShared方法和传播释放动作唤醒后继节点的doReleaseShared方法，tryReleaseShared需要由子类实现，方法内部通过CAS和for循环来确保释放状态。</p><h1 id="取消获取同步状态"><a href="#取消获取同步状态" class="headerlink" title="取消获取同步状态"></a>取消获取同步状态</h1><p>在获取同步状态之前，是可以取消获取同步状态的动作的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predNext is the apparent node to unsplice. CASes below will</span></span><br><span class="line">    <span class="comment">// fail if not, in which case, we lost race vs another cancel</span></span><br><span class="line">    <span class="comment">// or signal, so no further action is necessary.</span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Can use unconditional write instead of CAS here.</span></span><br><span class="line">    <span class="comment">// After this atomic step, other Nodes can skip past us.</span></span><br><span class="line">    <span class="comment">// Before, we are free of interference from other threads.</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">                (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git使用日常记录</title>
      <link href="/hlblog/2018/11/17/Git/Git%E4%BD%BF%E7%94%A8%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
      <url>/hlblog/2018/11/17/Git/Git%E4%BD%BF%E7%94%A8%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>Git使用日常记录<br><a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS简介</title>
      <link href="/hlblog/2018/11/15/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E7%AE%80%E4%BB%8B/"/>
      <url>/hlblog/2018/11/15/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>AQS是什么？<br>AQS全称AbstractQueuedSynchronizer,jdk中对AQS的解释是<br><strong>Provides a framework for implementing blocking locks and related synchronizers (semaphores, events, etc) that rely on first-in-first-out (FIFO) wait queues.</strong><br>意思就是AQS它是一个依赖于先进先出队列(FIFO)的用于实现阻塞锁及相关同步器(信号量，事件等等)的框架。</p><!-- ![图片](https://avatars0.githubusercontent.com/u/17354339?s=460&v=4) --><a id="more"></a><p>AQS被设计成一个对大多数的同步器都有用的基础组件,它使用一个int类型的原子变量来代表同步器的同步状态。这个int变量被声明为volatile变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The synchronization state.</span><br><span class="line"> */</span><br><span class="line">private volatile int state;</span><br></pre></td></tr></table></figure></p><p>AQS的子类必须定义AQS中相关的pretected方法用于实现具体的修改同步状态的逻辑，并且从获取和释放的角度来定义该同步状态的意义。说白了就是AQS并没有提供修改同步同步状态的具体逻辑实现,需要子类根据自身的场景去做具体的实现,这里说的修改同步同步状态其实就是获取锁和释放锁的过程。目前AQS中提供的这类方法比较重要的有以下这四个:<br>tryAcquire(int):boolean  <font size="3" color="blue">尝试独占式获取同步状态,返回true说明同步状态获取成功</font><br>tryRelease(int):boolean  <font size="3" color="blue">尝试独占式释放同步状态,返回true说明同步状态释放成功</font><br>tryAcquireShared(int):int  <font size="3" color="blue">尝试共享式获取同步状态,返回值大于0说明同步状态获取成功</font><br>tryReleaseShared(int):boolean  <font size="3" color="blue">尝试共享式释放同步状态,返回true说明同步状态释放成功(全部释放)</font></p><p>除了这几个方法以外的其他大部分方法都是用于实现排队和阻塞队列的逻辑，AQS中有一个CLH队列，用于处理多线程之间出现锁竞争时线程的排队和阻塞的逻辑。除了CLH阻塞队列以外，AQS内部还提供了一个Condition接口的实现类ConditionObject，用于实现条件等待队列。</p><hr><p>我所理解的AQS，其核心就是一个同步状态，一种修改方式，两种操作，两个队列，两种锁</p><p><strong>一个状态</strong><br>一个状态指的是同步状态，AQS中用一个32位的int类型变量state的值来代表当前的同步状态。<br>state&gt;0说明同步同步状态已经被一个或多个线程持有,state=0锁未被任何线程持有，这里不存在小于0的情况<br>在ReentrantReadWriteLock中32位的state被分为高低两个16位 高16位代表读锁重入次数 低16位代表写锁重入次数，在读写锁中读锁和写锁的最大可重入次数均为65535</p><p><strong>一种方式</strong><br>CAS: Compare And Swap 比较并交换,使用这种方式修改某个值，可以保证在同一时刻多线程企图对某一个值进行修改时只有一个线程能成功。</p><p><strong>两个操作</strong><br>同步状态的获取: 使用CAS尝试修改同步状态，一般是对同步状态进行+n操作，对应锁的获取<br>同步状态的释放: 使用CAS尝试修改同步状态，一般是对同步状态进行-n操作，对应锁的释放</p><p><strong>两个队列</strong><br>CLH队列：在AQS中获取锁失败的线程会被封装成一个节点加入到阻塞队列中，每一个持有锁的线程在释放锁的时候都会唤醒其后继节点。<br>Condition队列：根据开发人员定义好的条件，为满足条件的线程将会进入到条件队列中并进入阻塞同步状态，但是条件队列中的线程在被唤醒之后不会继续往下执行，而是会出列并进入CLH队列的队尾，等待获取锁后再继续执行。</p><p><strong>两种锁</strong><br>独占锁：以独占模式获取到的排他锁，同一时刻只能有一个线程获取到锁，对应独占式获取同步状态<br>共享锁：以共享模式获取到的非排他锁，同一时刻能有多个线程获取到，对应共享式获取同步状态</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>next主题优化</title>
      <link href="/hlblog/2018/11/15/next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/"/>
      <url>/hlblog/2018/11/15/next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>next主题优化</p><a id="more"></a><h1 id="实现点击出现桃心效果"><a href="#实现点击出现桃心效果" class="headerlink" title="实现点击出现桃心效果"></a>实现点击出现桃心效果</h1><p>打开/themes/next/source/js/src ， 新建love.js文件，复制<a href="https://github.com/Neveryu/Neveryu.github.io/blob/master/js/src/love.js" target="_blank" rel="noopener">此处</a>的代码到love.js里面。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!function(e,t,a)&#123;function r()&#123;for(var e=0;e&lt;n.length;e++)n[e].alpha&lt;=0?(t.body.removeChild(n[e].el),n.splice(e,1)):(n[e].y--,n[e].scale+=.004,n[e].alpha-=.013,n[e].el.style.cssText=&quot;left:&quot;+n[e].x+&quot;px;top:&quot;+n[e].y+&quot;px;opacity:&quot;+n[e].alpha+&quot;;transform:scale(&quot;+n[e].scale+&quot;,&quot;+n[e].scale+&quot;) rotate(45deg);background:&quot;+n[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;var n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;,function(e)&#123;var a=t.createElement(&quot;style&quot;);a.type=&quot;text/css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &apos;&apos;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),function()&#123;var a=&quot;function&quot;==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;a&amp;&amp;a(),function(e)&#123;var a=t.createElement(&quot;div&quot;);a.className=&quot;heart&quot;,n.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;),t.body.appendChild(a)&#125;(e)&#125;&#125;(),r()&#125;(window,document);</span><br></pre></td></tr></table></figure></p><p>打开/themes/next/layout/_layout.swig文件， 在head标签内最后位置添加以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 页面点击小红心 --&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><h1 id="左上角-右上角的Github样式"><a href="#左上角-右上角的Github样式" class="headerlink" title="左上角/右上角的Github样式"></a>左上角/右上角的Github样式</h1><p>点击<a href="http://tholman.com/github-corners/" target="_blank" rel="noopener">这里</a>选择你喜欢的样式，复制其中的代码到themes/next/layout/_layout.swig文件中(放在<code>&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;</code>的下面)，并把href改为你的github地址。</p>]]></content>
      
      
      <categories>
          
          <category> next主题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> next主题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>AQS之CLH同步队列</title>
      <link href="/hlblog/2018/11/15/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E4%B9%8BCLH%E9%98%9F%E5%88%97/"/>
      <url>/hlblog/2018/11/15/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/AQS/AQS%E4%B9%8BCLH%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>在上一篇<a href="http://localhost:4000/2018/11/15/juc/AQS%E7%AE%80%E4%BB%8B/#more" target="_blank" rel="noopener">AQS简介</a>中有提到过AQS内部提供了一个CLH(Craig, Landin, and Hagersten)同步队列，用于处理多线程同时获取状态时的排队和阻塞的逻辑。<br>CLH同步队列是一个FIFO双向队列，在多线程竞争获取状态的情况下，将获取失败的线程及其等待状态等信息封装成节点加入到CLH队列中，并可能会使该节点阻塞起来。当持有同步状态的节点释放同步状态以后，会将其后继节点唤醒。CLH队列中非阻塞状态的节点会判断自己的前置节点是否为头结点，如果前置节点是头结点，就会尝试获取同步状态。</p><a id="more"></a><h1 id="队列节点"><a href="#队列节点" class="headerlink" title="队列节点"></a>队列节点</h1><p>一个CLH节点中包含的信息主要有当前线程的引用，等待状态，前置节点的引用，后继节点的引用等等,详情如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 标识当前节点为共享模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 标识当前节点为独占模式</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">        * 等待状态: 代表该节点已经取消获取状态的行为,一般是由于中断或者超时</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">        * 等待状态: 代表该节点的下一个节点需要被唤醒，在该节点释放状态以后将会唤醒后继节点</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 等待状态: 这个状态以后再说</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 等待状态: 这个状态以后再说</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 等待状态</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 前置节点的引用</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 后继节点的引用</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 指定线程的引用</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 指向下一个条件等待节点,用于条件队列中</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 返回true代表当前节点是以共享模式在等待</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="队列结构"><a href="#队列结构" class="headerlink" title="队列结构"></a>队列结构</h1><p>CLH同步队列的结构如下:<br><img src="http://www.hlblogs.com/images/juc/CLH-Sync-Queue.png" alt="ss"><br>这里来解释一下，为什么Head头结点没有被算在队列中,上面我们有讲到，当线程获取状态失败才会被封装成节点加入到CLH队列中,而头结点可以看成是一定已经成功获取同步状态的节点,所以头节点没有被算在CLH同步队列中。</p><h1 id="入列"><a href="#入列" class="headerlink" title="入列"></a>入列</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将当前线程和节点模式等信息封装成一个新的节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">//尝试入列,如果尾节点不为空，尝试将新生成的节点设置为尾节点。</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前尾节点为空或者尝试将新节点设置为尾节点的动作失败了，</span></span><br><span class="line">    <span class="comment">//就用一个死循环来重复处理，确保新的节点一定能加入到CLH队列中</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addWaiter方法中的参数是标识节点模式，这个参数只有两个选项，即Node.SHARED和Node.EXCLUSIVE。方法的内容比较简单，注释写的很清晰了。</p><p>enq方法用于一个无限的for循环来确保新生成的节点一定能加入到队列中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//无限循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">//如果尾节点为空，说明当前队列是一个空队列，</span></span><br><span class="line">            <span class="comment">//生成一个默认的新的节点作为头结点和尾节点</span></span><br><span class="line">            <span class="comment">//这个默认的新节点并没有持有同步状态，它会马上被队列中的后继节点取代。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">//只有成功将节点设置为尾节点，即成功加入队列，才能退出这个死循环</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>新节点在进入CLH队列以后会将前置节点的等待状态waitStatus设置为Node.SIGNAL,以用来将来前置节点释放同步状态以后将其后置节点(也就是刚刚入列的这个新节点)唤醒。这个设置非常的重要，我们来看看AQS是怎么做的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果当前节点的前置节点的等待状态已经被设置为waitStatus已经被设置为Node.SIGNAL,</span></span><br><span class="line">        <span class="comment">//那么当前节点就是可以阻塞的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//将前置节点的waitStatus设置为Node.SIGNAL</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS中提供了一个shouldParkAfterFailedAcquire方法来实现修改等待状态的功能，注意这个方法的真实作用是用来判断当前节点是否需要阻塞的。这个方法将来会用的比较多,等我们讲到AQS的阻塞和唤醒的时候再细说，这里粗略的了解一下即可。</p><h1 id="出列"><a href="#出列" class="headerlink" title="出列"></a>出列</h1><p>出列的过程也非常的简单，CLH队列是一个FIFO队列，头节点线程在释放状态以后会唤醒当前头节点的后继节点，而后继节点在被唤醒以后把自己设置为头节点，并断开与前置节点的关联，这样前置节点就出列了。<br>因为只有一个节点能获取到状态，所以这里是不需要使用CAS方式来保证的。</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Semaphore源码阅读笔记</title>
      <link href="/hlblog/2018/11/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/Semaphore%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/11/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/Semaphore%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Semphore底层是利用了AQS的共享式获取同步状态的机制</p><a id="more"></a><h1 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h1><p>Sync:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1192457210091910933L</span>;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        setState(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非公平的获取同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过一个无限循环去不停的尝试获取同步状态，没有排队机制</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放共享式获取的同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//通过一个无限循环去释放同步状态，确保能够成功的释放同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current + releases;</span><br><span class="line">            <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//减少可获取的同步状态</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reducePermits</span><span class="params">(<span class="keyword">int</span> reductions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">int</span> next = current - reductions;</span><br><span class="line">            <span class="keyword">if</span> (next &gt; current) <span class="comment">// underflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Permit count underflow"</span>);</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将可获取的同步状态数量置为0</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">drainPermits</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> current = getState();</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span> || compareAndSetState(current, <span class="number">0</span>))</span><br><span class="line">                <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FairSync(公平获取同步状态):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2014338818796000944L</span>;</span><br><span class="line"></span><br><span class="line">     FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">         <span class="keyword">super</span>(permits);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">             <span class="comment">//如果当前节点在CLH队列中有前置节点，本次获取同步状态失败。</span></span><br><span class="line">             <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                 <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">int</span> available = getState();</span><br><span class="line">             <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">             <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                 compareAndSetState(available, remaining))</span><br><span class="line">                 <span class="keyword">return</span> remaining;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>NonfairSync(非公平的获取同步状态):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">2694183684443567898L</span>;</span><br><span class="line"></span><br><span class="line">    NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">        <span class="keyword">super</span>(permits);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="获取同步状态"><a href="#获取同步状态" class="headerlink" title="获取同步状态"></a>获取同步状态</h1><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//尝试获取同步状态</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//尝试获取同步状态失败以后，进入CLH队列,在CLH队列中获取锁</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">//释放同步状态成功以后，唤醒后继节点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Exchanger源码阅读笔记</title>
      <link href="/hlblog/2018/11/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/Exchanger%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/11/14/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/Exchanger%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Exchanger源码阅读笔记</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cyclicbarrier和CountDownLatch对比</title>
      <link href="/hlblog/2018/11/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/CyclicBarrier%E5%92%8CCountDownLatch%E5%AF%B9%E6%AF%94/"/>
      <url>/hlblog/2018/11/13/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/CyclicBarrier%E5%92%8CCountDownLatch%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<p>Cyclicbarrier和CountDownLatch在功能和实现上的对比</p><a id="more"></a><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>CountDownLatch和CyclicBarrier对比</p><font size="3" color="blue">CountDownLatch比较适合使用在多个参与方(参与方的数量是不固定的)约定好了某些条件(可能一个也可能多个，但数量是固定的)，条件完成以后就能做某些事，但是这些条件要依赖于外部(可能是其他线程)来完成的情况下。</font><br><font size="3" color="blue">CyclicBarrier比较适合使用在多个参与方(参与方的数量是固定的)约定好了某一个条件，条件完成以后就能做某些事，但是这个条件必须要每个参与方都达到的情况下。</font><p>举例:<br>假如现在有一扇门，CountDownLatch和CyclicBarrier可以理解为门闩和门锁，CountDownLatch相当于门闩，CyclicBarrier相当于门锁。<br>CountDownLatch就像是门上的门闩，屋内的每个人可以拉开一个门闩，等到将门上的门闩全部拉开打开才能大门走向外面的世界。这个门闩是一开始就插好的。<br>CyclicBarrier就像是门上的门锁，几个人分别在几个不同的屋子里，大家相约一起出去，这样必须得等到所有的人都把门锁好了大家才能走，先锁好门的人等待没有锁好门的人。最后一个锁好门的人通知其他人以后大家才可以离开</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>CountDownLatch: AQS共享锁<br>CountDownLatch中只有释放锁的操作，各个线程其实并没有获取锁的操作，使用独占锁不划算</p><p>CyclicBarrier: ReentrantLock + Condition</p><p>1.如果CyclicBarrier采用共享锁会有什么问题？<br>使用共享锁,因为有阻塞队列的存在,多线程的执行就会变成串行的。</p><p>2.如果CountDownLatch采用ReentrantLock + Condition会有什么问题？<br>如果CountDownLatch使用ReentrantLock + Condition实现会变的比较复杂，因为ReentranLock和Condition背后代表着两个队列，即AQS中的CLH队列和Condition中的条件队列。CountDownLatch中需要扣除的数量是有限的，每个调用countDown方法线程只需要将指定的数量-1即可，使用CAS也不会存在长时间的自旋，对CPU的影响不会很大。个人认为Doug lea大神是在比较小的性能开销和较高的实现复杂度之间选择了前者。</p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Cyclicbarrier源码阅读笔记</title>
      <link href="/hlblog/2018/11/09/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/CyclicBarrier%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/11/09/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/CyclicBarrier%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>CyclicBarrier是juc中的并发工具类之一，它的特点是使得多条线程约定一个共同的点，等到相关的线程全部到达这个点再继续往下进行。以参加旅行团为例，到达某个景点以后所有的游客自由活动两小时，大家约定在某个点集合，然后去下一个景点，那么导游必须要等所有的游客全部到达约定好的集合地点以后才能带着游客前往下一个景点。</p><a id="more"></a><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"到达"</span>);</span><br><span class="line">            <span class="comment">//等待</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> index = cyclicBarrier.await();</span><br><span class="line">                System.out.println(index + <span class="string">"============"</span> + Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"所有线程全部到达了...."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> CyclicBarrierThread().start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread-1到达</span><br><span class="line">Thread-3到达</span><br><span class="line">Thread-2到达</span><br><span class="line">Thread-0到达</span><br><span class="line">Thread-4到达</span><br><span class="line">各线程全部到达了....</span><br><span class="line">0============Thread-4</span><br><span class="line">3============Thread-2</span><br><span class="line">1============Thread-0</span><br><span class="line">4============Thread-1</span><br><span class="line">2============Thread-3</span><br></pre></td></tr></table></figure></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><p>CyclicBarrier中的字段<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">/** The number of parties */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="comment">/* The command to run when tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"><span class="comment">/** The current generation */</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment"> * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment"> * generation or when broken.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure></p><p>CyclicBarrier有两个构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个构造函数，根据源码可知下面只有一个参数的构造函数内部调用的也是上面双参数的构造函数。在上面的案例中使用的也是双参数的构造函数。</p><p>这里我们先来埋下一个问题:</p><font size="3" color="red">为什么传入的Runnable实例会比我们在循环中生成的线程更早执行？</font><p>下面我们带着这个问题来进入CyclicBarrier的源码</p><p>首先来解释一下构造函数中的parties和count<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure></p><p>在构造函数中我们可以看到，parties和count的初始化数量是相同的，那么它们的作用分别是什么呢？<br>parties代表的是当前这个屏障所需要达到达到目标的总数量，它是不变的。<br>count代表的是当前未到达目标的数量，实际上CyclicBarrier的使用中，各线程所修改的就是count这个变量。</p><p>以上面的案例作为例子，我们假设for循环中生成的五条线程分别为t1,t2,t3,t4,t5.假设五条线程的开始执行顺序为t1-&gt;t2-&gt;t3-&gt;t4-&gt;t5.</p><p>首先t1开始执行，输出Thread-1到达，然后执行await方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到await方法内部只是调用了dowait方法，这个dowait方法是非常重要的核心方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//这里t1率先获取到锁，所以后续的线程会进入阻塞队列等待。</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//t1线程在释放锁以后会唤醒后继节点。</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先不考虑中断和Generation.broken<br>t1线程进入这个方法以后，int index = –count; count的初始化值为5，index的值为4，然后就进入for循环内，因为传入的timed为false,所以会执行trip.wait，这个方法主要做了三件事:<br>1.将当前线程加入到条件队列<br>2.释放当前线程所持有的锁，全部！<br>3.如果当前线程不在阻塞队列中，阻塞当前线程<br>这里就不再对Condition做详细说明了。<br>t1线程会在这里被阻塞起来加入到条件队列中并释放它所持有的全部的锁，它的锁释放以后，t2线程获取到锁，最终它和t1一样也被阻塞在这里，后续的t3,t4也是一样。<br>最后t5线程获取到锁，t5到达以后，经过前面t1,t2,t3,t4的执行，再执行int index = –count，得到的index的值就是0了，这样下面这个if语句内的代码就会执行了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">    <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">            <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先，得到我们在构造函数内传入的Runnable实例，如果它不为空就执行它，到这里我们可以解答上面的问题了，到这里t1-t5的方法都没有执行，而runnable的方法率先被执行了，这就解答了为什么runnable方法比其他线程内的方法先执行。<br>runnable方法执行以后，，还有一个比较重要的方法就是nextGeneration();方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看到这里的trip.signalAll();整个流程基本就通了，这行代码会唤醒所有阻塞在条件队列中的线程，并把它们添加到阻塞队列的队尾。然后它们会在阻塞队列中一一出列并获取锁执行相应的逻辑。<br>我们再回到dowait方法，线程在trip.await();这一步被阻塞，那么当线程被唤醒以后，都会继续往下执行。那么它如何退出这个for循环呢，注意下面这两行代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (g != generation)</span><br><span class="line">    <span class="keyword">return</span> index;</span><br></pre></td></tr></table></figure></p><p>在不考虑中断和超时的情况下，线程会在这一步就会退出for循环，那么generation是在什么时候发生变动的呢？<br>往前看nextGeneration方法，在方法内的最后一行generation被重新赋值了。</p><p>到这里，所有的线程都从阻塞中被唤醒出来并且退出了for循环，可以继续执行接下来的逻辑了。</p><h2 id="中断和超时"><a href="#中断和超时" class="headerlink" title="中断和超时"></a>中断和超时</h2><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><p>CyclicBarrier的await方法是可以响应中断的，如果某个调用CyclicBarrier实例的线程在执行await方法期间发生了中断，<br>那么它会响应中断，调用breakBarrier方法打断当前的CyclicBarrier实例,然后抛出中断异常。当前的CyclicBarrier实例被打断以后，其他的线程最终都会看到这次打断操作，然后抛出BrokenBarrierException.<br>再来看看breakBarrier方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法非常的简单，它做了三件事<br>1.generation.broken = true; 这个赋值操作会被其他所有的线程感知到，其他的线程感知到这一步赋值以后，会抛出BrokenBarrierException<br>2.count = parties; 将未获取到锁的线程的数量充值未初始值。<br>3.trip.signalAll(); 这个操作比较重要，它会唤醒条件队列中所有的线程，并将它们一一加入到阻塞队列的队尾。然后它们会在阻塞队列中一一出列并获取锁然后往下执行，最终由于generation.broken = true而抛出BrokenBarrierException。</p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>CyclicBarrier为使用者提供了超时策略，那么超时策略有什么不同呢？<br>我们知道，在不采用超时策略的时候，调用await方法的线程都会进入阻塞状态，直到最后一条线程执行await方法，然后这些线程才会被唤醒继续执行接下来的逻辑，<br>那么最后一个或者几个线程一直没有执行await方法，那么这些陷入阻塞状态的线程就会一直阻塞,这是我们所不希望看到的。而如果使用了可超时的方法，情况就完全不一样了。<br>说到超时不得不提到一个await方法的重载方法，之前我们提到的await方法是无参的，而带有超时功能的await方法是有两个参数的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过代码可知，CyclicBarrier中的两个await方法内部都是调用了dowait方法来实现的，在dowait方法中有一个for循环，这是一个死循环，循环中有这样一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!timed)</span><br><span class="line">    trip.await();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">    nanos = trip.awaitNanos(nanos);</span><br></pre></td></tr></table></figure></p><p>如果调用的是无参的await方法，那么这里的timed传入的就是false,然后进入第一个if体内进入阻塞状态，在达成条件之前一直阻塞不会。<br>如果调用的是有参的await方法, 那么这里的timed传入的就是true,然后进入第二个if体内进入阻塞状态，但是这种阻塞是有时间限制的，只会在指定的时间范围内处于阻塞状态。如果在指定的时间内没能满足条件(其实就是调用await相关方法的线程数量不足),那么当前线程就会被主动唤醒，执行下面这段代码后当前CyclicBarrier被打断，所有阻塞中的线程被唤醒，然后一一抛出BrokenBarrierException，当前线程抛出TimeoutException。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">    breakBarrier();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CountDownLatch源码分析</title>
      <link href="/hlblog/2018/11/06/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/CountDownLatch%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/11/06/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/CountDownLatch%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>CountDownLatch的字面意思是倒计时门闩，我们可以把它理解为门闩，这个门闩把门给从内部锁上了，不把它打开外面的人就进不到屋里去。那么如何才能把它打开呢？等到倒计时结束它就自动打开了！</p><font size="3" color="red">以下CountDownLatch简称CDL</font><a id="more"></a><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><p>我们先来看个demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLacthTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CountDownLacthTest countDownLacthTest  = <span class="keyword">new</span> CountDownLacthTest();</span><br><span class="line">        countDownLacthTest.doWork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line">        CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">        Executor e = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 10 个任务，提交给线程池来执行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">            e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等待所有的任务完成，这个方法才会返回</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">            System.out.println(<span class="string">"=finish="</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">        WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">            <span class="keyword">this</span>.i = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                doWork(i);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这个线程的任务完成了，调用 countDown 方法</span></span><br><span class="line">                doneSignal.countDown();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            System.out.println(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个demo中，用一个3条线程的线程池去处理10个任务。这10个任务必须全部完成以后才能输出=finish=，否则线程会一直阻塞在await方法处。<br>运行结果:<br>0<br>2<br>3<br>1<br>5<br>4<br>7<br>6<br>9<br>8<br>=finish=</p><p>从运行结果可以看出，各个任务执行完成的顺序是不固定的，但是=finish=一定是最后输出。原因是在任务没有全部完成的时候，线程会一直阻塞在await方法处。</p><p>本文的重点是对CDL的源码进行分析，所以不会对它的用法做过度深究。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>CDL的整个工作流程可分为三步<br>第一步: 构造实例(获取同步状态)<br>第二步: 阻塞<br>第三部: 释放同步状态-解除阻塞</p><h2 id="Sync内部类"><a href="#Sync内部类" class="headerlink" title="Sync内部类"></a>Sync内部类</h2><p>一个juc中非常常见的Sync内部类，继承了AQS类并实现了tryAcquiredShared方法和tryReleaseShared方法，前者是用来尝试共享式获取同步状态的，后者是用来尝试共享式释放同步状态的。通过这两个方法我们可以确定，CDL的特性是利用了AQS的共享式获取同步状态相关机制来实现的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">      Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">          setState(count);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> getState();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//尝试共享式获取同步状态,返回值大于0说明同步状态获取成功</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//尝试共享式释放同步状态,返回true说明同步状态已经全部释放成功</span></span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">          <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">              <span class="keyword">int</span> c = getState();</span><br><span class="line">              <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">              <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                  <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>CDL只有一个构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再来看看Sync的构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这两个构造方法都是比较简单的，这里我们可以看出，创建CDL实例的时候，构造方法中只做了一件事，就是将AQS底层的状态值修改为被传入的参数值，对应着上面demo中的任务数。<br>这里可以把它理解为有count个任务分别获取了一个数量的共享同步状态，等到任务结束会将持有的同步状态释放掉。</p><h2 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h2><p>CDL的阻塞通过调用await()方法或await(long,TimeUtil)来实现，这里先以await方法为例阐述阻塞的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法位于AQS类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过源码可以看出，CDL的await方法实际上是调用了AQS的acquireSharedInterruptibly(int)方法，这个方法是用来进行可中断的获取共享同步状态的(这里暂时不考虑中断问题)，在第二个条件判断中，调用tryAcquireShared方法进行了一次获取共享同步状态的尝试，这个方法在AQS中是一个抽象类，CDL中的Sync内部类对其进行了实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>tryAcquireShared方法实现的非常简单，这个方法出现的本意是为了处理获取共享同步状态的逻辑，乍一看这里的实现似乎与获取同步状态没有一关系，仔细想想确实没有关系，但是在这里，这个设计真的是非常的巧妙。<br>其实刚刚看构造函数的时候已经说过了，获取同步状态这一步已经在构造实例的时候完成了，那么这里的实现这个方法的作用其实就是<font size="3" color="blue">返回是否还有同步状态未被释放</font>.<br>这里会有两个情况:<br>1.在调用await方法的时候所有的同步状态已经全部释放<br>2.在调用await方法的时候所有的同步状态没有全部释放</p><p>如果是第一种情况呢，tryAcquireShared方法会返回1，再看看上面的acquireSharedInterruptibly方法，因为条件判断不通过，所以这个方法就执行完了，这样await方法也就顺利的执行完了，中间不会出现阻塞的情况。</p><p>那么第二种情况呢，tryAcquireShared方法会返回-1，这样会接着执行doAcquireSharedInterruptibly(arg)方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//封装一个新的节点进入阻塞队列</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来我们来看一下doAcquireSharedInterruptibly这个方法。<br>首先，封装一个共享模式的节点，进入阻塞队列，这个比较简单了,就是先尝试入列，入列失败就循环入列直到成功为止<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">//如果尾节点为空，那么头结点也为空，整个阻塞队列就是一个空队列</span></span><br><span class="line">            <span class="comment">//创建一个默认的节点作为头结点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后呢，就是进入一个死循环<br>在循环中获取到刚刚创建的新节点的前置节点，然后判断该前置节点是否为头结点，只有在前置节点为头结点的情况下，当前节点才有可能去竞争同步状态。<br>接着调用tryAcquireShared方法，因为此时任务还没有全部完成，所以同步状态没有被全部释放，所以这里的返回值为-1。<br>因为未能满足这里的的if条件，所以只能继续往下执行。<br>shouldParkAfterFailedAcquire(p, node)方法是用来判断当前节点线程是都应该阻塞的<br>parkAndCheckInterrupt()方法是用来阻塞线程，等到被唤醒以后返回中断状态的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AQS中的阻塞队列中每一个新节点的waitStatus默认为0，所以每个节点在第一次进入shouldParkAfterFailedAcquire方法时会将新节点的waitStatus置为Node.SIGNAL，然后第二次进入的时候第一个if条件判断出会结束整个方法，返回true,然后调用parkAndCheckInterrupt方法将线程阻塞在这里。</p><h2 id="释放同步状态-解除阻塞"><a href="#释放同步状态-解除阻塞" class="headerlink" title="释放同步状态-解除阻塞"></a>释放同步状态-解除阻塞</h2><p>CDL中的释放同步状态和解除阻塞是通过countDown方法来实现的，countDown方法每一次调用都会释放1个数量的同步状态，等到将全部的同步状态释放完毕，AQS中state为0的时候，就会去唤醒头结点的后继节点，然后将后继节点设置为头结点。并将此行为传播下去，直至所有的节点全部被唤醒。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的tryReleaseShared方法是有Sync内部类来实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，tryReleaseShared每一次调用都会对state进行减1的操作，等到state==0即同步状态全部释放以后才会返回true。<br>再回到刚刚的releaseShared方法，等到全部的同步状态都被释放完毕，开始执行doReleaseShared方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">//这里会唤醒后继节点，同时被唤醒的后继节点会继续唤醒它的后继节点，就这样一直将所有的节点全部唤醒</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    <span class="comment">//这里如果刚好有新的节点入列，那么它的waitStatus就会被修改为Node.SIGNAL(-1)，所以这里有可能会执行失败。</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这里如果被唤醒的后继节点没有成为新的头结点，就继续循环，否则就退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ReentrantLock源码阅读笔记</title>
      <link href="/hlblog/2018/11/01/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%94%81/ReentrantLock%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
      <url>/hlblog/2018/11/01/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/java/juc/%E9%94%81/ReentrantLock%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>ReentrantLock是juc提供的一种可重入的互斥锁，对于不同线程来说，它是互斥的，同一时间只可能有一个线程获取到锁，其他的企图获取锁的线程都将阻塞起来等待持有锁的线程释放锁。对于同一线程来说，它是可重入的，同一个线程能够多次获取到同一把锁，只是在释放的时候需要将线程获取到的全被重入锁都释放掉才算是释放完成。</p><a id="more"></a><h1 id="获取独占锁"><a href="#获取独占锁" class="headerlink" title="获取独占锁"></a>获取独占锁</h1><p>1.调用Lock方法加锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//CAS尝试抢占独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        <span class="comment">//如果抢占成功，将本线程设置为独占锁持有线程</span></span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 2.如果抢占失败，调用AQS的acquire方法</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2.调用AQS的acquire方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 2.1调用tryAcquire方法尝试获取锁，此方法AQS未实现，留给子类实现</span></span><br><span class="line"><span class="comment">// ReentrantLock中的FairLock和NonFairLock均对它进行了实现</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line"><span class="comment">// 2.2 addWaiter方法将当前线程封装成一个节点加入CLH队列</span></span><br><span class="line"><span class="comment">// 2.3  调用acquireQueue方法循环获取锁，如果线程需要阻塞，就阻塞线程，此方法位于AQS类中  </span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.1 尝试获取锁<br>调用tryAcquire方法尝试获取锁，此方法AQS未实现，留给子类实现，ReentrantLock中的FairLock和NonFairLock均对它进行了实现，这里以NonFairLock中的实现为例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//nonfairTryAcquire类位于ReentrantLock中的内部类Sync</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line"><span class="comment">//获取加锁状态</span></span><br><span class="line">          <span class="keyword">int</span> c = getState();</span><br><span class="line"><span class="comment">//加锁状态为0说明此时并没有任何线程持有锁</span></span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//尝试抢占锁</span></span><br><span class="line">              <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                  setExclusiveOwnerThread(current);</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">//如果已经有线程持有了锁，检查持有锁的线程是否是当前线程</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line"><span class="comment">//如果持有锁的线程就是当前线程，锁重入，返回true,获取成功</span></span><br><span class="line">              <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">              <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">              setState(nextc);</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line"><span class="comment">//如果锁已经被持有并且持有锁的线程不是当前线程，返回false，本次获取锁失败</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.2 调用addWaiter方法将当前线程封装成一个节点加入CLH队列，此方法位于AQS类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这里的mode参数为AQS.Node类中的Node.EXCLUSIVE，这是一个Node引用，用来标识当前节点处于独占模式</span></span><br><span class="line">       Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">       <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">       Node pred = tail;</span><br><span class="line">       <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">           node.prev = pred;</span><br><span class="line"><span class="comment">//尝试将本次生成的新节点设置为新的尾节点，如果设置成功，说明新节点入队成功</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line"><span class="comment">//新节点入队成功以后，将前置节点的后置节点设置为本次生成的新节点，然后将新节点返回。</span></span><br><span class="line">               pred.next = node;</span><br><span class="line">               <span class="keyword">return</span> node;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">// 2.2.1 如果尾节点为空，或者新节点未能成功设置为新的尾节点，调用enq方法循环操作，直至成功为止。</span></span><br><span class="line">       enq(node);</span><br><span class="line">       <span class="keyword">return</span> node;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.2.1 如果尾节点为空，或者新节点未能成功设置为新的尾节点，调用enq方法循环操作，直至成功为止，此方法位于AQS类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line"><span class="comment">//这是一个死循环，只有将节点成功加入阻塞队列中才有可能退出</span></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           Node t = tail;</span><br><span class="line">           <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line"><span class="comment">//如果尾节点为空，就生成一个新的节点，将它设置为头结点，一般来说，头结点和尾节点要么都为空，要么都不为空</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                   tail = head;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果尾节点不为空，</span></span><br><span class="line">               node.prev = t;</span><br><span class="line"><span class="comment">//尝试将参数中传过来的节点（也就是本次生成的新节点）设置为新的尾节点，如果设置成功，说明新节点入队成功</span></span><br><span class="line">               <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                   t.next = node;</span><br><span class="line"><span class="comment">//新节点入队成功以后，将前置节点的后置节点设置为本次生成的新节点，然后将新节点返回。</span></span><br><span class="line">                   <span class="keyword">return</span> t;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.3  调用acquireQueue方法循环获取锁，如果线程需要阻塞，就阻塞线程，此方法位于AQS类中<br>这个方法内部是一个死循环，只有获取锁以后才能退出这个循环，所以当该方法执行完毕以后，当前线程一定是成功持有锁的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">//获取节点的前置节点</span></span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line"><span class="comment">//tryAcquire方法参考步骤2.1</span></span><br><span class="line"><span class="comment">//如果该节点的前置节点是头结点，并且该节点成功获取锁，将该节点设置为头结点</span></span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span> interrupted;</span><br><span class="line">               &#125;</span><br><span class="line"><span class="comment">//2.3.1 调用shouldParkAfterFailedAcquire方法判断节点的线程是否需要阻塞</span></span><br><span class="line"><span class="comment">//此方法最多只会在第一次调用时返回false</span></span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line"><span class="comment">//2.3.2 如果该节点线程需要阻塞，调用parkAndCheckInterrupt方法阻塞线程</span></span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>这里来说明一下上面代码里关于头结点的判断，也就是if (p == head &amp;&amp; tryAcquire(arg))<br>这里为什么要先判断是否是头结点呢？对于阻塞队列中的任何一个节点来说，只有它的前置节点是头结点，它才有可能获取到锁，这与当前锁是公平锁还是非公平锁无关，只要进了阻塞队列，全都得按顺序来。  </p><p>2.3.1  调用shouldParkAfterFailedAcquire方法判断节点的线程是否需要阻塞，此方法位于AQS类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">           <span class="comment">//如果前置节点的后置节点等待状态已经设置为SIGNAL，即需要被唤醒，那么就可以放心的将当前节点的线程阻塞，</span></span><br><span class="line"><span class="comment">//等到前置节点释放锁时会唤醒当前线程</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="comment">//如果前置节点的后置节点等待状态值大于0，说明节点已经取消获取锁的操作，就将该节点的前置节点设置为前置节点的前置接节点</span></span><br><span class="line"><span class="comment">//直到找到一个未取消的前置节点。</span></span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               node.prev = pred = pred.prev;</span><br><span class="line">           &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">           pred.next = node;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//如果前置节点的后置节点状态即不等于SIGNAL(-1),也不大于0，就将它设置为signal(-1)</span></span><br><span class="line"><span class="comment">//这个waitStatus默认都是0</span></span><br><span class="line">           compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>2.3.2 如果该节点线程需要阻塞，调用parkAndCheckInterrupt方法阻塞线程，此方法位于AQS类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//阻塞当前线程</span></span><br><span class="line">  LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">//线程被唤醒后返回中断状态</span></span><br><span class="line">       <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>加锁过程的总结：<br>在ReentrantLock中，当某个线程请求获取非公平锁的时候，会立即进行一次抢占尝试，如果没能抢到锁，会再次进行一次尝试，但是这第二次尝试有一个前提，那就是锁并没有被任何线程持有。如果已经被某个线程持有了，就不会进行第二次的抢占尝试，而是会去判断当前线程是否就是持有锁的那个线程，如果恰好是当前线程持有锁，那么就进行一次锁重入的操作，本次获取锁成功。如果当前线程并不是持有锁的线程，那么本次获取锁就失败了。本次获取锁失败以后，就把当前线程及锁类型信息（独占式还是共享式，ReentranLock中默认是独占式）封装成一个节点，加入到CLH队列中。<br>新的节点加入到队列以后，检测尾节点存不存在，如果存在，会循环尝试把新节点设置为新的尾节点，设置成功以后开始一个死循环，把新节点的前置节点的waitStatus（相当于该节点的后继节点的等待状态，默认0）设置为signal(-1),设置完以后新节点线程进入阻塞状态，当新节点的前置节点释放锁以后会根据waitStatus来唤醒这个新节点。等到新节点被其前置节点唤醒以后（此时其前置节点就是头结点），新节点会再次开始循环尝试获取锁，直到获取成功为止。  </p><p>公平锁的获取过程和非公平锁区别不大，非公平锁获取锁的过程会有两次抢占，第一次抢占是非公平锁独有的，公平锁中不存在这次操作。第二次抢占公平锁也同样会有，但是非公平锁的抢占只要当前锁没有被持有就会进行，而公平锁除了要判断当前锁有没有被持有之外，还要判断此时阻塞队列中有没有节点正在排队，如果有节点正在排队，那么就不会进行这一次抢占，乖乖到队列之后去排队。<br>不管是公平锁还是非公平锁，在抢占锁失败以后，都会进入阻塞队列，这以后的操作时一样的。</p><h1 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h1><p>释放锁的过程非常简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       sync.release(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法位于AQS类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//尝试释放锁</span></span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line"><span class="comment">//唤醒后继节点</span></span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放锁，因为锁是可重入的，所以必须得要线程所持有的全部锁都释放以后才会返回true。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line"><span class="comment">//当前线程是否为持有锁的线程，如果不是，将会抛出异常</span></span><br><span class="line">          <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">          <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">              free = <span class="keyword">true</span>;</span><br><span class="line">              setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          setState(c);</span><br><span class="line">          <span class="keyword">return</span> free;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒后继节点。。。此方法位于AQS类</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">       <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">       <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">           compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           s = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span></span><br><span class="line">           <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">               <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                   s = t;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">           <span class="comment">//如果有后继节点线程存在，将它唤醒</span></span><br><span class="line">           LockSupport.unpark(s.thread);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>解锁过程的总结：<br>不管是公平锁还是非公平锁，解锁的过程几乎都是一样的，先释放锁，释放成功以后唤醒后继节点就完了。</p><p>整个独占锁的获取和释放的过程就是这样了，但是使用这种方式获取锁对中断和获取时间是不敏感的，也就是说这种方式不会响应中断，也没会超时，在获取到锁之前线程会一直处于阻塞队列中直到获取成功为止。</p><hr><h1 id="响应中断的获取锁"><a href="#响应中断的获取锁" class="headerlink" title="响应中断的获取锁"></a>响应中断的获取锁</h1><p>调用ReentrantLock中的 lockInterruptibly方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法位于AQS类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">           doAcquireInterruptibly(arg);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法位于AQS类</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">       <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">               <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                   failed = <span class="keyword">false</span>;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line"><span class="comment">//此方法在线程被唤醒以后会返回中断状态，详情可参考2.3.2</span></span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (failed)</span><br><span class="line">               cancelAcquire(node);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>根据代码可以看出，响应中断的获取锁并没有什么大的不同，与前面获取锁的方式相比，仅仅有两个不同<br>一. 在尝试获取锁之前先判断中断状态，如果该线程已经被中断，则抛出中断异常，停止获取锁。<br>二. 在线程的阻塞过程中，如果该线程被中断了，那么在线程被唤醒以后，将会抛出中断异常，然后取消获取锁。</p><hr><h1 id="超时的获取锁"><a href="#超时的获取锁" class="headerlink" title="超时的获取锁"></a>超时的获取锁</h1><p>超时的获取锁在原本阻塞是获取锁的方式上增加了一个超时时间，就是说它如果没有获取到锁不会一直阻塞在阻塞队列中，而是会在到达超时时间以后就放弃获取锁，本次获取锁失败。与此同时，这种方式也是会响应中断的，如果在获取锁的过程中线程被中断了，那么线程会抛出中断异常，然后取消获取锁。<br>ReentrantLock中提供了<font color="blue" size="3">tryLock(long,TimeUtil)</font>方法来超时的获取锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//参数一：时间数值   参数二：时间单位</span></span><br><span class="line">    <span class="comment">//将传入的参数统一转换为纳秒来进行处理</span></span><br><span class="line">    <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法位于AQS</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//响应中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//tryAcquire方法获取锁 ，doAcquireNanos方法超时的获取锁</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此方法位于AQS</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//计算出超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="comment">//生成新的节点并加入到阻塞队列中</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="comment">//用于判断是否取消获取锁</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//计算超时的剩余时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">//指定时间内阻塞</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="comment">//响应中断，抛出中断异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//取消获取锁</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面代码可以看出，超时的获取锁还是比较容易理解的，只是在自旋的时候加入对超时时间的判断，如果已经到达了超时时间，就退出自旋状态，本次获取锁失败。还有一个不同就是关于线程阻塞，这种方式获取锁也可能会阻塞线程，但是不会一直阻塞下去，这里的阻塞计算没有其他线程来唤醒被阻塞的线程，也会在指定的时间内自我唤醒。</p><hr><h1 id="取消获取锁"><a href="#取消获取锁" class="headerlink" title="取消获取锁"></a>取消获取锁</h1><p>前面对ReentrantLock中锁的获取和释放做了一定的说明，下面再来说说取消获取锁这个操作。<br>取消获取锁其实就相当于将原本成功进入阻塞队列的节点取消入队，那么它一般会在什么场景下发生呢？<br>1.程序有Bug,被动抛出异常<br>2.响应中断，主动抛出中断异常<br>仔细观察阻塞获取锁，中断获取锁，超时获取锁这三种获取方式的代码，会发现使用这三种方式获取锁的时候都会涉及到下面这段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (failed)</span><br><span class="line">        cancelAcquire(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cancelAcquire方法就是用来取消获取锁的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ignore if node doesn't exist</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Skip cancelled predecessors</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are the tail, remove ourselves.</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If successor needs signal, try to set pred's next-link</span></span><br><span class="line">        <span class="comment">// so it will get one. Otherwise wake it up to propagate.</span></span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp; ((ws = pred.waitStatus) == Node.SIGNAL || (ws &lt;= <span class="number">0</span> &amp;&amp;compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp; pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java源码阅读笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SpringCloud优化</title>
      <link href="/hlblog/2010/01/11/springcloud/SpringCloud%E4%BC%98%E5%8C%96/"/>
      <url>/hlblog/2010/01/11/springcloud/SpringCloud%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>SpringCloud优化记录。</p><a id="more"></a><h1 id="核心服务性能优化"><a href="#核心服务性能优化" class="headerlink" title="核心服务性能优化"></a>核心服务性能优化</h1><p>接口的响应速度不能太慢，一般200ms以内返回是比较好的，如果某个接口的响应速度过慢，那么它是无法应对高并发的场景的。<br>如果接口响应时间比较慢，那么要想尽一切办法，来提高响应速度:</p><ol><li>代码优化: 包括业务和技术两方面</li><li>sql语句优化: 尽量避免又臭又长的大sql，最好是只采用简单的单表查询。</li><li>数据库优化: 加索引，索引优化</li><li>缓存: ehcache、redis等等</li></ol><h1 id="超时时长的设置"><a href="#超时时长的设置" class="headerlink" title="超时时长的设置"></a>超时时长的设置</h1><p>为了避免超时的情况发生，很多人会把SpringCloud中的超时时间设置的比较大，这样的确可以在一定程度上避免超时的情况，但是调高超时时间可能会导致大量的线程被占用，导致后续请求没有线程来处理，使得接口的响应速度急剧下降。超时时长一般设置1s比较合理。如果设置成1s的接口频繁超时，那么就要考虑优化那个接口了。</p><h1 id="失败重试的设置"><a href="#失败重试的设置" class="headerlink" title="失败重试的设置"></a>失败重试的设置</h1><p>将SpringCloud中的超时时长设置成1s好像没什么问题了，但是在网络抖动的情况下，很有可能导致接口的响应时间超过1s，这个时候应该怎么办呢?总不能等待用户刷新产生新的请求吧? 所以该有的重试还是需要设置的。这个重试一般是配合着超时时长来做的,如果某次请求失败了，就进行一次重试，如果重试依然失败，就换一台机器进行再次重试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ribbon:</span><br><span class="line">   ConnectionTimeout: <span class="number">1000</span></span><br><span class="line">   ReadTimeout: <span class="number">1000</span></span><br><span class="line">   OkToRetryOnAllOperations: <span class="keyword">true</span></span><br><span class="line">   MaxAutoRetries: <span class="number">1</span></span><br><span class="line">   MaxAutoRetriesNextServer: <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h1 id="接口的幂等性"><a href="#接口的幂等性" class="headerlink" title="接口的幂等性"></a>接口的幂等性</h1><p>所谓接口的幂等性，就是说这个接口无论被访问多少次，产生的结果都是唯一的，比如一个更新请求在特殊情况下，比如上面的重试，发送了两次，那么接口必须保证只有一次能成功。常见的方案有:</p><ol><li>利用数据库唯一索引来保证幂等性</li><li>通过在redis中设置唯一id来保证幂等性</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
